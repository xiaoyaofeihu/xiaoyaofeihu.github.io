<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/page/2/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/page/2/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/JVM/JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/JVM/JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌JVM主要组成部分有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM主要组成部分有哪些？"><a href="#👌JVM主要组成部分有哪些？" class="headerlink" title="👌JVM主要组成部分有哪些？"></a>👌JVM主要组成部分有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p><img src="/2025/05/06/JVM/JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/bfRGipU0bnWvup3D/1725898764439-e7db4bb9-4d60-4b85-9b3d-02c5dbfd311c-379175.png" alt="1725898764439-e7db4bb9-4d60-4b85-9b3d-02c5dbfd311c.png"></p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>类加载子系统负责将 .class 文件加载到内存中，并进行验证、准备、解析和初始化。</p>
<p><strong>主要功能</strong>：</p>
<p><strong>加载</strong>：从文件系统或网络中读取 .class 文件。</p>
<p><strong>验证</strong>：确保字节码文件的正确性和安全性。</p>
<p><strong>准备</strong>：为类的静态变量分配内存并设置默认初始值。</p>
<p><strong>解析</strong>：将符号引用转换为直接引用。</p>
<p><strong>初始化</strong>：执行类的静态初始化块和静态变量的初始化。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM 在运行时将内存划分为多个不同的数据区域，每个区域都有特定的用途。</p>
<p><strong>方法区（Method Area）</strong>：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。</p>
<p><strong>堆（Heap）</strong>：存储所有对象实例和数组，是垃圾收集的主要区域。</p>
<p><strong>Java 栈（Java Stacks）</strong>：每个线程都有自己的 Java 栈，存储局部变量表、操作数栈、动态链接、方法返回地址等信息。</p>
<p><strong>本地方法栈（Native Method Stacks）</strong>：为本地方法调用服务，存储本地方法调用的状态。</p>
<p><strong>程序计数器（Program Counter Register）</strong>：每个线程都有自己的程序计数器，指示当前线程执行的字节码行号。</p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>执行引擎负责执行字节码指令。</p>
<p><strong>主要组件</strong>：</p>
<p><strong>解释器（Interpreter）</strong>：逐条解释执行字节码指令，速度较慢。</p>
<p><strong>即时编译器（Just-In-Time Compiler, JIT）</strong>：将热点代码（频繁执行的代码）编译为本地机器码，提高执行速度。</p>
<p><strong>垃圾收集器（Garbage Collector, GC）</strong>：自动管理内存，回收不再使用的对象，防止内存泄漏。</p>
<h2 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h2><p>本地接口（通常是 Java Native Interface, JNI）允许 Java 代码与本地（非 Java）代码进行交互。</p>
<p><strong>主要功能</strong>：</p>
<p>调用本地方法（通常是用 C 或 C++ 编写的）。</p>
<p>允许 Java 代码使用操作系统特性或访问硬件。</p>
<h2 id="本地方法库"><a href="#本地方法库" class="headerlink" title="本地方法库"></a>本地方法库</h2><p>本地方法库是存储本地方法实现的动态链接库（如 .dll 文件或 .so 文件）。</p>
<p><strong>主要功能</strong>：</p>
<p>提供本地方法的具体实现。</p>
<p>由本地接口调用以执行本地代码。</p>
<h3 id="JVM-主要组成部分的图示"><a href="#JVM-主要组成部分的图示" class="headerlink" title="JVM 主要组成部分的图示"></a>JVM 主要组成部分的图示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">|     类加载子系统 (Class Loader Subsystem)    |</span><br><span class="line">+---------------------------+</span><br><span class="line">|         运行时数据区 (Runtime Data Area)         |</span><br><span class="line">|  - 方法区 (Method Area)                        |</span><br><span class="line">|  - 堆 (Heap)                                   |</span><br><span class="line">|  - Java 栈 (Java Stacks)                       |</span><br><span class="line">|  - 本地方法栈 (Native Method Stacks)           |</span><br><span class="line">|  - 程序计数器 (Program Counter)                |</span><br><span class="line">+---------------------------+</span><br><span class="line">|          执行引擎 (Execution Engine)           |</span><br><span class="line">|  - 解释器 (Interpreter)                        |</span><br><span class="line">|  - 即时编译器 (Just-In-Time Compiler, JIT)      |</span><br><span class="line">|  - 垃圾收集器 (Garbage Collector, GC)          |</span><br><span class="line">+---------------------------+</span><br><span class="line">|         本地接口 (Native Interface)            |</span><br><span class="line">+---------------------------+</span><br><span class="line">|     本地方法库 (Native Method Libraries)      |</span><br><span class="line">+---------------------------+</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/redis%E7%9A%84%E5%86%85%E5%AD%98%E7%94%A8%E5%AE%8C%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌redis的内存用完了会发生什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis的内存用完了会发生什么？"><a href="#👌redis的内存用完了会发生什么？" class="headerlink" title="👌redis的内存用完了会发生什么？"></a>👌redis的内存用完了会发生什么？</h1><p>redis 内存用完之后发生的现象主要取决于我们配置的内存回收策略。默认是noeviction，这个策略不会删除任何的键，当内存不足的时候，就会报错。这种策略，我们一般不使用。常见使用的就是 lru，回收最近最少使用的有过期时间的键。其他的策略还比如 randow，可以回收随机的键。ttl 按照最短的过期时间来进行回收。以上。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>lru，lfu，random，无过期</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>当Redis的内存用完时，会根据配置的内存回收策略采取不同的措施。可以在内存达到限制时决定如何处理新的写请求。主要的策略有如下 8 种。</p>
<h3 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h3><ol>
<li><strong>noeviction</strong>：不删除任何键，当内存不足时返回错误。这是默认策略。</li>
</ol>
<p>当内存达到限制时，Redis将不再接受任何写请求，并返回错误。例如，客户端尝试设置新键时，会收到类似以下的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM command not allowed when used memory &gt; &#x27;maxmemory&#x27;.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>allkeys-lru</strong>：使用最近最少使用（LRU）算法回收所有键。</li>
<li><strong>volatile-lru</strong>：使用最近最少使用（LRU）算法回收设置了过期时间的键。</li>
</ol>
<p>Redis将根据LRU算法选择最近最少使用的键进行删除，以腾出空间存储新的数据。allkeys-lru会在所有键中选择，volatile-lru只会在设置了过期时间的键中选择。</p>
<ol start="4">
<li><strong>allkeys-random</strong>：随机回收所有键。</li>
<li><strong>volatile-random</strong>：随机回收设置了过期时间的键。</li>
</ol>
<p>Redis会随机选择一些键进行删除，以腾出空间。allkeys-random会在所有键中选择，volatile-random只会在设置了过期时间的键中选择。</p>
<ol start="6">
<li><strong>volatile-ttl</strong>：回收那些剩余生存时间（TTL）最短的键。</li>
</ol>
<p>Redis将选择那些剩余生存时间（TTL）最短的键进行删除。</p>
<ol start="7">
<li><strong>volatile-lfu</strong>：使用最长时间没有被使用（LFU）算法回收设置了过期时间的键。</li>
<li><strong>allkeys-lfu</strong>：使用最长时间没有被使用（LFU）算法回收所有键。</li>
</ol>
<p>Redis将根据LFU算法选择最近最少使用的键进行删除。volatile-lfu只会在设置了过期时间的键中选择，allkeys-lfu会在所有键中选择。</p>
<h3 id="配置内存回收策略的方式"><a href="#配置内存回收策略的方式" class="headerlink" title="配置内存回收策略的方式"></a>配置内存回收策略的方式</h3><p>redis.conf文件中配置内存回收策略，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>

<p>也可通过命令行参数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --maxmemory 100mb --maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/" itemprop="url">👌redis的同步机制是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis的同步机制是什么"><a href="#👌redis的同步机制是什么" class="headerlink" title="👌redis的同步机制是什么?"></a>👌redis的同步机制是什么?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>redis 的同步机制主要是主从同步，一开始从服务器发送同步命令，主服务器接收到之后，就会生成一个 rdb 的文件，然后传输给从服务器，从服务器接收到之后，立马进行数据的恢复。然后当主服务器再次接收到写命令的时候，会发给从服务器。这个过程是一个异步复制，主服务器不会等待结果。这样就完成了主从复制，主要的核心步骤就是这些。如果同步机制发生问题的话，从服务器可以进行断线重连。还可以做集群、哨兵，来自动切换。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>主要还是考主从同步原理和如何进行配置，还可以带一点故障的处理。面试官主要是想看看你对集群有没有一定的了解，redis 主从的数据复制有没有了解。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>rdb 快照，增量同步，故障机制</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>redis的同步机制主要涉及主从复制，主从复制机制允许一个服务器（主服务器）将数据复制到一个或多个服务器（从服务器）。从服务器可以是只读的，也可以接受写操作，但这些写操作不会被同步回主服务器。</p>
<h3 id="初次同步"><a href="#初次同步" class="headerlink" title="初次同步"></a>初次同步</h3><p>当从服务器第一次连接到主服务器时，或者当从服务器与主服务器的连接中断后重新连接时，会触发一次全量同步过程。</p>
<ol>
<li><strong>从服务器发送SYNC命令</strong>：从服务器向主服务器发送SYNC命令，请求进行同步。</li>
<li><strong>主服务器生成RDB快照</strong>：主服务器接收到SYNC命令后，会生成一个RDB（Redis Database）快照文件，并在生成过程中将所有新写入的命令记录到一个缓冲区中。</li>
<li><strong>传输RDB文件</strong>：主服务器将生成的RDB文件发送给从服务器。从服务器接收到RDB文件后，会清空自身的数据库并加载这个RDB文件。</li>
<li><strong>传输缓冲区中的命令</strong>：主服务器将缓冲区中的所有写命令发送给从服务器，从服务器依次执行这些命令，以确保数据完全同步。</li>
</ol>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>在初次同步完成后，主从服务器会保持连接状态，主服务器会将后续的所有写命令实时发送给从服务器，从服务器执行这些命令以保持数据的一致性。</p>
<h2 id="同步机制如何配置"><a href="#同步机制如何配置" class="headerlink" title="同步机制如何配置"></a>同步机制如何配置</h2><h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><p>主服务器的配置通常不需要特别设置，只需要确保其能够接受从服务器的连接请求。</p>
<h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><p>在从服务器的配置文件中，需要指定主服务器的IP地址和端口号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;master-ip&gt; &lt;master-port&gt;</span><br><span class="line">replicaof 192.168.1.100 6379</span><br></pre></td></tr></table></figure>

<h2 id="同步机制的故障处理"><a href="#同步机制的故障处理" class="headerlink" title="同步机制的故障处理"></a>同步机制的故障处理</h2><h4 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h4><p>当从服务器与主服务器的连接中断时，从服务器会自动尝试重连。在重连成功后，从服务器会根据情况选择进行全量同步或增量同步。</p>
<h4 id="主从切换"><a href="#主从切换" class="headerlink" title="主从切换"></a>主从切换</h4><p>在高可用环境中，可以使用Redis Sentinel或Redis Cluster来实现自动主从切换。当主服务器发生故障时，Sentinel或Cluster会自动选举一个新的主服务器，并通知其他从服务器进行同步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/redis%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/redis%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌redis的高级数据类型有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis的高级数据类型有哪些？"><a href="#👌redis的高级数据类型有哪些？" class="headerlink" title="👌redis的高级数据类型有哪些？"></a>👌redis的高级数据类型有哪些？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>面对一些复杂的场景，redis提供了一些高级数据类型，来进行了功能的扩展。主要有四种，bitmaps，hyperloglog，geo，stream。stream 不是非常常用，主要是用来实现消息队列功能。常用的就是 bitmap，bitmap 的 0，1 特性，非常实用于签到，或者存在，不存在这种类型判断，以及在大量数据下，快速统计是否结果。bitmap 非常节省空间，相比于传统的存储数据后，在 mysql 等层面统计，bitmap 更加适用。其次就是hyperloglog 主要是用于一些数量的统计，不过要允许误差，他不会存具体的内容，会帮助我们进行数据的统计，像常见的网站访问统计，就非常适合这个数据结构。geo 主要是做地理位置的计算，通过经度和纬度来定位位置，经过运算可以得到距离，附近范围的坐标等等。像比如美团外卖的附近商家，地图的距离测算，都可以通过 geo 的结构来进行实现，以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>这道题问的比较少，如果在问你基础数据类型的时候，你补了一句，还有三种高级类型，如果面试官感兴趣的话，会继续的追问你。不过三种里面最常用的就是 bitmap，其他用的比较少，重点关注 bitmap 即可。hyperloglog，geo 都不常见，无需关注。作为了解即可。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>bitmap，二进制位统计，签到功能，hyperloglog，大数据量统计，geo，地理位置，经纬度，附近的人</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="一、-Bitmaps"><a href="#一、-Bitmaps" class="headerlink" title="一、 Bitmaps"></a>一、 Bitmaps</h2><p>位图就是一个用二进制位（0和1）来表示数据的结构。可以把它想象成一排开关，每个开关只能是开（1）或者关（0）。这些开关排成一行，从左到右编号，编号从0开始。</p>
<p>目的就是操作某一个位置的数据变成 1 或者 0。</p>
<h3 id="主要操作命令"><a href="#主要操作命令" class="headerlink" title="主要操作命令"></a>主要操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT jichi 4 1</span><br></pre></td></tr></table></figure>

<p>按照上图，我们其实就是把 4 位设置成了 1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT jichi 4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT jichi  //获取bitmap里面有多少个1</span><br></pre></td></tr></table></figure>

<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>基于上面我们按照大家常见的比如用户签到系统，来做一个例子的说明。</p>
<p><font style="color:#2F8EF4;">假设我们有一个用户签到系统，我们可以用 bitmap 来记录每个用户每天是否签到。比如，一个月有30天，我们可以用30个位来表示这个月的签到情况，我们就可以如此设计。</font></p>
<p><font style="color:#2F8EF4;">第1天签到：第0位设为1。第2天没签到：第1位设为0。第3天签到：第2位设为1。以此类推…</font></p>
<p>这个例子就用上面三个命令即可完成，setbit 设置签到位置，getbit 判断某一天有没有签到，bitcount 获取总共签了多少次到。</p>
<p>假设用户在第1天和第3天签到，那么 bitmap 的值就是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101000000000000000000000000000</span><br></pre></td></tr></table></figure>

<h3 id="为什么用-bitmap"><a href="#为什么用-bitmap" class="headerlink" title="为什么用 bitmap"></a>为什么用 bitmap</h3><p><strong>类似签到，活跃情况，这些场景，假设我们用数据库存储，可能是一条一条的，统计起来也费时和麻烦，如果使用 bitmap，可以进行非常快速的统计，并且 bitmap 每个位只是二进制位，非常节省空间。</strong></p>
<p><strong>扩展起来，其实比如判断用户有没有权限，假设把某个权限作为一个位置，新增作为 1，删除作为 2，那么这种场景也是可以很快知道用户是否有权限的一种方式。</strong></p>
<p><strong>总之涉及单位置判断的，是否的场景，bitmap 比较靠谱。</strong></p>
<hr>
<h2 id="二、HyperLogLog"><a href="#二、HyperLogLog" class="headerlink" title="二、HyperLogLog"></a>二、HyperLogLog</h2><p>HyperLogLog 用于计算数据集中不重复元素的数量，是 Redis 提供的一种基数统计的数据结构。当我们需要统计大量数据中有多少不同的元素时，直接存储所有元素会占用大量内存。例如，统计一个网站一天内有多少不同的IP地址访问。如果直接存储所有IP地址，内存消耗会非常大。HyperLogLog通过巧妙的数学方法，可以在很小的内存占用下，提供一个非常接近的估算值。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<blockquote>
<p>什么是基数？？</p>
<p><font style="color:rgb(51, 51, 51);">比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</font></p>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><font style="color:rgb(51, 51, 51);">常用命令</font></h3><p>HyperLogLog 在 Redis 中以字符串的形式存在，但是只能作为计数器来使用，并不能获取到集合的原始数据。</p>
<p>主要涉及三个命令：</p>
<p><strong>添加元素</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element1 element2 ...</span><br><span class="line">例如：PFADD jichihll jichi jitui</span><br></pre></td></tr></table></figure>

<p><strong>估算基数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT key</span><br><span class="line">PFCOUNT jichihll</span><br><span class="line"></span><br><span class="line">返回的就是 2</span><br></pre></td></tr></table></figure>

<p><strong>合并多个HyperLogLog</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE destkey sourcekey1 sourcekey2 ...</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>凡是大量的数据下，统计不同数据的数量的情况都可以使用，非常的方便，同时要接受误差的场景。比如</p>
<p><strong>网站访问统计</strong>：估算鸡翅 club 网站每天有多少独立访客。</p>
<p><strong>日志分析</strong>：估算日志文件中有多少不同的错误类型。</p>
<h2 id="三、-Geospatial-Indexes"><a href="#三、-Geospatial-Indexes" class="headerlink" title="三、 Geospatial Indexes"></a>三、 Geospatial Indexes</h2><p>Geo数据指的是与地理位置相关的数据。简单来说，就是关于“东西在哪里”的数据。它可以描述物体的位置、形状和关系，比如城市的坐标、商店的位置、路线的路径等等。</p>
<p>有主要的三个要素，经度，纬度，和位置名称。</p>
<p>比如鸡哥所在的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD jichi 16.281231 37.1231241 jd</span><br></pre></td></tr></table></figure>

<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>添加地理位置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line">GEOADD cities 116.4074 39.9042 &quot;Beijing&quot;</span><br></pre></td></tr></table></figure>

<p><strong>获取地理位置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS key member</span><br><span class="line">GEOPOS cities &quot;Beijing&quot;</span><br><span class="line">会返回</span><br><span class="line">116.4074</span><br><span class="line">39.9042</span><br></pre></td></tr></table></figure>

<p><strong>计算距离</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEODIST key member1 member2 [unit]</span><br><span class="line">GEODIST cities &quot;Beijing&quot; &quot;Shanghai&quot; km（计算北京和上海之间的距离，单位为公里）</span><br></pre></td></tr></table></figure>

<p><strong>查找附近的位置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius [unit]</span><br><span class="line">GEORADIUS cities 116.4074 39.9042 100 km（查找北京附近100公里内的所有城市）</span><br></pre></td></tr></table></figure>

<p><strong>查找某个位置附近的位置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER key member radius [unit]</span><br><span class="line">GEORADIUSBYMEMBER cities &quot;Beijing&quot; 100 km（查找北京附近100公里内的所有城市）</span><br></pre></td></tr></table></figure>

<p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p>
<p>georadiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>附近的人：比如类似微信的附近的人，以自己为中心，找其他的人，这种场景，就可以使用GEORADIUS 。</p>
<p>基于地理位置推荐：比如推荐某个位置附近的餐厅，都可以实现</p>
<p>计算距离：大家会遇到这种场景，比如当你购物的时候，美团外卖会告诉你商家距您多远，也可以通过 geo 来进行实现。</p>
<h2 id="四、Stream（不是重点）"><a href="#四、Stream（不是重点）" class="headerlink" title="四、Stream（不是重点）"></a>四、Stream（不是重点）</h2><p>stream 是 redis5.0 版本后面加入的。比较新，以至于很多老八股题目，都没有提到这个类型。还有就是本身应用度的场景真的不多，类似 mq，但是如果 mq 的场景，大家一般会选择正宗的 rokcetmq 或者 rabbit 或者 kafka，所以这种类型，大家稍微知道即可。</p>
<p>Redis中的流结构用来处理<strong>连续不断到达的数据</strong>。你可以把它想象成一条流水线，数据像流水一样源源不断地流过来，我们可以在流水线的不同位置对这些数据进行处理。</p>
<p>主要目的是做消息队列，在此之前 redis 曾经使用发布订阅模式来做，但是发布订阅有一个缺点就是消息无法持久化。非常脆弱，redis 宕机，断开这些，都会产生造成丢失。stream 提供了持久化和主备同步机制。</p>
<h3 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h3><p><strong>消息（Message）</strong>：流中的每一条数据。每条消息都有一个唯一的ID和一组字段和值。</p>
<p><strong>流（Stream）</strong>：存储消息的地方。可以把它看作一个消息队列。</p>
<p><strong>消费者组（Consumer Group）</strong>：一个或多个消费者组成的组，用来处理流中的消息。</p>
<p><strong>消费者（Consumer）</strong>：处理消息的终端，可以是应用程序或服务。</p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>如果需要轻量级，很轻很轻，没有 mq 的情况下，可以使用 redis 来做，适合处理需要<strong>实时处理</strong>和<strong>快速响应</strong>的数据。比如做成用户消息实时发送和接收、服务器日志实时记录和分析、传感器数据实时收集和处理。</p>
<p>不过需要注意的是，正常来说 mq，mqtt 等等在各自场景有比较好的应用。</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p><strong>添加消息到流</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XADD stream-name * field1 value1 [field2 value2 ...]</span><br><span class="line">XADD mystream * user jichi message &quot;Hello, world!&quot;</span><br><span class="line">他会向流mystream添加一条消息，消息内容是user: jichi, message: &quot;Hello, world!&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>读取消息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREAD COUNT count STREAMS stream-name ID</span><br><span class="line">XREAD COUNT 2 STREAMS mystream 0</span><br><span class="line">会从流mystream中读取前两条消息，也就是读取到jichi 的hello world</span><br></pre></td></tr></table></figure>

<p><strong>创建消费者组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE stream-name group-name ID</span><br><span class="line">XGROUP CREATE mystream mygroup 0</span><br><span class="line">会为流mystream创建一个名为mygroup的消费者组。</span><br></pre></td></tr></table></figure>

<p><strong>消费者组读取消息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group-name consumer-name COUNT count STREAMS stream-name ID</span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 2 STREAMS mystream &gt;</span><br><span class="line">会让消费者组mygroup中的消费者consumer1读取流mystream中的前两条消息。</span><br></pre></td></tr></table></figure>

<p><strong>确认消息处理完成</strong>：</p>
<p>消费者处理完成，应该进行 ack。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XACK stream-name group-name ID</span><br><span class="line">XACK mystream mygroup 1526569495631-0</span><br><span class="line">确认消费者组mygroup已经处理完了ID为1526569495631-0的消息。</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8Bredis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8Bredis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1_/" itemprop="url">👌什么情况下redis哨兵模式会产生数据丢失</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么情况下redis哨兵模式会产生数据丢失"><a href="#👌什么情况下redis哨兵模式会产生数据丢失" class="headerlink" title="👌什么情况下redis哨兵模式会产生数据丢失?"></a>👌什么情况下redis哨兵模式会产生数据丢失?</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>其实 redis 在这种情况下的数据丢失，主要就是 4 点，第一点是主从复制的延迟，如果本身复制的过程存在延迟，然后数据还没有从节点的时候，就发生故障，会导致数据丢失。第二个就是故障转移，比如在从节点升级为新主节点的过程中，可能还有部分数据请求写入老节点。也会造成数据丢失。第三代呢就是同步故障，比如一个新的节点刚加入，正同步数据呢，结果主节点挂了，也会丢失。最后一个就是万恶的网络，网络分区会导致集群节点无法通信。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>这个主要是看你对数据丢失这块，是否有过一定的完整性思考。常见的问题，无非总结就是 延迟，切换，网络三大点。其他的数据丢失题，其实也可以用这个往上套。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>主从复制延迟，故障转移写入，同步故障，网络分区</p>
<h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><p>为了尽量减少哨兵模式下的数据丢失，可以采取以下措施：</p>
<p><strong>1、 尽量使用半同步复制</strong>：通过配置min-slaves-to-write和min-slaves-max-lag参数，确保主节点在写入数据时，至少有一定数量的从节点已同步数据。</p>
<p><strong>2、 优化故障检测和切换参数</strong>：根据实际情况优化哨兵的故障检测和切换参数，确保能够及时、准确地进行故障检测和切换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AFredis%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AFredis%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%EF%BC%9F/" itemprop="url">什么是redis事务机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是redis事务机制？"><a href="#👌什么是redis事务机制？" class="headerlink" title="👌什么是redis事务机制？"></a>👌什么是redis事务机制？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，redis 的事务机制不算是一个像 mysql 一样的正常的事务，只是保证了正常情况下的原子性，一场情况不提供回滚机制。redis 主要是将事务的命令，放在一个队列，一起准备顺序执行。主要是 multi，exec，watch 命令配合使用。使用非常简单，先标记事务开始后，放入命令，再通过 exec 执行即可。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>实际场景的事务还是用的很少的，这道题也不是特别重点，了解一下 redis 这个事务特性即可。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>原子性、不支持回滚、watch 乐观锁</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>redis中事务是一组命令的集合，一组命令要么全部执行，要么全部不执行。事务在Redis中是通过流水线（Pipeline）技术实现的，所有命令在执行之前都会被放入一个队列中，直到执行EXEC命令时，所有命令才会按顺序执行。</p>
<h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><h3 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h3><p>MULTI命令用于标记一个事务的开始。执行MULTI后，所有的命令都会被放入一个队列中，而不是立即执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br></pre></td></tr></table></figure>

<h3 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h3><p>EXEC命令用于执行从MULTI命令开始后放入队列中的所有命令。所有命令会按顺序执行，并且在执行过程中不会被其他客户端的命令打断。Redis事务在执行EXEC命令时具有原子性，即所有命令要么全部执行，要么全部不执行。Redis事务并不支持回滚机制。如果在事务执行过程中发生错误，已经执行的命令不会被回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<h3 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h3><p>DISCARD命令用于放弃从MULTI命令开始后放入队列中的所有命令，并且取消事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DISCARD</span><br></pre></td></tr></table></figure>

<h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><p>WATCH命令用于监视一个或多个键，在事务执行之前，如果这些键被其他客户端修改，事务将被中止。WATCH命令通常用于实现乐观锁。这样可以防止事务中的数据竞争问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WATCH key1 key2</span><br></pre></td></tr></table></figure>

<h2 id="事务的工作原理"><a href="#事务的工作原理" class="headerlink" title="事务的工作原理"></a>事务的工作原理</h2><h4 id="事务的执行过程"><a href="#事务的执行过程" class="headerlink" title="事务的执行过程"></a>事务的执行过程</h4><p><strong>1、 开始事务</strong>：使用MULTI命令开始一个事务。</p>
<p><strong>2、 命令入队</strong>：在事务开始之后，所有的命令都会被放入队列中，而不是立即执行。</p>
<p><strong>4、 执行事务</strong>：使用EXEC命令执行队列中的所有命令。如果在使用WATCH监视的键在事务执行前被修改，事务将被中止。</p>
<p><strong>4、 放弃事务</strong>：使用DISCARD命令可以放弃当前事务队列中的所有命令。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 开始事务</span><br><span class="line">MULTI</span><br><span class="line"># 添加命令到事务队列</span><br><span class="line">SET key1 value1</span><br><span class="line">SET key2 value2</span><br><span class="line"># 执行事务</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p>如果在事务执行之前，使用WATCH命令监视了某个键，并且该键在事务执行前被修改，事务将被中止：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 监视键</span><br><span class="line">WATCH key1</span><br><span class="line"># 开始事务</span><br><span class="line">MULTI</span><br><span class="line"># 添加命令到事务队列</span><br><span class="line">SET key1 value1</span><br><span class="line">SET key2 value2</span><br><span class="line"># 执行事务（如果key1在此之前被修改，事务将被中止）</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AFredis%E5%93%88%E5%B8%8C%E6%A7%BD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AFredis%E5%93%88%E5%B8%8C%E6%A7%BD%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F/" itemprop="url">什么是redis哈希槽</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是redis哈希槽的概念？"><a href="#👌什么是redis哈希槽的概念？" class="headerlink" title="👌什么是redis哈希槽的概念？"></a>👌什么是redis哈希槽的概念？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，redis 的哈希槽是集群模式下的一个概念，目的是为了实现数据的分布和管理，水平扩展，哈希槽总共有 16384 个，每个节点管理一部分的哈希槽，然后 key 通过取模算法后映射过来。再根据哈希槽对应的管理节点，就可以找到数据。初始的分配哈希槽可以采用手动指定的方式，也可以采用 redis 的工具的形式分配。有了哈希槽这种方式，能够将数据均匀分布到集群中的各个节点上，避免某些节点过载。同时实现负载均衡，确保每个节点的负载大致均衡。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>集群模式必考题，如果简历写了 redis 的集群模式，这道题必考，大家一定注意。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>哈希槽，取模，集群，数据分配</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>哈希槽是Redis集群里的一个概念，主要用于实现数据的分布和管理。集群模式中数据是分布在多个节点上的，哈希槽的机制是确定每个键应该存储在哪个节点上。Redis集群中有16384个哈希槽（编号从0到16383）。每个键在存储之前都会根据其哈希值被映射到其中一个哈希槽。</p>
<h3 id="哈希槽的工作原理"><a href="#哈希槽的工作原理" class="headerlink" title="哈希槽的工作原理"></a>哈希槽的工作原理</h3><p>Redis使用CRC16算法对每个键进行哈希计算，然后对16384取模，得到一个哈希槽编号。例如，假设键为”mykey”，其哈希值计算结果为12345，那么12345 % 16384的结果就是哈希槽编号。集群中的每个节点负责管理一定范围的哈希槽。Redis可以把数据分布到多个节点上。例如，节点A可能负责哈希槽0到5000，节点B负责哈希槽5001到10000，节点C负责哈希槽10001到16383。</p>
<h3 id="哈希槽的分配和迁移"><a href="#哈希槽的分配和迁移" class="headerlink" title="哈希槽的分配和迁移"></a>哈希槽的分配和迁移</h3><p><strong>初始分配</strong>： 集群启动时哈希槽会被分配到不同的节点上。可以手动指定每个节点负责的哈希槽范围，也可以使用Redis提供的工具自动分配。</p>
<p><strong>数据迁移</strong>： 当集群中的节点发生变化（如新增节点或删除节点）时，Redis会重新分配哈希槽（重新分片resharding），相应的数据从一个节点迁移到另一个节点。</p>
<h3 id="哈希槽的作用"><a href="#哈希槽的作用" class="headerlink" title="哈希槽的作用"></a>哈希槽的作用</h3><p><strong>数据分布</strong>： 通过哈希槽机制，Redis能够将数据均匀分布到集群中的各个节点上，避免某些节点过载。</p>
<p><strong>负载均衡</strong>： 当集群扩展或缩减时，Redis可以通过重新分配哈希槽来实现负载均衡，确保每个节点的负载大致均衡。</p>
<p><strong>高可用性</strong>： Redis集群中的每个节点可以有一个或多个副本（从节点），这些副本也会根据哈希槽进行数据复制，从而提高系统的高可用性和容错能力。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个Redis集群，包含三个节点：节点A、节点B和节点C。哈希槽的分配如下：</p>
<ul>
<li>节点A：负责哈希槽0到5460</li>
<li>节点B：负责哈希槽5461到10922</li>
<li>节点C：负责哈希槽10923到16383</li>
</ul>
<p>当我们插入一个键”mykey”时，Redis会计算其哈希值，并映射到相应的哈希槽。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CRC16(&quot;mykey&quot;) = 12345</span><br><span class="line">12345 % 16384 = 12345</span><br></pre></td></tr></table></figure>

<p>键”mykey”会被存储在负责哈希槽12345的节点C上。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F/" itemprop="url">👌什么是缓存击穿？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是缓存击穿？"><a href="#👌什么是缓存击穿？" class="headerlink" title="👌什么是缓存击穿？"></a>👌什么是缓存击穿？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，缓存击穿主要是高并发情况下，某个热点key突然失效或者未被缓存，导致大量请求直接穿透到后端数据库，从而使得数据库负载过高，甚至崩溃的问题。经常会有小伙伴和缓存穿透弄混，一个比较好的区分点就是可以理解为单 key，同时重建缓存需要时间。解决这个问题，一般常见的两种方案，一个是互斥锁，在多请求情况下，只有一个请求会去构建缓存，其他的进行等待，这种主要是要考虑好死锁的问题和请求阻塞的问题。另一种就是设置一个逻辑过期时间，去进行异步的缓存更新，缓存本身永远不会过期，这样也就避免了击穿的问题。但是复杂性和逻辑时间的设置就比较考验设计。一般情况下互斥锁方案即可。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>redis 经典三问之一，要注意和穿透的区分，很多小伙伴分不清，这是不行的。主要是考核大家对于互斥锁的死锁隐患的考虑以及数据一致性的考虑。看是否有这些方面的一些思考。一定要细致理解其中的图和数据。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>互斥锁，不过期，一致性，高并发吞吐量</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>缓存击穿是指在高并发的情况下，某个热点key突然失效或者未被缓存，导致大量请求直接穿透到后端数据库，从而使得数据库负载过高，甚至崩溃的问题。</p>
<p>这里要注意一个点就是比如构建这个 key 的缓存需要一定的时间，例如当缓存没有，查询数据后，重新放入缓存的过程需要一定的时间，如果这个时候，不进行控制，可能有很多请求都在做同一件事构建缓存，可能会引发数据库的压力剧增，或者影响到第三方服务。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、互斥锁"><a href="#1、互斥锁" class="headerlink" title="1、互斥锁"></a>1、互斥锁</h3><p>在缓存失效时，通过加锁机制保证只有一个线程能访问数据库并更新缓存，其他线程等待该线程完成后再读取缓存。核心重点 ：只有一个线程访问数据库和建立缓存。</p>
<p>根据上面的流程图，我们可以看到一个非常具体的实现步骤：</p>
<ol>
<li>当缓存失效时，尝试获取一个分布式锁。</li>
<li>获取锁的线程去数据库查询数据并更新缓存。</li>
<li>其他未获取锁的线程等待锁释放后，再次尝试读取缓存。</li>
</ol>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lockAcquired</span> <span class="operator">=</span> redis.setnx(<span class="string">&quot;lock:&quot;</span> + key, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 双重检查锁，防止重复查询数据库</span></span><br><span class="line">                value = redis.get(key);</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    value = database.query(key);</span><br><span class="line">                    redis.set(key, value, <span class="number">3600</span>);  <span class="comment">// 1小时过期</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                redis.del(<span class="string">&quot;lock:&quot;</span> + key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 等待锁释放，再次尝试获取缓存</span></span><br><span class="line">            <span class="keyword">while</span> ((value = redis.get(key)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);  <span class="comment">// 等待100毫秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>锁的实现要确保高效和可靠，避免死锁和性能瓶颈。可以设置锁的过期时间，防止因异常情况导致锁无法释放。</p>
<h3 id="2、不过期"><a href="#2、不过期" class="headerlink" title="2、不过期"></a><font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">2、不过期</font></h3><p><font style="color:rgb(36, 41, 47);">设置一个较长的缓存过期时间，同时在缓存中存储一个逻辑过期时间。当逻辑过期时间到达时，后台异步更新缓存，而不是让用户请求直接穿透到数据库。这种方案可以彻底防止请求打到数据库，不过就是造成了代码实现过于复杂，因为你需要尽可能的保持二者的一致。</font></p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>在缓存中存储数据时，附带一个逻辑过期时间。</li>
<li>读取缓存时，检查逻辑过期时间是否到达。</li>
<li>如果逻辑过期时间到达，异步线程去数据库查询新数据并更新缓存，但仍返回旧数据给用户，避免缓存失效时大量请求直接访问数据库。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheEntry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheEntry</span><span class="params">(String value, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = expireTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() &gt; expireTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">CacheEntry</span> <span class="variable">cacheEntry</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheEntry == <span class="literal">null</span> || cacheEntry.isExpired()) &#123;</span><br><span class="line">        <span class="comment">// 异步更新缓存</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> database.query(key);</span><br><span class="line">            redis.set(key, <span class="keyword">new</span> <span class="title class_">CacheEntry</span>(newValue, System.currentTimeMillis() + <span class="number">3600</span> * <span class="number">1000</span>));  <span class="comment">// 1小时逻辑过期</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheEntry != <span class="literal">null</span> ? cacheEntry.getValue() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><p>互斥锁要注意的点是，阻塞等待可能会存在死锁或者请求阻塞的情况，降低了高并发的吞吐量。</p>
<p>不过期这种方式，设置逻辑时间是一个非常考验功底的情况，设置的过程，数据不一致性的时间就越长，所以要考虑好方案和业务情况。互斥锁，就不存在这种问题。各有优势，按照情况来进行选择。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F_/" itemprop="url">👌什么是缓存穿透</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是缓存穿透"><a href="#👌什么是缓存穿透" class="headerlink" title="👌什么是缓存穿透?"></a>👌什么是缓存穿透?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，缓存穿透的最核心就是当高并发请求来的时候，但是 key 在缓存中不存在的时候，就会请求数据库，如果数据库还是没有的话，就会返回，但是这个时候，由于没有数据，也不会存入到缓存中，下次请求过来还会重复这个操作。如果说这个 key 一直没有数据，就会不断的打到数据库中。这就是缓存穿透。缓存穿透主要可以通过缓存空值，布隆过滤器的方式来进行解决。常用的就是缓存空值，当数据库也查询不到的时候，在缓存中将空值写入，这样后面的请求就会命中缓存，不会造成数据库的大压力。布隆过滤器比较适合一些固定值，来进行初步的过滤，这样可以减少误判率，同时减轻压力，以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>redis 算是必问的三个概念之一，其他两个是缓存击穿和缓存雪崩，后面也有介绍。这道题很多人容易把缓存穿透和缓存击穿来弄乱。要注意好识别，还有就是三种常见的解决方案要理解透彻。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>穿透的核心概念，缓存空对象解决，布隆过滤器，缓存预热。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p><strong>缓存穿透</strong>是指在高并发场景下，如果某一个key被高并发访问，但该key在缓存中不存在，那么请求会穿透到数据库查询。如果这个key在数据库中也不存在，就会导致每次请求都要到数据库去查询，给数据库带来压力。严重的缓存穿透会导致数据库宕机。可以根据图看到核心的重点在于不命中和返回空。解决方案也围绕这些即可。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、-缓存空对象"><a href="#1、-缓存空对象" class="headerlink" title="1、 缓存空对象"></a><strong>1、 缓存空对象</strong></h3><p>当数据库中查不到数据时，缓存一个空对象（例如一个标记为空或不存在的对象），并给这个空对象的缓存设置一个过期时间。这样，下次再查询该数据时，就可以直接从缓存中拿到空对象，从而避免了不必要的数据库查询。</p>
<p>这种解决方式有两个缺点：</p>
<p>需要缓存层提供更多的内存空间来缓存这些空对象，当空对象很多时，会浪费更多的内存。</p>
<p>会导致缓存层和存储层的数据不一致，即使设置了较短的过期时间，也会在这段时间内造成数据不一致问题。比如缓存还是空对象，这个时候数据库已经有值了。这种引入复杂性，当数据库值变化的时候，要清空缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String key = &quot;jichiKey&quot;;</span><br><span class="line">String value = redis.get(key);</span><br><span class="line">if (value == null) &#123;</span><br><span class="line">    value = database.query(key);</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        // 缓存空结果，设置短过期时间</span><br><span class="line">        redis.set(key, &quot;&quot;, 60);  // 60秒过期</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        redis.set(key, value, 3600);  // 1小时过期</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、-使用布隆过滤器"><a href="#2、-使用布隆过滤器" class="headerlink" title="2、 使用布隆过滤器"></a><strong>2、 使用布隆过滤器</strong></h3><p>布隆过滤器用于检测一个元素是否在集合中。访问缓存和数据库之前，先判断布隆过滤器里面有没有这个 key，如果 key 存在，可以继续往下走，如果 key 不存在，就不用往下进行走了。比较适合数据 key 相对固定的场景。可以减少误识别率。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; bloomFilter = new BloomFilter&lt;&gt;(expectedInsertions, falsePositiveProbability);</span><br><span class="line">// 初始化布隆过滤器，插入所有可能存在的键</span><br><span class="line">for (String key : allPossibleKeys) &#123;</span><br><span class="line">    bloomFilter.put(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询时使用布隆过滤器</span><br><span class="line">String key = &quot;jichiKey&quot;;</span><br><span class="line">if (!bloomFilter.mightContain(key)) &#123;</span><br><span class="line">    // 布隆过滤器判断不存在，直接返回</span><br><span class="line">    return null;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 布隆过滤器判断可能存在，查询缓存和数据库</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        value = database.query(key);</span><br><span class="line">        redis.set(key, value, 3600);  // 1小时过期</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、缓存预热"><a href="#3、缓存预热" class="headerlink" title="3、缓存预热"></a><strong>3、缓存预热</strong></h3><p>在系统启动时，提前将热门数据加载到缓存中，可以避免因为请求热门数据而导致的缓存穿透问题。需要根据系统的实际情况和业务需求来判断是否需要对缓存进行预热。比如在一些高并发的系统下，提前预热可以大大减少毛刺的产生，以及提高性能和系统稳定。</p>
<p>缓存预热的经典代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.jingdianjichi.redis.init;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public abstract class AbstractCache &#123;</span><br><span class="line"></span><br><span class="line">    public void initCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getCache(String key)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void clearCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void reloadCache()&#123;</span><br><span class="line">        clearCache();</span><br><span class="line">        initCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class InitCache implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        //我要知道哪些缓存需要进行一个预热</span><br><span class="line">        ApplicationContext applicationContext = SpringContextUtil.getApplicationContext();</span><br><span class="line">        Map&lt;String, AbstractCache&gt; beanMap = applicationContext.getBeansOfType(AbstractCache.class);</span><br><span class="line">        //调用init方法</span><br><span class="line">        if(beanMap.isEmpty())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(Map.Entry&lt;String,AbstractCache&gt; entry : beanMap.entrySet())&#123;</span><br><span class="line">            AbstractCache abstractCache = (AbstractCache) SpringContextUtil.getBean(entry.getValue().getClass());</span><br><span class="line">            abstractCache.initCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CategoryCache extends AbstractCache &#123;</span><br><span class="line"></span><br><span class="line">    private static final String CATEGORY_CACHE_KEY = &quot;CATEGORY&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initCache() &#123;</span><br><span class="line">        //跟数据库做联动了，跟其他的数据来源进行联动</span><br><span class="line">        redisUtil.set(&quot;category&quot;,&quot;知识&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T getCache(String key) &#123;</span><br><span class="line">        if(!redisTemplate.hasKey(key).booleanValue())&#123;</span><br><span class="line">            reloadCache();</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearCache() &#123;</span><br><span class="line">        redisTemplate.delete(CATEGORY_CACHE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9_/" itemprop="url">👌什么是缓存雪崩？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是缓存雪崩"><a href="#👌什么是缓存雪崩" class="headerlink" title="👌什么是缓存雪崩?"></a>👌什么是缓存雪崩?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，缓存雪崩主要是在同一时间，系统大量缓存失效，这个时候的大量请求都要打到数据库，增加了数据库压力，导致数据库崩溃或者不可用，一般如果产生了雪崩，就是比较严重的后果。雪崩主要的解决方案，一方面是设置合理的缓存过期时间，不要让同一时间失效，尽量的分散。另一个方案就是可以在比如服务刚启动的时候，进行缓存的预热，防止刚启动的时候，大量请求打到数据库。另一方面也要提升缓存架构的高可用，避免因为缓存服务的问题，导致请求打到数据库。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>经典的缓存三大问题之一。问的也是挺多的，面试官主要是想知道你对他的理解，相比击穿和穿透，雪崩很好理解。要注意的一个点就是雪崩相对应的解决方案要重点记一下。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>同时过期失效，设置分散过期时间，热点数据预加载，高可用</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a><font style="color:rgb(36, 41, 47);">题目详细答案</font></h1><p><font style="color:rgb(36, 41, 47);">缓存雪崩是指在某一时刻，大量缓存数据同时失效，导致大量的请求直接穿透到数据库，瞬间给数据库带来巨大的压力，可能导致数据库崩溃或服务不可用。</font></p>
<h2 id="雪崩的常见原因"><a href="#雪崩的常见原因" class="headerlink" title="雪崩的常见原因"></a>雪崩的常见原因</h2><ol>
<li><strong>缓存数据过期时间相同</strong>：当缓存系统中大量数据的过期时间被设置为同一时间点或相近的时间段时，这些数据会同时失效，从而引发缓存雪崩。</li>
<li><strong>缓存服务器故障</strong>：当缓存服务器发生故障时，如果没有有效的容错机制，缓存中的数据将无法被访问，系统可能直接请求后端服务或数据库，导致系统性能下降。</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="设置合理的缓存过期时间"><a href="#设置合理的缓存过期时间" class="headerlink" title="设置合理的缓存过期时间"></a>设置合理的缓存过期时间</h3><p>缓存过期时间的设置需要根据业务需求和数据的变化频率来确定。对于不经常变化的数据，可以设置较长的过期时间，以减少对数据库的频繁访问。对于经常变化的数据，可以设置较短的过期时间，确保缓存数据的实时性。总之就是尽量打散缓存的过期时间，最好做到均匀的时间分布，减轻系统同一时刻的压力。</p>
<h3 id="使用热点数据预加载"><a href="#使用热点数据预加载" class="headerlink" title="使用热点数据预加载"></a>使用热点数据预加载</h3><p>预先将热点数据加载到缓存中，并设置较长的过期时间，可以避免在同一时间点大量请求直接访问数据库。可以根据业务需求，在系统启动或低峰期进行预热操作，将热点数据提前加载到缓存中。</p>
<p>热点数据预加载可以提升系统的性能和响应速度，减轻数据库的负载。</p>
<h3 id="缓存高可用"><a href="#缓存高可用" class="headerlink" title="缓存高可用"></a>缓存高可用</h3><p>缓存做成集群的形式，提高可用性，防止缓存挂掉后，造成的穿透问题。</p>
<p>当缓存服务器发生故障或宕机时，需要有相应的故障转移和降级策略。可以通过监控系统来及时发现缓存故障，并进行自动切换到备份缓存服务器。同时，可以实现降级策略，当缓存失效时，系统可以直接访问数据库，保证系统的可用性。通过缓存故障转移和降级策略，可以保证系统在缓存不可用或故障的情况下仍然可以正常运行，提高系统的稳定性和容错性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E4%BD%BF%E7%94%A8redis%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99%E7%9A%84uv%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E4%BD%BF%E7%94%A8redis%E7%BB%9F%E8%AE%A1%E7%BD%91%E7%AB%99%E7%9A%84uv%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A/" itemprop="url">👌使用redis统计网站的uv，应该怎么做</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌使用redis统计网站的uv，应该怎么做"><a href="#👌使用redis统计网站的uv，应该怎么做" class="headerlink" title="👌使用redis统计网站的uv，应该怎么做"></a>👌使用redis统计网站的uv，应该怎么做</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>常见的是使用Set数据结构和HyperLogLog数据结构。</p>
<h2 id="使用Set统计UV"><a href="#使用Set统计UV" class="headerlink" title="使用Set统计UV"></a>使用Set统计UV</h2><p>Set是一种集合数据结构，可以存储不重复的元素。将每个访客的唯一标识（如用户ID或IP地址）添加到Set中，可以很方便地统计独立访客数。</p>
<ol>
<li><strong>记录访客访问</strong>：每次有访客访问时，将其唯一标识添加到当天的Set中。</li>
<li><strong>获取UV</strong>：使用SCARD命令获取Set中元素的数量，即为独立访客数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">public class UVTrackerSet &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    public UVTrackerSet(String redisHost, int redisPort) &#123;</span><br><span class="line">        this.jedis = newJedis(redisHost, redisPort);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recordVisit(String userId) &#123;</span><br><span class="line">        String date= LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">        String key=&quot;uv:set:&quot; + date;</span><br><span class="line">        jedis.sadd(key, userId);</span><br><span class="line">        // 设置键的过期时间为30天，防止内存无限增长</span><br><span class="line">        jedis.expire(key, 30 * 24 * 60 * 60);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getUV(String date) &#123;</span><br><span class="line">        String key=&quot;uv:set:&quot; + date;</span><br><span class="line">        return jedis.scard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getUVRange(String startDate, String endDate) &#123;</span><br><span class="line">        LocalDatestart= LocalDate.parse(startDate, DATE_FORMATTER);</span><br><span class="line">        LocalDateend= LocalDate.parse(endDate, DATE_FORMATTER);</span><br><span class="line"></span><br><span class="line">        String[] keys = start.datesUntil(end.plusDays(1))</span><br><span class="line">                .map(date -&gt; &quot;uv:set:&quot; + date.format(DATE_FORMATTER))</span><br><span class="line">                .toArray(String[]::new);</span><br><span class="line"></span><br><span class="line">        StringtempKey=&quot;uv:set:range&quot;;</span><br><span class="line">        jedis.sunionstore(tempKey, keys);</span><br><span class="line">        longuvCount= jedis.scard(tempKey);</span><br><span class="line">        jedis.del(tempKey);</span><br><span class="line">        return uvCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UVTrackerSet tracker = new UVTrackerSet(&quot;localhost&quot;, 6379);</span><br><span class="line"></span><br><span class="line">        // 记录访客访问</span><br><span class="line">        tracker.recordVisit(&quot;user_123&quot;);</span><br><span class="line">        tracker.recordVisit(&quot;user_456&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取指定日期的UV</span><br><span class="line">        Stringtoday= LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">        System.out.println(&quot;UV for &quot; + today + &quot;: &quot; + tracker.getUV(today));</span><br><span class="line"></span><br><span class="line">        // 获取一段时间内的UV</span><br><span class="line">        StringstartDate=&quot;2023-07-01&quot;;</span><br><span class="line">        StringendDate=&quot;2023-07-07&quot;;</span><br><span class="line">        System.out.println(&quot;UV from &quot; + startDate + &quot; to &quot; + endDate + &quot;: &quot; + tracker.getUVRange(startDate, endDate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用HyperLogLog统计UV"><a href="#使用HyperLogLog统计UV" class="headerlink" title="使用HyperLogLog统计UV"></a>使用HyperLogLog统计UV</h2><p>HyperLogLog是一种概率性数据结构，可以在固定的内存空间内提供高效的基数估计。它适合处理大规模数据。</p>
<ol>
<li><strong>记录访客访问</strong>：每次有访客访问时，将其唯一标识添加到当天的HyperLogLog中。</li>
<li><strong>获取UV</strong>：使用PFCOUNT命令获取HyperLogLog的基数估计。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">public class UVTrackerHLL &#123;</span><br><span class="line"></span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    private static final DateTimeFormatter DATE_FORMATTER= DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    public UVTrackerHLL(String redisHost, int redisPort) &#123;</span><br><span class="line">        this.jedis = newJedis(redisHost, redisPort);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recordVisit(String userId) &#123;</span><br><span class="line">        Stringdate= LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">        Stringkey=&quot;uv:hll:&quot; + date;</span><br><span class="line">        jedis.pfadd(key, userId);</span><br><span class="line">        // 设置键的过期时间为30天，防止内存无限增长</span><br><span class="line">        jedis.expire(key, 30 * 24 * 60 * 60);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getUV(String date) &#123;</span><br><span class="line">        Stringkey=&quot;uv:hll:&quot; + date;</span><br><span class="line">        return jedis.pfcount(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getUVRange(String startDate, String endDate) &#123;</span><br><span class="line">        LocalDatestart= LocalDate.parse(startDate, DATE_FORMATTER);</span><br><span class="line">        LocalDateend= LocalDate.parse(endDate, DATE_FORMATTER);</span><br><span class="line"></span><br><span class="line">        String[] keys = start.datesUntil(end.plusDays(1))</span><br><span class="line">                .map(date -&gt; &quot;uv:hll:&quot; + date.format(DATE_FORMATTER))</span><br><span class="line">                .toArray(String[]::new);</span><br><span class="line"></span><br><span class="line">        StringtempKey=&quot;uv:hll:range&quot;;</span><br><span class="line">        jedis.pfmerge(tempKey, keys);</span><br><span class="line">        longuvCount= jedis.pfcount(tempKey);</span><br><span class="line">        jedis.del(tempKey);</span><br><span class="line">        return uvCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UVTrackerHLLtracker=newUVTrackerHLL(&quot;localhost&quot;, 6379);</span><br><span class="line"></span><br><span class="line">        // 记录访客访问</span><br><span class="line">        tracker.recordVisit(&quot;user_123&quot;);</span><br><span class="line">        tracker.recordVisit(&quot;user_456&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取指定日期的UV</span><br><span class="line">        Stringtoday= LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">        System.out.println(&quot;UV for &quot; + today + &quot;: &quot; + tracker.getUV(today));</span><br><span class="line"></span><br><span class="line">        // 获取一段时间内的UV</span><br><span class="line">        StringstartDate=&quot;2023-07-01&quot;;</span><br><span class="line">        StringendDate=&quot;2023-07-07&quot;;</span><br><span class="line">        System.out.println(&quot;UV from &quot; + startDate + &quot; to &quot; + endDate + &quot;: &quot; + tracker.getUVRange(startDate, endDate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h2><table>
<thead>
<tr>
<th></th>
<th>set</th>
<th>hyperloglog</th>
</tr>
</thead>
<tbody><tr>
<td>精准度</td>
<td>精确统计，无误差</td>
<td>存在一定误差（通常在0.81%左右）</td>
</tr>
<tr>
<td>占用内存</td>
<td>内存占用较大，尤其是当访客数量很大时</td>
<td>内存占用小，通常只需要12KB内存。</td>
</tr>
<tr>
<td>内存占用情况</td>
<td>小数据量，同时对内存不敏感可以</td>
<td>适合大规模数据</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84key%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84key%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌如果有大量的key需要设置同一时间过期，一般需要注意什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#👌如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="👌如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>👌如果有大量的key需要设置同一时间过期，一般需要注意什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>大量的 key 同一时间过期，就是非常常见的缓存雪崩场景。</p>
<p>缓存雪崩是指在同一时间大量缓存key同时失效，导致大量请求直接涌向数据库或后端服务，可能引发系统崩溃或性能严重下降。</p>
<h2 id="雪崩解决方案"><a href="#雪崩解决方案" class="headerlink" title="雪崩解决方案"></a>雪崩解决方案</h2><p><strong>过期时间随机化</strong>：在设置过期时间时，添加一个随机的偏移量，使得不同key的过期时间稍微不同，避免在同一时刻大量key同时失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> baseExpiry=<span class="number">3600</span>; <span class="comment">// 基础过期时间，单位为秒</span></span><br><span class="line"><span class="type">int</span> randomOffset= random.nextInt(<span class="number">300</span>); <span class="comment">// 随机偏移量，最大300秒</span></span><br><span class="line"><span class="type">int</span> finalExpiry= baseExpiry + randomOffset;</span><br><span class="line">redisClient.set(key, value, finalExpiry);</span><br></pre></td></tr></table></figure>

<p><strong>分散过期时间</strong>：根据业务逻辑，将key的过期时间分散在不同的时间段内。例如，可以根据key的某些属性（如用户ID、商品ID等）分散设置过期时间。</p>
<p><strong>缓存预热</strong>：在缓存失效前，提前预热缓存，确保缓存中始终有数据。</p>
<h2 id="监控报警机制"><a href="#监控报警机制" class="headerlink" title="监控报警机制"></a>监控报警机制</h2><p>使用Redis自身的监控工具或第三方监控工具（如Prometheus、Grafana等）监控缓存的命中率、延迟、内存使用等指标。设置报警规则，当缓存命中率下降或延迟增加时，及时发送报警通知，便于快速定位和解决问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/redis/%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/redis/%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌看门狗机制的原理是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌看门狗机制的原理是什么？"><a href="#👌看门狗机制的原理是什么？" class="headerlink" title="👌看门狗机制的原理是什么？"></a>👌看门狗机制的原理是什么？</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>在我们平常使用分布式锁的时候，一般会设置一个锁的过期时间，那么如果锁过期的时候，业务还没执行完怎么办，于是就有了看门狗。看门狗机制是一种用于自动续约分布式锁的机制，确保在持有锁的客户端处理完业务逻辑之前，锁不会过期。当客户端获取到锁时，会在 Redis 中设置一个键和一个过期时间（默认30秒）。同时，Redisson 会启动一个后台任务，这个任务会定期检查锁的状态。看门狗任务会每隔一段时间，默认是锁的过期时间的1&#x2F;3，即10秒，检查锁的状态。如果锁仍然被持有，看门狗任务会将锁的过期时间重置为初始值。这样，锁的过期时间不断被延长，直到客户端明确释放锁或者客户端挂掉。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>看门狗机制非常常问，一旦问到分布式锁的问题，就会产生这个问题，当你说出异常情况下，传统的分布式锁，采取过期时间释放，防止死锁的时候，就会引入到这个问题。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>后台任务续约，高可靠，自动管理</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redisson 的看门狗机制是一种用于自动续约分布式锁的机制，确保在持有锁的客户端处理完业务逻辑之前，锁不会过期。比如，我们平时使用分布式锁的时候，一般会设置一个锁的过期时间，那么如果锁过期的时候，业务还没执行完怎么办，于是就有了看门狗。</p>
<h2 id="看门狗机制的原理"><a href="#看门狗机制的原理" class="headerlink" title="看门狗机制的原理"></a>看门狗机制的原理</h2><p><strong>初始锁定</strong>：</p>
<p>当客户端获取到锁时，会在 Redis 中设置一个键（代表锁）和一个过期时间（默认30秒）。同时，Redisson 会启动一个后台任务（看门狗），这个任务会定期检查锁的状态。</p>
<p><strong>自动续约</strong>：</p>
<p>看门狗任务会每隔一段时间（默认是锁的过期时间的1&#x2F;3，即10秒）检查锁的状态。如果锁仍然被持有（即客户端还在持有锁且没有释放），看门狗任务会将锁的过期时间重置为初始值（例如，再次设置为30秒）。这样，锁的过期时间不断被延长，直到客户端明确释放锁或者客户端挂掉。</p>
<p><strong>释放锁</strong>：</p>
<p>当客户端完成业务逻辑后，会显式地调用<code>unlock()</code>方法释放锁。一旦锁被释放，看门狗任务会停止续约，锁在 Redis 中的键会被删除或自然过期。</p>
<h3 id="看门狗机制的工作流程"><a href="#看门狗机制的工作流程" class="headerlink" title="看门狗机制的工作流程"></a>看门狗机制的工作流程</h3><p><strong>获取锁</strong>：客户端请求获取锁，Redis 中创建一个键表示锁，并设置一个过期时间（例如30秒）。启动看门狗任务，定期检查锁的状态。</p>
<p><strong>定期续约</strong>：看门狗任务每隔一定时间（例如10秒）检查锁的状态。如果锁仍然被持有（即客户端还在处理业务逻辑），看门狗任务会重置锁的过期时间（例如，再次设置为30秒）。</p>
<p><strong>锁的释放</strong>：客户端业务逻辑完成后，调用<code>unlock()</code>方法释放锁。看门狗任务停止续约，锁在 Redis 中的键被删除或自然过期。</p>
<h3 id="看门狗机制的优势"><a href="#看门狗机制的优势" class="headerlink" title="看门狗机制的优势"></a>看门狗机制的优势</h3><p><strong>高可靠性</strong>：通过自动续约机制，确保锁在持有者处理完业务逻辑之前不会过期，避免了锁意外过期导致的并发问题。</p>
<p><strong>自动管理</strong>：无需手动续约锁的过期时间，简化了分布式锁的使用和管理。</p>
<p><strong>容错性</strong>：如果客户端在持有锁期间崩溃或断开连接，锁会在过期时间后自动释放，避免了死锁问题。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> RedissonConfig.createClient();</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取锁，等待时间为100秒，锁的过期时间为10秒</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 业务逻辑</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock acquired, executing business logic&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 模拟长时间运行的任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Lock released&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Could not acquire lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redissonClient.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/05/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/05/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F/" itemprop="url">👌分布式锁的特点？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-05T13:33:41+00:00">
                2025-05-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌分布式锁的特点？"><a href="#👌分布式锁的特点？" class="headerlink" title="👌分布式锁的特点？"></a>👌分布式锁的特点？</h1><p> 实现，zookeeper 的实现。数据库的实现方案基本不常见，这种方式性能很低，还容易影响业务。redis 比较常见使用，主要是用 setnx 的特性来做。成功 set 进去，意味着上锁成功。失败意味着没有获取到锁，业务执行完成后，在通过 del 来释放锁。一般会配合看门狗机制，来做异常的续约处理。以上。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>分布式锁主要有三个特点，是我们要时刻进行注意的。</p>
<ol>
<li><strong>互斥性</strong>：在某一时刻，只有一个客户端可以持有锁。</li>
<li><strong>容错性</strong>：即使某个持有锁的客户端崩溃或失去连接，锁也能够被其他客户端重新获取。</li>
<li><strong>高可用性</strong>：锁服务需要高可用，通常需要在分布式环境中实现。</li>
</ol>
<h2 id="分布式锁的实现方式"><a href="#分布式锁的实现方式" class="headerlink" title="分布式锁的实现方式"></a>分布式锁的实现方式</h2><h3 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h3><p>使用数据库的SELECT … FOR UPDATE 语句或类似的行级锁机制来实现分布式锁。优点是实现简单，缺点是性能较低，依赖于数据库的高可用性。高并发情况下也会对数据库造成非常大的压力。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 获取锁</span><br><span class="line">SELECT * FROM locks WHERE resource = &#x27;resource_name&#x27; FOR UPDATE;</span><br><span class="line"></span><br><span class="line">-- 释放锁</span><br><span class="line">DELETE FROM locks WHERE resource = &#x27;resource_name&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="基于-Redis"><a href="#基于-Redis" class="headerlink" title="基于 Redis"></a>基于 Redis</h2><p>Redis 提供了原子操作和高性能的特性，非常适合用来实现分布式锁。通常使用SETNX命令来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁</span><br><span class="line">String result = jedis.set(&quot;lock_key&quot;, &quot;lock_value&quot;, &quot;NX&quot;, &quot;PX&quot;, 30000);</span><br><span class="line">if (&quot;OK&quot;.equals(result)) &#123;</span><br><span class="line">    // 锁获取成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放锁</span><br><span class="line">if (lock_value.equals(jedis.get(&quot;lock_key&quot;))) &#123;</span><br><span class="line">    jedis.del(&quot;lock_key&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于-Zookeeper"><a href="#基于-Zookeeper" class="headerlink" title="基于 Zookeeper"></a>基于 Zookeeper</h2><p>Zookeeper 提供了分布式协调服务，可以用来实现分布式锁。通过创建临时顺序节点来实现锁机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个临时顺序节点</span><br><span class="line">String path = zookeeper.create(&quot;/locks/lock-&quot;, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">// 检查是否获取到锁</span><br><span class="line">List&lt;String&gt; children = zookeeper.getChildren(&quot;/locks&quot;, false);</span><br><span class="line">Collections.sort(children);</span><br><span class="line">if (path.equals(&quot;/locks/&quot; + children.get(0))) &#123;</span><br><span class="line">    // 获取到锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><ol>
<li><strong>分布式事务</strong>：在分布式系统中，需要确保多个节点上的操作在同一事务中执行。</li>
<li><strong>资源共享</strong>：如分布式系统中的限流、分布式任务调度等场景。</li>
<li><strong>数据一致性</strong>：在多个节点并发访问同一资源时，确保数据一致性。</li>
</ol>
<h2 id="分布式锁的常见常见问题"><a href="#分布式锁的常见常见问题" class="headerlink" title="分布式锁的常见常见问题"></a>分布式锁的常见常见问题</h2><ol>
<li><strong>死锁</strong>：如果某个节点在持有锁期间崩溃或失去连接，可能会导致其他节点无法获取锁。</li>
<li><strong>性能</strong>：分布式锁的实现需要考虑性能问题，尤其是在高并发场景下。</li>
<li><strong>可靠性</strong>：锁服务需要高可用，通常需要在分布式环境中实现。</li>
</ol>
<h2 id="分布式锁的改进"><a href="#分布式锁的改进" class="headerlink" title="分布式锁的改进"></a>分布式锁的改进</h2><ol>
<li><strong>锁过期时间</strong>：设置锁的过期时间，避免死锁问题。</li>
<li><strong>租约机制</strong>：使用租约机制，定期续约锁，确保锁在持有期间不会被其他节点获取。</li>
<li><strong>锁竞争优化</strong>：使用合适的锁竞争算法，减少锁竞争的开销。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/04/JVM/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/04/JVM/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌JVM内存分配的指针碰撞与空闲列表是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-04T13:33:41+00:00">
                2025-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM内存分配的指针碰撞与空闲列表是什么？"><a href="#👌JVM内存分配的指针碰撞与空闲列表是什么？" class="headerlink" title="👌JVM内存分配的指针碰撞与空闲列表是什么？"></a>👌JVM内存分配的指针碰撞与空闲列表是什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>指针碰撞（Bump-the-pointer）和空闲列表（Free-list）是两种常见的内存分配策略。</p>
<h2 id="指针碰撞（Bump-the-pointer）"><a href="#指针碰撞（Bump-the-pointer）" class="headerlink" title="指针碰撞（Bump-the-pointer）"></a>指针碰撞（Bump-the-pointer）</h2><p>指针碰撞是一种高效的内存分配策略，适用于堆内存是连续且规整的情况。这种方法的基本思想是通过移动一个指针来分配内存。具体步骤如下：</p>
<ol>
<li><strong>内存布局</strong>：堆内存被划分为已使用的内存和空闲的内存，中间有一个指针（称为分配指针）作为分界线。</li>
<li><strong>分配内存</strong>：当需要为新对象分配内存时，只需将分配指针向空闲内存方向移动一段与对象大小相等的距离。</li>
<li><strong>更新指针</strong>：分配指针更新后，新的对象内存区域就被标记为已使用。</li>
</ol>
<p>这种方法的优点是分配速度非常快，只需简单的指针移动操作。然而，它的缺点是在堆内存不规整（例如存在内存碎片）的情况下无法使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 已使用内存 | 分配指针 | 空闲内存 |</span><br><span class="line">|------------|----------|----------|</span><br></pre></td></tr></table></figure>

<p>当分配一个对象时，分配指针向右移动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 已使用内存 | 已使用内存 | 分配指针 | 空闲内存 |</span><br><span class="line">|------------|------------|----------|----------|</span><br></pre></td></tr></table></figure>

<h2 id="空闲列表（Free-list）"><a href="#空闲列表（Free-list）" class="headerlink" title="空闲列表（Free-list）"></a>空闲列表（Free-list）</h2><p>空闲列表是一种适用于堆内存不规整的情况下的内存分配策略。它通过维护一个列表来记录所有可用的空闲内存块。具体步骤如下：</p>
<ol>
<li><strong>空闲列表</strong>：JVM 维护一个空闲列表，记录所有可用的内存块及其大小。</li>
<li><strong>查找空闲块</strong>：当需要为新对象分配内存时，JVM 会在空闲列表中查找一个足够大的内存块。</li>
<li><strong>分配内存</strong>：找到合适的内存块后，将其从空闲列表中移除，并将其标记为已使用。如果内存块大于所需大小，可能会将剩余部分重新放回空闲列表中。</li>
<li><strong>回收内存</strong>：当对象被垃圾回收器回收后，JVM 会将其内存块重新添加到空闲列表中。</li>
</ol>
<p>这种方法的优点是能够更好地利用内存，适用于内存碎片较多的情况。然而，它的缺点是分配速度较慢，因为需要在空闲列表中查找合适的内存块。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><p>假设空闲列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空闲列表: [块1(大小: 32), 块2(大小: 64), 块3(大小: 128)]</span><br></pre></td></tr></table></figure>

<p>当需要分配一个大小为 50 的对象时，JVM 会在空闲列表中查找：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到块2(大小: 64)</span><br></pre></td></tr></table></figure>

<p>将块2分成两部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分配块2的前50个单位，剩余部分重新放回空闲列表</span><br><span class="line">空闲列表: [块1(大小: 32), 块2剩余部分(大小: 14), 块3(大小: 128)]</span><br></pre></td></tr></table></figure>



<p><strong>指针碰撞（Bump-the-pointer）</strong>：适用于堆内存规整的情况，分配速度快，但不适用于内存碎片较多的情况。</p>
<p><strong>空闲列表（Free-list）</strong>：适用于堆内存不规整的情况，能够更好地利用内存，但分配速度较慢。</p>
<p>这两种内存分配策略各有优缺点，JVM 会根据具体情况选择合适的策略，以优化内存分配和垃圾回收的效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/04/JVM/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/04/JVM/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌jvm垃圾回收算法有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-04T13:33:41+00:00">
                2025-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm垃圾回收算法有哪些？"><a href="#👌jvm垃圾回收算法有哪些？" class="headerlink" title="👌jvm垃圾回收算法有哪些？"></a>👌jvm垃圾回收算法有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>垃圾回收算法的核心在于解决两个问题：一是确定哪些对象能够被回收（引用计数法、可达性分析法），二是如何回收这些对象。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法（Reference Counting）是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。</p>
<p>当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>可达性分析算法是JVM垃圾回收中的一种算法，它通过分析对象的引用关系，判断对象是否可达，从而决定对象是否可以被回收。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>垃圾收集器首先遍历对象图，标记所有可达的对象，然后清除未标记的对象。简单直接，不需要移动对象。但是会产生内存碎片，可能导致大对象分配失败。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>在标记阶段标记所有可达的对象后，压缩阶段将存活的对象移动到内存的一端，整理出连续的可用内存空间。这种方式消除了内存碎片问题。但是对象移动需要额外的时间和资源。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>将内存分为两个相等的区域，每次只使用其中一个。当这个区域使用完时，将存活的对象复制到另一个区域，然后清空当前区域。这种方式简单高效，没有内存碎片问题。缺点就是需要双倍的内存空间。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象的生命周期将堆内存划分为几代（通常是新生代和老年代），新生代使用复制算法，老年代使用标记-整理或标记-清除算法。优化了垃圾收集性能，因为大部分对象在新生代被收集，减少了老年代的垃圾收集频率。不过需要额外的内存管理和调优。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>将堆内存划分为多个小的独立区域（Region），每个区域可以独立进行垃圾收集。这种方式提高了内存管理的灵活性和效率，适用于大堆内存的应用。缺点是实现较复杂，需要精细的内存管理。</p>
<h3 id="具体垃圾收集器使用的算法"><a href="#具体垃圾收集器使用的算法" class="headerlink" title="具体垃圾收集器使用的算法"></a>具体垃圾收集器使用的算法</h3><p><strong>Serial GC</strong>：使用标记-整理算法。</p>
<p><strong>Parallel GC</strong>：新生代使用复制算法，老年代使用标记-整理算法。</p>
<p><strong>CMS GC</strong>：新生代使用复制算法，老年代使用标记-清除算法，并发标记和清除。</p>
<p><strong>G1 GC</strong>：分区算法，结合标记-整理和复制算法。</p>
<p><strong>ZGC</strong>：分区算法，使用染色指针和读屏障技术，实现并发标记和压缩。</p>
<p><strong>Shenandoah GC</strong>：分区算法，使用并发标记和并发压缩技术。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/Java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/Java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA_/" itemprop="url">👌Java类初始化时机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java类初始化时机"><a href="#👌Java类初始化时机" class="headerlink" title="👌Java类初始化时机?"></a>👌Java类初始化时机?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>当使用new关键字创建类的实例时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>

<h3 id="访问类的静态变量或静态方法"><a href="#访问类的静态变量或静态方法" class="headerlink" title="访问类的静态变量或静态方法"></a>访问类的静态变量或静态方法</h3><p>当访问类的静态变量或调用静态方法时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MyClass.staticVar);</span><br><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过反射 API 对类进行反射调用时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="初始化子类"><a href="#初始化子类" class="headerlink" title="初始化子类"></a>初始化子类</h3><p>当初始化一个类的子类时，父类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child = new Child(); // 输出：Parent initialized, Child initialized</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-虚拟机启动时"><a href="#Java-虚拟机启动时" class="headerlink" title="Java 虚拟机启动时"></a>Java 虚拟机启动时</h3><p>包含main方法的类在虚拟机启动时会被初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Main class initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><h3 id="通过子类引用父类的静态字段"><a href="#通过子类引用父类的静态字段" class="headerlink" title="通过子类引用父类的静态字段"></a>通过子类引用父类的静态字段</h3><p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static int value = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Child.value); // 输出：42，不会触发 Child 的初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义对象数组"><a href="#定义对象数组" class="headerlink" title="定义对象数组"></a>定义对象数组</h3><p>定义类的对象数组不会触发类的初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass[] array = newMyClass[10]; // 不会触发 MyClass 的初始化</span><br></pre></td></tr></table></figure>

<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>引用常量不会触发类的初始化，因为常量在编译阶段会存入调用类的常量池中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    static final int CONSTANT = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyClass.CONSTANT); // 不会触发 MyClass 的初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/" itemprop="url">👌Java类加载器的机制是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java类加载器的机制是什么"><a href="#👌Java类加载器的机制是什么" class="headerlink" title="👌Java类加载器的机制是什么?"></a>👌Java类加载器的机制是什么?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 的类加载机制是 JVM 负责将类文件加载到内存中，并将其转换为Class对象的过程。它包括三个主要步骤：加载（Loading）、链接（Linking）和初始化（Initialization）。以下是详细的描述：</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载阶段是将类文件读入内存，并创建一个Class对象的过程。具体步骤如下：</p>
<p><strong>查找和导入类的二进制数据</strong>：从不同的来源（如文件系统、网络等）获取类的字节码。</p>
<p><strong>创建Class对象</strong>：将字节码转换为 JVM 能够识别的Class对象。</p>
<p>加载阶段可以通过系统类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）等完成。</p>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><p>链接阶段将类的二进制数据合并到 JVM 运行时环境中。链接阶段包括三个步骤：</p>
<p><strong>验证（Verification）</strong>：确保类的字节码符合 JVM 规范，保证不会破坏 JVM 的安全性。</p>
<p><strong>准备（Preparation）</strong>：为类的静态变量分配内存，并将其初始化为默认值。</p>
<p><strong>解析（Resolution）</strong>：将常量池中的符号引用转换为直接引用。</p>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><p>初始化阶段是执行类构造器<clinit>方法的过程。该方法是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块（static {}）中的语句合并产生的。初始化阶段是类加载过程的最后一步。</clinit></p>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>Java 的类加载器负责加载类文件。Java 中的类加载器遵循双亲委派模型（Parent Delegation Model），即类加载器在加载类时会先委托给父类加载器加载，如果父类加载器无法加载，再尝试自己加载。</p>
<h3 id="双亲委派模型（Parent-Delegation-Model）"><a href="#双亲委派模型（Parent-Delegation-Model）" class="headerlink" title="双亲委派模型（Parent Delegation Model）"></a>双亲委派模型（Parent Delegation Model）</h3><p>双亲委派模型的工作流程如下：</p>
<ol>
<li><strong>检查缓存</strong>：类加载器首先检查缓存中是否已经加载过该类，如果已经加载，则直接返回Class对象。</li>
<li><strong>委托父类加载</strong>：如果缓存中没有，则委托父类加载器加载。</li>
<li><strong>父类加载失败</strong>：如果父类加载器加载失败（抛出ClassNotFoundException），则由当前类加载器尝试加载。</li>
</ol>
<p>这种模型的好处是避免类的重复加载，确保核心类库不会被自定义类加载器加载和覆盖。</p>
<h3 id="常见的类加载器"><a href="#常见的类加载器" class="headerlink" title="常见的类加载器"></a>常见的类加载器</h3><p><strong>Bootstrap ClassLoader</strong>：引导类加载器，负责加载核心类库，如rt.jar中的类。它是用原生代码实现的，不是java.lang.ClassLoader的子类。</p>
<p><strong>Extension ClassLoader</strong>：扩展类加载器，负责加载JAVA_HOME&#x2F;lib&#x2F;ext目录中的类。</p>
<p><strong>Application ClassLoader</strong>：应用程序类加载器，负责加载应用程序的类路径（classpath）中的类。</p>
<h2 id="类加载器的示例"><a href="#类加载器的示例" class="headerlink" title="类加载器的示例"></a>类加载器的示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在路径</span><br><span class="line">            MyClassLoader classLoader = new MyClassLoader(&quot;/path/to/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/jvm%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/jvm%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F/" itemprop="url">👌新生代空间大小的比例及如何调整？？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-新生代空间大小的比例及如何调整？"><a href="#👌jvm-新生代空间大小的比例及如何调整？" class="headerlink" title="👌jvm 新生代空间大小的比例及如何调整？"></a>👌jvm 新生代空间大小的比例及如何调整？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，堆内存通常被划分为新生代（Young Generation）和老年代（Old Generation）。新生代又进一步划分为 Eden 区和两个 Survivor 区（S0 和 S1）。调整新生代空间大小的主要目的是优化垃圾收集性能，减少应用程序的停顿时间。</p>
<h2 id="新生代空间的默认比例"><a href="#新生代空间的默认比例" class="headerlink" title="新生代空间的默认比例"></a>新生代空间的默认比例</h2><p>默认情况下，HotSpot JVM 使用的比例大致如下：</p>
<p><strong>新生代（Young Generation）</strong>：占整个堆内存的 1&#x2F;3 到 1&#x2F;4 左右。</p>
<p><strong>老年代（Old Generation）</strong>：占整个堆内存的 2&#x2F;3 到 3&#x2F;4 左右。</p>
<p>在新生代内部，默认的比例是：</p>
<p><strong>Eden 区</strong>：占新生代的 8&#x2F;10（即 80%）。</p>
<p><strong>每个 Survivor 区（S0 和 S1）</strong>：各占新生代的 1&#x2F;10（即 10%）。</p>
<h2 id="新生代空间大小的调整"><a href="#新生代空间大小的调整" class="headerlink" title="新生代空间大小的调整"></a>新生代空间大小的调整</h2><h3 id="调整新生代和老年代的比例"><a href="#调整新生代和老年代的比例" class="headerlink" title="调整新生代和老年代的比例"></a>调整新生代和老年代的比例</h3><p><strong>-Xms和-Xmx</strong>：设置堆内存的初始大小和最大大小。</p>
<p><strong>-XX:NewSize和-XX:MaxNewSize</strong>：设置新生代的初始大小和最大大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=512m</span><br><span class="line">-XX:MaxNewSize=512m</span><br></pre></td></tr></table></figure>

<p><strong>-XX:NewRatio</strong>：设置新生代和老年代的比例。例如，-XX:NewRatio&#x3D;3 表示新生代占整个堆的 1&#x2F;4，老年代占 3&#x2F;4。</p>
<h3 id="调整-Eden-区和-Survivor-区的比例"><a href="#调整-Eden-区和-Survivor-区的比例" class="headerlink" title="调整 Eden 区和 Survivor 区的比例"></a>调整 Eden 区和 Survivor 区的比例</h3><p><strong>-XX:SurvivorRatio</strong>：设置 Eden 区和 Survivor 区的比例。例如，-XX:SurvivorRatio&#x3D;8表示 Eden 区占新生代的 8&#x2F;10，每个 Survivor 区占 1&#x2F;10。</p>
<h3 id="调整-Survivor-区的数量"><a href="#调整-Survivor-区的数量" class="headerlink" title="调整 Survivor 区的数量"></a>调整 Survivor 区的数量</h3><p><strong>-XX:SurvivorRatio</strong>：默认情况下，JVM 使用两个 Survivor 区（S0 和 S1）。你可以通过调整 Survivor 区的比例来优化内存使用和垃圾收集性能。</p>
<h3 id="动态调整新生代大小"><a href="#动态调整新生代大小" class="headerlink" title="动态调整新生代大小"></a>动态调整新生代大小</h3><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小策略，JVM 会根据应用程序的运行情况动态调整新生代和老年代的大小。</p>
<h2 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h2><p>在调整新生代空间大小时，需要考虑以下因素：</p>
<p><strong>应用程序的对象生命周期</strong>：</p>
<p>如果应用程序创建了大量短生命周期对象（例如 Web 应用中的请求对象），则需要较大的新生代空间，以减少 Minor GC 的频率。</p>
<p>如果应用程序有较多长生命周期对象，则需要较大的老年代空间，以减少 Major GC 的频率。</p>
<p><strong>GC 日志分析</strong>：</p>
<p>启用 GC 日志（例如-Xlog:gc*或-XX:+PrintGCDetails），分析垃圾收集的频率和停顿时间，调整新生代和老年代的大小以优化性能。</p>
<p><strong>性能测试</strong>：</p>
<p>在调整 JVM 参数后，进行性能测试，观察 GC 行为和应用程序的响应时间，进一步调整参数以达到最佳性能。</p>
<h2 id="配置-demo"><a href="#配置-demo" class="headerlink" title="配置 demo"></a>配置 demo</h2><p>假设你有一个堆内存大小为 4GB 的 JVM 实例，你希望新生代占 1GB，老年代占 3GB，并且 Eden 区占新生代的 80%，每个 Survivor 区占 10%。可以使用如下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms4g -Xmx4g</span><br><span class="line">-XX:NewSize=1g </span><br><span class="line">-XX:MaxNewSize=1g</span><br><span class="line">-XX:NewRatio=3</span><br><span class="line">-XX:SurvivorRatio=8</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/qd6qd8z80xv9420a">https://www.yuque.com/jingdianjichi/xyxdsi/qd6qd8z80xv9420a</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8_/" itemprop="url">👌Java双亲委派机制的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-12T03:01:32+00:00">
                2025-05-12
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java双亲委派机制的作用"><a href="#👌Java双亲委派机制的作用" class="headerlink" title="👌Java双亲委派机制的作用?"></a>👌Java双亲委派机制的作用?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="保证-Java-核心库的安全性"><a href="#保证-Java-核心库的安全性" class="headerlink" title="保证 Java 核心库的安全性"></a>保证 Java 核心库的安全性</h2><p>通过双亲委派机制，Java 核心库（如java.lang.Object等）由启动类加载器（Bootstrap ClassLoader）加载。由于启动类加载器是在 JVM 启动时由本地代码实现的，并且它加载的类路径是固定的系统核心库路径，因此可以确保这些核心类不会被篡改或替换。这样系统的安全性和稳定性得到了保障。</p>
<h2 id="避免类的重复加载"><a href="#避免类的重复加载" class="headerlink" title="避免类的重复加载"></a>避免类的重复加载</h2><p>双亲委派机制确保了每个类只会被加载一次。如果一个类已经被父类加载器加载过，那么子类加载器就不会再重复加载这个类。这样可以避免类的重复加载，提高类加载的效率，并减少内存消耗。</p>
<h2 id="保证类加载的一致性"><a href="#保证类加载的一致性" class="headerlink" title="保证类加载的一致性"></a>保证类加载的一致性</h2><p>通过双亲委派机制，可以确保同一个类在整个 JVM 中只有一个定义。这样可以避免类的冲突和不一致问题。例如，如果应用程序和第三方库中都定义了一个相同的类名，通过双亲委派机制可以确保最终加载的是位于更高层次的类加载器中的类，从而避免冲突。</p>
<h2 id="提高类加载的效率"><a href="#提高类加载的效率" class="headerlink" title="提高类加载的效率"></a>提高类加载的效率</h2><p>双亲委派机制通过将类加载请求逐级向上委派，可以利用已经加载的类，提高类加载的效率。父类加载器在加载类时，如果该类已经被加载过，那么直接返回该类的引用，从而减少了重复加载的开销。</p>
<h2 id="支持动态扩展"><a href="#支持动态扩展" class="headerlink" title="支持动态扩展"></a>支持动态扩展</h2><p>双亲委派机制允许在不同的类加载器中加载不同的类，从而支持动态扩展。例如，应用程序类加载器（Application ClassLoader）可以加载应用程序特定的类，而扩展类加载器（Extension ClassLoader）可以加载扩展库中的类，这样可以方便地进行动态扩展和模块化开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">226</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
