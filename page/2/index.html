<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/page/2/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/page/2/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB_/" itemprop="url">👌CMS收集器和G1收集器的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌CMS收集器和G1收集器的区别"><a href="#👌CMS收集器和G1收集器的区别" class="headerlink" title="👌CMS收集器和G1收集器的区别?"></a>👌CMS收集器和G1收集器的区别?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>CMS（Concurrent Mark-Sweep）和 G1（Garbage-First）是两种不同的垃圾收集器。</p>
<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS 是一种低停顿的垃圾收集器，设计目标是减少应用程序的停顿时间。它适用于对响应时间要求高的应用程序，例如 Web 服务器。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>CMS 收集器的工作过程主要分为以下几个阶段：</p>
<ol>
<li><strong>初始标记（Initial Mark）</strong>：标记直接可达的对象，这个阶段需要暂停所有应用线程（Stop-the-world，STW）。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：在应用线程运行的同时，标记从初始标记阶段开始的所有可达对象。</li>
<li><strong>重新标记（Remark）</strong>：再次暂停所有应用线程，标记在并发标记阶段发生变化的对象。</li>
<li><strong>并发清除（Concurrent Sweep）</strong>：在应用线程运行的同时，清除不可达的对象。</li>
</ol>
<h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>G1 是一种面向服务端应用的垃圾收集器，设计目标是提供可预测的停顿时间，同时具备较高的吞吐量。G1 收集器适用于大内存、多处理器的环境。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>G1 收集器将堆划分为多个大小相等的区域（Region），每个区域可以作为 Eden、Survivor 或 Old 区。G1 的工作过程包括：</p>
<ol>
<li><strong>初始标记（Initial Mark）</strong>：标记从根对象直接可达的对象，需要暂停应用线程（STW）。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：在应用线程运行的同时，标记从初始标记阶段开始的所有可达对象。</li>
<li><strong>最终标记（Final Mark）</strong>：再次暂停应用线程，标记在并发标记阶段发生变化的对象。</li>
<li><strong>筛选回收（Live Data Counting and Cleanup）</strong>：计算每个区域的存活对象数量，并根据回收收益选择要回收的区域。回收过程包括复制存活对象和清理区域。</li>
</ol>
<h2 id="比较总结"><a href="#比较总结" class="headerlink" title="比较总结"></a>比较总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>CMS 收集器</th>
<th>G1 收集器</th>
</tr>
</thead>
<tbody><tr>
<td>设计目标</td>
<td>低停顿时间</td>
<td>可预测的停顿时间，较高吞吐量</td>
</tr>
<tr>
<td>内存管理</td>
<td>标记-清除，可能产生碎片</td>
<td>标记-复制，减少内存碎片</td>
</tr>
<tr>
<td>并发性</td>
<td>并发标记和清除</td>
<td>并发标记，区域化回收</td>
</tr>
<tr>
<td>停顿时间</td>
<td>较短，但不确定</td>
<td>可配置的停顿时间目标</td>
</tr>
<tr>
<td>适用场景</td>
<td>对响应时间敏感的应用</td>
<td>大内存、多处理器、需要可预测停顿时间的应用</td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><p><strong>CMS 收集器</strong>：适用于对响应时间要求高、内存较小、应用负载相对稳定的场景。</p>
<p><strong>G1 收集器</strong>：适用于大内存、多处理器环境，需要可预测停顿时间的应用，特别是那些需要处理大量数据和高并发请求的服务端应用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%9F/" itemprop="url">👌JVM创建对象的时候，如何进行并发处理？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM创建对象的时候，如何进行并发处理？"><a href="#👌JVM创建对象的时候，如何进行并发处理？" class="headerlink" title="👌JVM创建对象的时候，如何进行并发处理？"></a>👌JVM创建对象的时候，如何进行并发处理？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，为了支持高效的并发处理，特别是在创建对象时，JVM 采用了多种技术和优化策略。这些技术和策略旨在确保在多线程环境下对象创建的安全性和效率。</p>
<h2 id="TLAB（Thread-Local-Allocation-Buffers）"><a href="#TLAB（Thread-Local-Allocation-Buffers）" class="headerlink" title="TLAB（Thread-Local Allocation Buffers）"></a>TLAB（Thread-Local Allocation Buffers）</h2><p>TLAB 是 JVM 中的一种优化技术，用于减少线程间的内存分配冲突。每个线程都会被分配一个小的、私有的堆内存空间，称为 TLAB。对象首先尝试在 TLAB 中分配内存。如果 TLAB 中有足够的空间，内存分配可以在没有锁竞争的情况下完成，从而提高性能。</p>
<h3 id="TLAB-工作流程"><a href="#TLAB-工作流程" class="headerlink" title="TLAB 工作流程"></a>TLAB 工作流程</h3><ol>
<li><strong>分配 TLAB</strong>：每个线程在创建时都会被分配一个 TLAB。</li>
<li><strong>对象分配</strong>：当线程需要分配对象时，首先尝试在其 TLAB 中分配内存。</li>
<li><strong>TLAB 用尽</strong>：如果 TLAB 中没有足够的空间，线程会请求分配新的 TLAB。如果堆内存不足以分配新的 TLAB，线程将直接在全局堆中分配内存，这时可能需要进行同步操作。</li>
</ol>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>在某些情况下，特别是当 TLAB 用尽或者需要直接在全局堆中分配内存时，JVM 需要使用锁机制来确保线程安全。常见的锁机制包括：</p>
<p><strong>轻量级锁（Lightweight Locking）</strong>：通过使用 CAS（Compare-And-Swap）操作来实现快速锁定和解锁，适用于竞争不激烈的场景。</p>
<p><strong>偏向锁（Biased Locking）</strong>：当锁倾向于被同一个线程持有时，JVM 会减少锁的开销，适用于单线程访问的情况。</p>
<p><strong>重量级锁（Heavyweight Locking）</strong>：当锁竞争激烈时，JVM 会使用操作系统的互斥锁（如synchronized关键字），这会导致较高的开销。</p>
<h2 id="并发垃圾回收器"><a href="#并发垃圾回收器" class="headerlink" title="并发垃圾回收器"></a>并发垃圾回收器</h2><p>并发垃圾回收器（如 G1、ZGC 和 Shenandoah）在进行垃圾回收时，尽量减少对应用线程的暂停时间。它们通过并发标记、并发清理和增量压缩等技术，确保在多线程环境下高效地管理堆内存。</p>
<h2 id="内存屏障（Memory-Barriers）"><a href="#内存屏障（Memory-Barriers）" class="headerlink" title="内存屏障（Memory Barriers）"></a>内存屏障（Memory Barriers）</h2><p>JVM 使用内存屏障来确保内存操作的顺序性和可见性。内存屏障是一种低级同步原语，用于防止编译器和 CPU 重新排序内存操作，从而确保在多线程环境下的内存一致性。</p>
<h2 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare-And-Swap）"></a>CAS（Compare-And-Swap）</h2><p>CAS 是一种无锁的同步机制，广泛用于 JVM 的并发处理。它允许线程在不使用锁的情况下进行原子操作，从而提高并发性能。CAS 操作包括以下步骤：</p>
<ol>
<li><strong>读取内存位置的当前值</strong>。</li>
<li><strong>比较当前值和预期值</strong>。</li>
<li><strong>如果当前值等于预期值，则写入新值</strong>。</li>
</ol>
<p>如果在写入过程中发现当前值已被其他线程修改，CAS 操作会失败，线程可以选择重试或采取其他措施。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" itemprop="url">👌JVM堆和栈的区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM堆和栈的区别？"><a href="#👌JVM堆和栈的区别？" class="headerlink" title="👌JVM堆和栈的区别？"></a>👌JVM堆和栈的区别？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM（Java Virtual Machine）中，堆（Heap）和栈（Stack）是两种不同的内存区域，它们在内存管理和程序执行中扮演着不同的角色。</p>
<table>
<thead>
<tr>
<th></th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>用于存储所有的对象实例和数组，都在堆中分配内存。</td>
<td>用于存储方法的局部变量、方法调用的参数和方法的调用信息（如返回地址）。每个线程都有自己的栈，栈中的数据与线程一一对应。</td>
</tr>
<tr>
<td>内存管理方式</td>
<td>由垃圾收集器进行自动管理，负责分配和回收对象内存。堆内存是全局共享的，所有线程都可以访问堆中的对象。</td>
<td>由编译器自动管理，内存分配和释放按照方法调用的顺序进行。栈内存是线程私有的，每个线程都有自己的栈，互不干扰。</td>
</tr>
<tr>
<td>生命周期</td>
<td>对象在堆中的生命周期由垃圾收集器决定，只要有引用指向对象，对象就会存在。</td>
<td></td>
</tr>
<tr>
<td>对象的生命周期可以跨越多个方法调用，直到没有引用指向它时才会被垃圾收集器回收。</td>
<td>局部变量的生命周期与方法调用的生命周期一致，方法调用结束时，栈帧被销毁，局部变量也随之销毁。</td>
<td></td>
</tr>
<tr>
<td>栈中的数据在方法调用结束后立即释放。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>内存大小</td>
<td>通常较大，可以通过 JVM 参数（如-Xms和-Xmx）进行配置。适合存储需要较长生命周期的大量对象。</td>
<td>通常较小，每个线程的栈大小可以通过 JVM 参数（如-Xss）进行配置。适合存储短生命周期的小数据。</td>
</tr>
<tr>
<td>线程安全</td>
<td>由于是全局共享的，堆中的对象在多线程环境下需要进行同步控制，以避免线程安全问题。</td>
<td>线程私有的，栈中的数据天然是线程安全的，不需要额外的同步控制。</td>
</tr>
<tr>
<td>访问速度</td>
<td>访问速度相对较慢，因为需要通过引用进行访问，并且涉及到垃圾收集器的管理。</td>
<td>访问速度相对较快，因为栈中数据直接通过栈帧进行访问，且栈的内存分配和释放效率高。</td>
</tr>
<tr>
<td>内存溢出</td>
<td>如果堆内存不足，会抛出OutOfMemoryError（如java.lang.OutOfMemoryError: Java heap space）。</td>
<td>如果栈内存不足，会抛出StackOverflowError（如java.lang.StackOverflowError）。</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/" itemprop="url">👌JVM的三色标记算法是什么？解决了什么问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM的三色标记算法是什么？解决了什么问题？"><a href="#👌JVM的三色标记算法是什么？解决了什么问题？" class="headerlink" title="👌JVM的三色标记算法是什么？解决了什么问题？"></a>👌JVM的三色标记算法是什么？解决了什么问题？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>三色标记算法通过颜色标记和处理队列，解决了并发垃圾收集过程中对象引用变化导致的标记不准确问题。它确保所有存活对象都能被正确标记，从而避免了存活对象被错误回收。同时，写屏障技术的使用进一步保证了颜色不变性，确保算法在并发环境下的正确性。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>三色标记算法是一种用于垃圾回收的标记算法，通过将对象分为三种颜色（白色、灰色和黑色）来管理垃圾收集过程。它主要解决了在并发垃圾收集过程中如何正确标记存活对象的问题，避免了遗漏存活对象或错误标记对象的情况。</p>
<h2 id="三色标记算法的基本概念"><a href="#三色标记算法的基本概念" class="headerlink" title="三色标记算法的基本概念"></a>三色标记算法的基本概念</h2><p><strong>白色</strong>：表示对象尚未被垃圾收集器访问到。如果垃圾收集过程结束时对象仍然是白色，它将被视为不可达对象，随后被回收。</p>
<p><strong>灰色</strong>：表示对象已被访问到，但其引用的对象尚未全部访问。灰色对象需要进一步扫描其引用的对象。</p>
<p><strong>黑色</strong>：表示对象及其引用的对象都已被访问到。黑色对象不需要再扫描。</p>
<h2 id="三色标记算法的工作流程"><a href="#三色标记算法的工作流程" class="headerlink" title="三色标记算法的工作流程"></a>三色标记算法的工作流程</h2><ol>
<li><strong>初始化</strong>：所有对象开始时都是白色的。</li>
<li><strong>标记根对象</strong>：将根对象（GC Roots）标记为灰色，并将它们放入一个待处理队列。</li>
<li><strong>处理灰色对象</strong>：</li>
</ol>
<p>从队列中取出一个灰色对象，将其标记为黑色，将该对象引用的所有白色对象标记为灰色，并将这些灰色对象加入队列。</p>
<ol start="4">
<li><strong>重复步骤 3</strong>，直到队列为空。</li>
<li><strong>清除白色对象</strong>：所有剩余的白色对象都是不可达的，可以被回收。</li>
</ol>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>三色标记算法主要解决了以下问题：</p>
<ol>
<li><strong>并发标记的准确性</strong>：在并发垃圾收集过程中，应用线程可能会修改对象引用，导致垃圾收集器标记不准确。三色标记算法通过颜色标记和处理队列，确保所有存活对象都能被正确标记。</li>
<li><strong>避免重复标记</strong>：通过将对象分为三种颜色，垃圾收集器能有效避免重复标记对象，提高标记效率。</li>
<li><strong>处理对象引用变化</strong>：在并发标记阶段，应用线程可能会增加或删除对象引用。三色标记算法通过维护颜色状态和处理队列，确保引用变化不会导致存活对象被错误回收。</li>
</ol>
<h2 id="颜色不变性"><a href="#颜色不变性" class="headerlink" title="颜色不变性"></a>颜色不变性</h2><p>为了确保三色标记算法在并发环境下的正确性，通常需要维护以下两种不变性之一：</p>
<ol>
<li><strong>强三色不变性</strong>：黑色对象不能直接引用白色对象。这意味着如果一个黑色对象引用了一个白色对象，白色对象必须先被标记为灰色。</li>
<li><strong>弱三色不变性</strong>：在标记阶段，白色对象只能通过灰色对象直接或间接引用。这意味着如果一个白色对象被引用，它一定会通过一个灰色对象。</li>
</ol>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>为了维护颜色不变性，垃圾收集器通常会使用写屏障技术。在对象引用发生变化时，写屏障会执行特定的操作，确保颜色不变性不被破坏。例如，在引用赋值操作时，写屏障可能会将目标对象标记为灰色，确保其不会被错误回收。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E7%9A%84%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E7%9A%84%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F/" itemprop="url">👌JVM的类命名空间如何理解？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM的类命名空间如何理解？"><a href="#👌JVM的类命名空间如何理解？" class="headerlink" title="👌JVM的类命名空间如何理解？"></a>👌JVM的类命名空间如何理解？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的类命名空间是指 JVM 在运行时用来区分和管理不同类加载器加载的类的机制。</p>
<h2 id="类命名空间的基本概念"><a href="#类命名空间的基本概念" class="headerlink" title="类命名空间的基本概念"></a>类命名空间的基本概念</h2><p>在 JVM 中，每个类加载器都有自己的命名空间。一个类的完全限定名（即类的全路径名，例如com.example.MyClass）在 JVM 的命名空间中是唯一的，但同一个完全限定名的类可以由不同的类加载器加载，从而在不同的命名空间中存在多个版本。</p>
<h2 id="类命名空间的工作原理"><a href="#类命名空间的工作原理" class="headerlink" title="类命名空间的工作原理"></a>类命名空间的工作原理</h2><ol>
<li><strong>双亲委派模型</strong>：类加载器在加载一个类时，首先会将请求委派给父类加载器。如果父类加载器无法找到该类，才会由当前类加载器尝试加载。这种机制确保了核心类库的优先加载和安全性。</li>
<li><strong>类的唯一性</strong>：在 JVM 中，一个类由其完全限定名和加载它的类加载器共同决定。即使两个类的完全限定名相同，但如果它们是由不同的类加载器加载的，那么它们在 JVM 中被认为是不同的类。</li>
</ol>
<h2 id="类命名空间示例"><a href="#类命名空间示例" class="headerlink" title="类命名空间示例"></a>类命名空间示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderNamespaceDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 创建两个自定义类加载器</span><br><span class="line">        ClassLoader classLoader1 = new CustomClassLoader();</span><br><span class="line">        ClassLoader classLoader2 = new CustomClassLoader();</span><br><span class="line"></span><br><span class="line">        // 使用不同的类加载器加载同一个类</span><br><span class="line">        Class&lt;?&gt; class1 = classLoader1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">        Class&lt;?&gt; class2 = classLoader2.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line"></span><br><span class="line">        // 比较两个类对象是否相同</span><br><span class="line">        System.out.println(class1 == class2); // 输出 false，说明类对象在不同的命名空间中</span><br><span class="line"></span><br><span class="line">        // 实例化对象并调用方法</span><br><span class="line">        Object obj1 = class1.getDeclaredConstructor().newInstance();</span><br><span class="line">        Object obj2 = class2.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        Method method1 = class1.getMethod(&quot;sayHello&quot;);</span><br><span class="line">        Method method2 = class2.getMethod(&quot;sayHello&quot;);</span><br><span class="line"></span><br><span class="line">        method1.invoke(obj1);</span><br><span class="line">        method2.invoke(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义类加载器</span><br><span class="line">class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        if (name.startsWith(&quot;com.example&quot;)) &#123;</span><br><span class="line">            // 自定义加载逻辑，例如从文件系统或网络加载类字节码</span><br><span class="line">            byte[] classData = getClassData(name);</span><br><span class="line">            if (classData != null) &#123;</span><br><span class="line">                return defineClass(name, classData, 0, classData.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassData(String className) &#123;</span><br><span class="line">        // 实现类加载的逻辑，例如从文件系统或网络加载类字节码</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomClassLoader是一个自定义类加载器。我们创建了两个CustomClassLoader实例，并分别使用它们加载同一个类com.example.MyClass。由于这两个类加载器是不同的，因此它们各自的命名空间也是不同的，即使类的完全限定名相同，加载后的类对象也是不同的。</p>
<h2 id="类命名空间的应用"><a href="#类命名空间的应用" class="headerlink" title="类命名空间的应用"></a>类命名空间的应用</h2><ol>
<li><strong>模块化</strong>：通过使用不同的类加载器，可以实现模块化的类加载，每个模块有自己的命名空间，互不干扰。</li>
<li><strong>隔离</strong>：在应用服务器（如 Tomcat）中，不同的应用程序使用不同的类加载器，从而实现类的隔离，避免类冲突。</li>
<li><strong>插件系统</strong>：在插件系统中，每个插件可以使用自己的类加载器加载类，确保插件之间的独立性和隔离性。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E7%B1%BB%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%8D%B8%E8%BD%BD%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E7%B1%BB%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%8D%B8%E8%BD%BD%EF%BC%9F/" itemprop="url">👌JVM类何时可以卸载？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM类何时可以卸载？"><a href="#👌JVM类何时可以卸载？" class="headerlink" title="👌JVM类何时可以卸载？"></a>👌JVM类何时可以卸载？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="类加载器被卸载"><a href="#类加载器被卸载" class="headerlink" title="类加载器被卸载"></a>类加载器被卸载</h2><p>类的卸载与类加载器的生命周期密切相关。只有当一个类加载器没有任何活动的引用时，JVM 才会考虑卸载由该加载器加载的所有类。因此，类的卸载通常发生在类加载器被卸载的时候。具体条件包括：</p>
<p><strong>类加载器没有活动的引用</strong>：即没有任何线程或静态变量引用该类加载器。</p>
<p><strong>类加载器加载的所有类都没有活动的引用</strong>：即这些类的实例、静态字段和方法都不再被引用。</p>
<h2 id="没有对类的实例的引用"><a href="#没有对类的实例的引用" class="headerlink" title="没有对类的实例的引用"></a>没有对类的实例的引用</h2><p>为了卸载一个类，JVM 需要确保没有对该类的实例的引用。</p>
<p>没有该类的对象实例在堆中。</p>
<p>没有对该类的静态字段的引用。</p>
<p>没有活动线程在执行该类的方法。</p>
<h2 id="没有对类的静态方法和静态字段的引用"><a href="#没有对类的静态方法和静态字段的引用" class="headerlink" title="没有对类的静态方法和静态字段的引用"></a>没有对类的静态方法和静态字段的引用</h2><p>如果一个类的静态方法或静态字段仍然被引用，那么该类将不会被卸载。因此，JVM 必须确保：没有线程在执行该类的静态方法。没有对该类的静态字段的引用。</p>
<h2 id="没有对类加载器的引用"><a href="#没有对类加载器的引用" class="headerlink" title="没有对类加载器的引用"></a>没有对类加载器的引用</h2><p>类的卸载需要确保类加载器本身也没有被引用。这意味着：</p>
<p>没有其他类加载器或对象引用该类加载器。该类加载器加载的所有类都可以被卸载。</p>
<h2 id="完成垃圾回收"><a href="#完成垃圾回收" class="headerlink" title="完成垃圾回收"></a>完成垃圾回收</h2><p>类的卸载通常发生在垃圾回收过程中。垃圾回收器会检查类加载器及其加载的类是否符合卸载条件。如果符合条件，垃圾回收器会卸载这些类并释放相关内存。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ClassUnloadingExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 创建一个新的类加载器</span><br><span class="line">        CustomClassLoader classLoader = new CustomClassLoader();</span><br><span class="line"></span><br><span class="line">        // 加载一个类</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(&quot;MyClass&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建类的实例</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        // 清除对类加载器和类实例的引用</span><br><span class="line">        classLoader = null;</span><br><span class="line">        instance = null;</span><br><span class="line"></span><br><span class="line">        // 请求垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 让垃圾回收器有时间运行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Class unloading example completed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">            if (&quot;MyClass&quot;.equals(name)) &#123;</span><br><span class="line">                byte[] classData = getClassData();</span><br><span class="line">                return defineClass(name, classData, 0, classData.length);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private byte[] getClassData() &#123;</span><br><span class="line">            // 模拟加载类数据</span><br><span class="line">            return new byte[]&#123;/* class data */&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个自定义的类加载器CustomClassLoader，并使用它加载一个类MyClass。然后，我们清除对类加载器和类实例的引用，并请求垃圾回收。垃圾回收器在条件满足时会卸载MyClass类。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%90%97_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%90%97_/" itemprop="url">👌Java会存在内存泄露吗</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java会存在内存泄露吗"><a href="#👌Java会存在内存泄露吗" class="headerlink" title="👌Java会存在内存泄露吗?"></a>👌Java会存在内存泄露吗?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>内存泄漏指的是程序在运行过程中由于某种原因未能释放不再使用的内存，导致内存使用量不断增加，最终可能耗尽可用内存。通常是由于程序逻辑错误或不当的资源管理引起的。</p>
<h2 id="常见的内存泄漏情况"><a href="#常见的内存泄漏情况" class="headerlink" title="常见的内存泄漏情况"></a>常见的内存泄漏情况</h2><h3 id="静态集合类（如HashMap、ArrayList）持有对象引用"><a href="#静态集合类（如HashMap、ArrayList）持有对象引用" class="headerlink" title="静态集合类（如HashMap、ArrayList）持有对象引用"></a>静态集合类（如HashMap、ArrayList）持有对象引用</h3><p>静态集合类会在整个应用程序生命周期内存在，如果没有及时清理不再使用的对象引用，这些对象就无法被垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryLeakExample &#123;</span><br><span class="line">    private static List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addToList(Object obj) &#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听器和回调函数"><a href="#监听器和回调函数" class="headerlink" title="监听器和回调函数"></a>监听器和回调函数</h3><p>如果注册的监听器或回调函数没有及时解除注册，它们持有的对象引用也会导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class EventSource &#123;</span><br><span class="line">    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void registerListener(EventListener listener) &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未关闭的资源"><a href="#未关闭的资源" class="headerlink" title="未关闭的资源"></a>未关闭的资源</h3><p>打开的文件、数据库连接、网络连接等资源如果没有及时关闭，会导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void readFile(String filePath) throws IOException &#123;</span><br><span class="line">    BufferedReader reader = new BufferedReader(new FileReader(filePath));</span><br><span class="line">    // 忘记关闭 reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类和匿名类持有外部类引用："><a href="#内部类和匿名类持有外部类引用：" class="headerlink" title="内部类和匿名类持有外部类引用："></a>内部类和匿名类持有外部类引用：</h3><p>内部类和匿名类会持有外部类的引用，如果这些类的实例生命周期较长，会导致外部类无法被垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String data;</span><br><span class="line"></span><br><span class="line">    public void startThread() &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存（Cache）没有清理："><a href="#缓存（Cache）没有清理：" class="headerlink" title="缓存（Cache）没有清理："></a>缓存（Cache）没有清理：</h3><p>使用缓存时，如果没有适当的清理策略（如 LRU 缓存），缓存中的对象会一直存在，导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CacheExample &#123;</span><br><span class="line">    private Map&lt;String, Object&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addToCache(String key, Object value) &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测和解决内存泄漏的方法"><a href="#检测和解决内存泄漏的方法" class="headerlink" title="检测和解决内存泄漏的方法"></a>检测和解决内存泄漏的方法</h2><h3 id="使用内存分析工具："><a href="#使用内存分析工具：" class="headerlink" title="使用内存分析工具："></a>使用内存分析工具：</h3><p>工具如 VisualVM、Eclipse MAT（Memory Analyzer Tool）可以帮助分析堆内存，找出可能的内存泄漏点。</p>
<h3 id="代码审查："><a href="#代码审查：" class="headerlink" title="代码审查："></a>代码审查：</h3><p>仔细审查代码，确保没有不必要的对象引用，及时释放资源。</p>
<h3 id="使用try-with-resources语句"><a href="#使用try-with-resources语句" class="headerlink" title="使用try-with-resources语句"></a>使用try-with-resources语句</h3><p>确保资源在使用完毕后被及时关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void readFile(String filePath) throws IOException &#123;</span><br><span class="line">    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class="line">        // 读取文件内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解除监听器注册"><a href="#解除监听器注册" class="headerlink" title="解除监听器注册"></a>解除监听器注册</h3><p>确保在不再需要监听器时解除注册。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class EventSource &#123;</span><br><span class="line">    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void registerListener(EventListener listener) &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unregisterListener(EventListener listener) &#123;</span><br><span class="line">        listeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%EF%BC%9F/" itemprop="url">👌Java创建对象的主要流程？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java创建对象的主要流程？"><a href="#👌Java创建对象的主要流程？" class="headerlink" title="👌Java创建对象的主要流程？"></a>👌Java创建对象的主要流程？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p>当使用new关键字创建对象时，JVM 首先检查类是否已经被加载、链接和初始化。如果类还没有被加载，JVM 会先执行类加载过程。类加载过程包括以下步骤：</p>
<p><strong>加载（Loading）</strong>：从文件系统或网络中读取类的二进制数据，并创建一个Class对象。</p>
<p><strong>链接（Linking）</strong>：包括验证（Verify）、准备（Prepare）和解析（Resolve）三个阶段。</p>
<ul>
<li><strong>验证</strong>：确保类的字节码符合 JVM 规范，没有安全问题。</li>
<li><strong>准备</strong>：为类的静态变量分配内存，并将其初始化为默认值。</li>
<li><strong>解析</strong>：将类的符号引用转换为直接引用。</li>
</ul>
<p><strong>初始化（Initialization）</strong>：执行类的静态初始化块和静态变量的初始化。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>一旦类被加载并初始化，JVM 会在堆中为新对象分配内存。内存分配的具体方式取决于 JVM 的实现，一般有以下几种方式：</p>
<p><strong>指针碰撞（Bump-the-pointer）</strong>：如果堆内存是规整的，所有已使用的内存都在一边，空闲内存都在另一边，中间有一个指针作为分界线。分配内存时，只需将指针向空闲内存方向移动一段与对象大小相等的距离。</p>
<p><strong>空闲列表（Free-list）</strong>：如果堆内存不规整，JVM 会维护一个空闲列表，记录哪些内存块是可用的。分配内存时，从空闲列表中找到一个足够大的内存块进行分配。</p>
<h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><p>在内存分配完成后，JVM 会将分配的内存空间初始化为零值。这一步确保了对象的实例变量在 Java 语言层面上有默认值（如0、false或null）。</p>
<h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>JVM 会在对象的内存区域中设置对象头（Object Header），对象头包含以下信息：</p>
<p><strong>Mark Word</strong>：存储对象的运行时数据，如哈希码、GC 分代年龄、锁状态等。</p>
<p><strong>Class Pointer</strong>：指向对象的类元数据，JVM 通过它来确定对象是哪个类的实例。</p>
<h2 id="执行构造器"><a href="#执行构造器" class="headerlink" title="执行构造器"></a>执行构造器</h2><p>最后，JVM 调用对象的构造器（Constructor）进行初始化。构造器初始化包括：</p>
<p><strong>执行父类构造器</strong>：如果类有父类，首先会调用父类的构造器。</p>
<p><strong>初始化实例变量</strong>：按照代码中定义的顺序初始化实例变量。</p>
<p><strong>执行构造器代码</strong>：执行构造器中的代码。</p>
<h2 id="返回对象引用"><a href="#返回对象引用" class="headerlink" title="返回对象引用"></a>返回对象引用</h2><p>构造器执行完毕后，JVM 返回新创建对象的引用。此时，对象已经完全初始化，可以被程序使用。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>展示对象创建的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    // 静态初始化块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Class MyClass is being initialized.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例初始化块</span><br><span class="line">    &#123;</span><br><span class="line">        value = 10;</span><br><span class="line">        System.out.println(&quot;Instance initialization block.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构造器</span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        System.out.println(&quot;Constructor is called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass obj = new MyClass();</span><br><span class="line">        System.out.println(&quot;Object created with value: &quot; + obj.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class MyClass is being initialized.</span><br><span class="line">Instance initialization block.</span><br><span class="line">Constructor is called.</span><br><span class="line">Object created with value: 10</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F/" itemprop="url">👌Java创建对象的几种方式？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java创建对象的几种方式？"><a href="#👌Java创建对象的几种方式？" class="headerlink" title="👌Java创建对象的几种方式？"></a>👌Java创建对象的几种方式？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用new关键字</h2><p>这是最常见和直接的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>

<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>通过Class类的newInstance()方法（已过时）或Constructor类的newInstance()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Class.newInstance() 方法（已过时）</span><br><span class="line">MyClass obj1 = MyClass.class.newInstance();</span><br><span class="line"></span><br><span class="line">// 使用 Constructor.newInstance() 方法</span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line">MyClass obj2 = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="使用clone-方法"><a href="#使用clone-方法" class="headerlink" title="使用clone()方法"></a>使用clone()方法</h2><p>通过实现Cloneable接口并重写clone()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass implements Cloneable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj1 = new MyClass();</span><br><span class="line">MyClass obj2 = (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>

<h2 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h2><p>通过ObjectInputStream进行反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 序列化对象</span><br><span class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">// 反序列化对象</span><br><span class="line">ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));</span><br><span class="line">MyClass obj = (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h2 id="使用工厂方法"><a href="#使用工厂方法" class="headerlink" title="使用工厂方法"></a>使用工厂方法</h2><p>通过工厂方法模式创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassFactory &#123;</span><br><span class="line">    public static MyClass createInstance() &#123;</span><br><span class="line">        return new MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = MyClassFactory.createInstance();</span><br></pre></td></tr></table></figure>

<h2 id="使用-Builder-模式"><a href="#使用-Builder-模式" class="headerlink" title="使用 Builder 模式"></a>使用 Builder 模式</h2><p>通过构建器模式创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private String field1;</span><br><span class="line">    private int field2;</span><br><span class="line"></span><br><span class="line">    private MyClass(Builder builder) &#123;</span><br><span class="line">        this.field1 = builder.field1;</span><br><span class="line">        this.field2 = builder.field2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String field1;</span><br><span class="line">        private int field2;</span><br><span class="line"></span><br><span class="line">        public Builder setField1(String field1) &#123;</span><br><span class="line">            this.field1 = field1;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setField2(int field2) &#123;</span><br><span class="line">            this.field2 = field2;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public MyClass build() &#123;</span><br><span class="line">            return new MyClass(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = new MyClass.Builder().setField1(&quot;value1&quot;).setField2(42).build();</span><br></pre></td></tr></table></figure>

<h2 id="通过Unsafe类"><a href="#通过Unsafe类" class="headerlink" title="通过Unsafe类"></a>通过Unsafe类</h2><p>使用sun.misc.Unsafe类（不建议在生产代码中使用，因为它依赖于内部 API，且不安全）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class UnsafeExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line"></span><br><span class="line">        MyClass obj = (MyClass) unsafe.allocateInstance(MyClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>new关键字</strong>：最常用，适用于大多数情况。</p>
<p><strong>反射</strong>：灵活但性能较差，适用于框架或工具类开发。</p>
<p><strong>clone()方法</strong>：适用于需要精确复制对象的情况。</p>
<p><strong>反序列化</strong>：适用于需要从持久化存储中恢复对象的情况。</p>
<p><strong>工厂方法和 Builder 模式</strong>：适用于需要复杂对象创建逻辑的情况。</p>
<p><strong>Unsafe类</strong>：不建议使用，除非在非常特殊的低级别操作中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E6%98%AF%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E6%98%AF%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80/" itemprop="url">👌Java是解释语言还是编译语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java是解释语言还是编译语言"><a href="#👌Java是解释语言还是编译语言" class="headerlink" title="👌Java是解释语言还是编译语言"></a>👌Java是解释语言还是编译语言</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 是一种既具有编译特性又具有解释特性的语言。它独特的运行机制使得它既不同于传统的编译语言（如 C 或 C++），也不同于传统的解释语言（如 Python 或 JavaScript）。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><strong>源代码编译</strong>：</p>
<p>Java 源代码文件（.java 文件）首先通过 Java 编译器（javac）编译成字节码文件（.class 文件）。这个编译过程将高层次的 Java 代码转换成一种中间表示形式，即字节码。这些字节码是平台无关的，可以在任何支持 Java 虚拟机（JVM）的系统上运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MyClass.java</span><br></pre></td></tr></table></figure>

<p><strong>字节码</strong>：字节码是一种中间语言，它并不是直接可执行的机器码，而是需要进一步解释或编译成机器码才能运行。</p>
<p>字节码的设计使得 Java 程序可以在不同的平台上运行，而无需重新编译源代码。</p>
<h2 id="解释阶段"><a href="#解释阶段" class="headerlink" title="解释阶段"></a>解释阶段</h2><p>当运行一个 Java 程序时，Java 虚拟机（JVM）会加载字节码并解释执行。JVM 内部包含一个解释器，它将字节码逐行解释成机器指令，然后执行这些指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyClass</span><br></pre></td></tr></table></figure>

<h2 id="Just-In-Time-JIT-编译"><a href="#Just-In-Time-JIT-编译" class="headerlink" title="Just-In-Time (JIT) 编译"></a>Just-In-Time (JIT) 编译</h2><p>为了提高性能，现代 JVM 实现通常包含一个 Just-In-Time (JIT) 编译器。JIT 编译器在程序运行时，将热点代码（即频繁执行的代码）动态编译成本地机器码，从而提高执行效率。这种动态编译使得 Java 结合了解释语言的灵活性和编译语言的高性能。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Java 既是一种编译语言，也是一种解释语言。它通过先编译成字节码，然后由 JVM 解释执行，并结合 JIT 编译优化性能。这种独特的机制使得 Java 具有跨平台性和高效性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B_/" itemprop="url">👌一次完整的垃圾回收过程是什么样的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java的类加载器有哪些"><a href="#👌Java的类加载器有哪些" class="headerlink" title="👌Java的类加载器有哪些?"></a>👌Java的类加载器有哪些?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，类加载器（ClassLoader）是负责将类文件加载到 JVM 中的组件。Java 提供了几种标准的类加载器，每种类加载器都有特定的职责和加载范围。</p>
<h2 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h2><p><strong>职责</strong>：加载 Java 核心类库，如java.lang.*、java.util.*等。</p>
<p><strong>实现</strong>：由本地代码（通常是 C++）实现，不是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或jrt:&#x2F;modules（在模块化系统中）。</p>
<p><strong>特点</strong>：是所有类加载器的顶层，没有父类加载器。</p>
<h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><p><strong>职责</strong>：加载扩展库中的类。</p>
<p><strong>实现</strong>：由sun.misc.Launcher$ExtClassLoader实现，是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录或由java.ext.dirs系统属性指定的目录。</p>
<p><strong>父类加载器</strong>：引导类加载器。</p>
<h2 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h2><p><strong>职责</strong>：加载应用程序类路径（classpath）中的类。</p>
<p><strong>实现</strong>：由sun.misc.Launcher$AppClassLoader实现，是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：由java.class.path系统属性指定的目录和 JAR 文件。</p>
<p><strong>父类加载器</strong>：扩展类加载器。</p>
<h2 id="自定义类加载器（Custom-ClassLoader）"><a href="#自定义类加载器（Custom-ClassLoader）" class="headerlink" title="自定义类加载器（Custom ClassLoader）"></a>自定义类加载器（Custom ClassLoader）</h2><p><strong>职责</strong>：满足特定需求的类加载器，通常在应用程序中自定义实现。</p>
<p><strong>实现</strong>：继承java.lang.ClassLoader并重写findClass方法。</p>
<p><strong>加载路径</strong>：由开发者自行定义，可以是文件系统、网络、数据库等。</p>
<p><strong>父类加载器</strong>：可以指定，也可以继承应用程序类加载器。</p>
<p>以下是一个简单的自定义类加载器示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/aldxe3g9bqszh1eh">https://www.yuque.com/jingdianjichi/xyxdsi/aldxe3g9bqszh1eh</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/java%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/java%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F_/" itemprop="url">👌java 加载 class 文件的几种方式?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌java-加载-class-文件的几种方式"><a href="#👌java-加载-class-文件的几种方式" class="headerlink" title="👌java 加载 class 文件的几种方式?"></a>👌java 加载 class 文件的几种方式?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="使用系统类加载器"><a href="#使用系统类加载器" class="headerlink" title="使用系统类加载器"></a>使用系统类加载器</h2><p>Java的系统类加载器（ClassLoader.getSystemClassLoader()）是默认的类加载器，可以用来加载类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = ClassLoader.getSystemClassLoader().loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义类加载器"><a href="#使用自定义类加载器" class="headerlink" title="使用自定义类加载器"></a>使用自定义类加载器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    byte[] classData = loadClassData(name);</span><br><span class="line">    if (classData == null) &#123;</span><br><span class="line">      throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line">    return defineClass(name, classData, 0, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private byte[] loadClassData(String name) &#123;</span><br><span class="line">    // 实现加载类数据的逻辑</span><br><span class="line">    return null; // 示例中返回null，实际应返回类的字节码数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      CustomClassLoader customClassLoader = new CustomClassLoader();</span><br><span class="line">      Class&lt;?&gt; clazz = customClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">      System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用URLClassLoader"><a href="#使用URLClassLoader" class="headerlink" title="使用URLClassLoader"></a>使用URLClassLoader</h2><p>URLClassLoader可以从指定的URL加载类，适用于从JAR文件或远程位置加载类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class URLClassLoaderExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      URL[] urls = &#123;new URL(&quot;file:///path/to/your/classes/&quot;)&#125;;</span><br><span class="line">      URLClassLoader urlClassLoader = new URLClassLoader(urls);</span><br><span class="line">      Class&lt;?&gt; clazz = urlClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">      System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>使用反射机制的Class.forName()方法加载类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Thread-currentThread-getContextClassLoader"><a href="#使用Thread-currentThread-getContextClassLoader" class="headerlink" title="使用Thread.currentThread().getContextClassLoader()"></a>使用Thread.currentThread().getContextClassLoader()</h2><p>获取当前线程的上下文类加载器来加载类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    Class&lt;?&gt; clazz = contextClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><font style="color:#2f5496;"></font></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/jvm%E7%9A%84%E7%B1%BB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/jvm%E7%9A%84%E7%B1%BB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88/" itemprop="url">👌jvm 的类缓存机制是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-的类缓存机制是什么"><a href="#👌jvm-的类缓存机制是什么" class="headerlink" title="👌jvm 的类缓存机制是什么"></a>👌jvm 的类缓存机制是什么</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的类缓存机制是指 JVM 在加载类时，将类的字节码和相关信息（如方法、字段、常量池等）存储在内存中的一种机制。这样做的目的是为了提高类加载的效率，避免重复加载相同的类。</p>
<h2 id="类缓存机制的工作原理"><a href="#类缓存机制的工作原理" class="headerlink" title="类缓存机制的工作原理"></a>类缓存机制的工作原理</h2><ol>
<li><strong>类加载器缓存</strong>：每个类加载器都有一个自己的缓存，用于存储已经加载的类。当需要加载一个类时，类加载器首先会检查其缓存中是否已经有该类的Class对象。如果有，则直接返回该对象；如果没有，则加载该类并将其缓存起来。</li>
<li><strong>双亲委派机制</strong>：在加载类时，类加载器会首先委派给其父类加载器进行加载。如果父类加载器无法加载该类，则由当前类加载器尝试加载。这种机制也有助于类缓存，因为父类加载器的缓存中可能已经有了该类。</li>
<li><strong>常量池缓存</strong>：JVM 会将类的常量池（constant pool）中的符号引用解析为直接引用，并将这些引用缓存起来，以便后续使用时可以快速访问。</li>
</ol>
<h2 id="类缓存的好处"><a href="#类缓存的好处" class="headerlink" title="类缓存的好处"></a>类缓存的好处</h2><p><strong>提高性能</strong>：通过缓存已经加载的类，可以避免重复加载相同的类，从而提高类加载的效率。</p>
<p><strong>减少内存消耗</strong>：缓存机制可以减少类加载过程中重复分配和初始化内存的开销。</p>
<p><strong>保证类的一致性</strong>：通过缓存机制，可以确保同一个类在 JVM 中只有一个Class对象，从而避免类加载冲突和不一致的问题。</p>
<h2 id="类缓存的实现"><a href="#类缓存的实现" class="headerlink" title="类缓存的实现"></a>类缓存的实现</h2><p>在 JVM 的实现中，类缓存通常由ClassLoader类的内部数据结构实现。例如，在 Oracle 的 HotSpot JVM 中，类缓存通常是一个HashMap，其中键是类的全限定名，值是类的Class对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderCacheDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        // 获取系统类加载器</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        // 加载类</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader.loadClass(&quot;java.lang.String&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader.loadClass(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">        // 比较两个类对象是否相同</span><br><span class="line">        System.out.println(clazz1 == clazz2); // 输出 true，说明类对象被缓存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用系统类加载器加载了两次java.lang.String类，并比较了两个Class对象。由于类加载器缓存的存在，两个Class对象实际上是相同的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E6%88%90%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E6%88%90%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F/" itemprop="url">👌为什么将永久代替换成元空间？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌为什么将永久代替换成元空间？"><a href="#👌为什么将永久代替换成元空间？" class="headerlink" title="👌为什么将永久代替换成元空间？"></a>👌为什么将永久代替换成元空间？</h1><p><strong>解决固定大小的限制</strong>：元空间可以动态扩展，减少内存不足的风险。</p>
<p><strong>改进内存管理</strong>：元空间的垃圾收集更为高效，减少了内存碎片和停顿时间。</p>
<p><strong>减少配置复杂性</strong>：默认动态扩展特性减少了对内存参数的调整需求。</p>
<p><strong>改进类卸载机制</strong>：提高了类卸载的效率，减少内存泄漏风险。</p>
<p><strong>提升兼容性和扩展性</strong>：更符合现代应用程序需求，支持未来 JVM 特性和优化。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>将永久代（PermGen）替换为元空间（Metaspace）是为了解决永久代在内存管理和性能方面的一些固有问题。</p>
<h2 id="固定大小的限制"><a href="#固定大小的限制" class="headerlink" title="固定大小的限制"></a>固定大小的限制</h2><p>永久代的大小是固定的，必须在 JVM 启动时通过参数（如-XX:PermSize和-XX:MaxPermSize）进行配置。固定大小导致了内存管理的刚性，应用程序在运行过程中如果需要加载大量类（例如使用大量反射或动态生成类），可能会导致永久代空间不足，从而抛出OutOfMemoryError: PermGen space异常。</p>
<hr>
<p>元空间使用本地内存（Native Memory），默认情况下可以根据需要动态扩展。动态扩展减少了内存不足的风险，提高了应用程序的稳定性和灵活性。</p>
<h2 id="更好的内存管理"><a href="#更好的内存管理" class="headerlink" title="更好的内存管理"></a>更好的内存管理</h2><p>永久代的垃圾收集与堆内存的垃圾收集有所不同，通常频率较低，且在垃圾收集时可能会导致较长的停顿时间。由于永久代的固定大小，垃圾收集器在回收永久代时需要考虑更多的复杂性，特别是在内存紧张的情况下。</p>
<hr>
<p>元空间的设计使得其垃圾收集更为高效，减少了内存碎片和停顿时间。元空间使用本地内存，减少了 JVM 堆内存的压力，使得堆内存的管理更加简单和高效。</p>
<h2 id="减少配置复杂性"><a href="#减少配置复杂性" class="headerlink" title="减少配置复杂性"></a>减少配置复杂性</h2><p>永久代需要在部署应用程序时仔细调整永久代的大小参数，以避免内存溢出，这增加了配置的复杂性和维护成本。</p>
<hr>
<p>元空间的默认动态扩展特性减少了开发者对内存参数的调整需求。即使需要限制元空间的大小，也可以通过-XX:MaxMetaspaceSize参数进行简单配置。</p>
<h3 id="兼容和扩展"><a href="#兼容和扩展" class="headerlink" title="兼容和扩展"></a>兼容和扩展</h3><p>永久代固定大小的永久代在面对不断变化的应用程序需求和新特性时，显得不够灵活。</p>
<p>元空间的设计更符合现代应用程序的需求，特别是在云计算和大规模分布式系统中。动态扩展和使用本地内存的特性使得元空间更具扩展性和兼容性，能够更好地支持未来的 JVM 特性和优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_/" itemprop="url">👌什么是java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是java内存模型"><a href="#👌什么是java内存模型" class="headerlink" title="👌什么是java内存模型?"></a>👌什么是java内存模型?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 内存模型（Java Memory Model, JMM）是 Java 虚拟机规范的一部分，定义了多线程环境下共享变量的访问规则以及不同线程之间如何通过内存进行交互。JMM 主要解决在多线程编程中可能出现的可见性、原子性和有序性问题。</p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p><strong>线程与主内存</strong>：</p>
<p>每个线程都有自己的工作内存（也称为本地内存），工作内存保存了该线程使用到的变量的副本。主内存是共享内存区域，所有线程都可以访问主内存中的变量。</p>
<p><strong>可见性</strong>：</p>
<p>可见性问题是指一个线程对共享变量的修改，另一个线程是否能够立即看到。JMM 通过volatile关键字、锁机制（如synchronized）等来保证变量的可见性。</p>
<p><strong>原子性</strong>：</p>
<p>原子性问题是指一个操作是否是不可分割的，即操作要么全部执行完成，要么完全不执行。JMM 保证了基本数据类型的读写操作的原子性，但对于复合操作（如 i++）则不保证。</p>
<p><strong>有序性</strong>：</p>
<p>有序性问题是指代码执行的顺序是否与程序的顺序一致。编译器和处理器可能会对指令进行重排序，以提高性能。JMM 通过volatile关键字、锁机制等来保证必要的有序性。</p>
<h2 id="内存模型中的同步机制"><a href="#内存模型中的同步机制" class="headerlink" title="内存模型中的同步机制"></a>内存模型中的同步机制</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile变量保证了对该变量的读写操作的可见性和有序性。</p>
<p>读volatile变量时，总是从主内存中读取最新的值。</p>
<p>写volatile变量时，总是将最新的值写回主内存。</p>
<h3 id="synchronized关键字："><a href="#synchronized关键字：" class="headerlink" title="synchronized关键字："></a>synchronized关键字：</h3><p>synchronized块或方法保证了进入临界区的线程对共享变量的独占访问。</p>
<p>退出synchronized块时，会将工作内存中的变量更新到主内存。</p>
<p>进入synchronized块时，会从主内存中读取最新的变量值。</p>
<h3 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h3><p>final变量在构造器中初始化后，其他线程可以立即看到初始化后的值。</p>
<p>final变量的引用不会被修改，因此可以确保其可见性。</p>
<h2 id="可见性问题示例"><a href="#可见性问题示例" class="headerlink" title="可见性问题示例"></a>可见性问题示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class VisibilityExample &#123;</span><br><span class="line">    private static boolean stop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (!stop) &#123;</span><br><span class="line">                // busy-wait</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true; // 另一个线程可能不会立即看到这个修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程修改了stop变量，但另一个线程可能不会立即看到修改，导致循环无法终止。可以使用volatile关键字解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class VisibilityExample &#123;</span><br><span class="line">    private static volatile boolean stop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (!stop) &#123;</span><br><span class="line">                // busy-wait</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true; // 另一个线程会立即看到这个修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA_/" itemprop="url">👌什么情况会发生栈溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么情况会发生栈溢出"><a href="#👌什么情况会发生栈溢出" class="headerlink" title="👌什么情况会发生栈溢出?"></a>👌什么情况会发生栈溢出?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>栈溢出（Stack Overflow）是指程序在运行过程中，由于调用栈（stack）空间被耗尽而导致的错误。调用栈是用来存储方法调用信息（如局部变量、方法参数和返回地址等）的内存区域。</p>
<h2 id="递归调用过深"><a href="#递归调用过深" class="headerlink" title="递归调用过深"></a>递归调用过深</h2><p>最常见的栈溢出情况是递归调用过深。递归函数在每次调用时都会在栈上分配新的栈帧，如果递归深度过大，栈空间很快就会耗尽。recursiveMethod方法无限递归调用自己，导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无终止条件的递归"><a href="#无终止条件的递归" class="headerlink" title="无终止条件的递归"></a>无终止条件的递归</h2><p>递归函数如果没有正确的终止条件，也会导致栈溢出。recursiveMethod方法的递归调用没有正确的终止条件，导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod(int num) &#123;</span><br><span class="line">        if (num == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        recursiveMethod(num); // 无终止条件的递归</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历深度过大的数据结构"><a href="#遍历深度过大的数据结构" class="headerlink" title="遍历深度过大的数据结构"></a>遍历深度过大的数据结构</h2><p>遍历深度过大的数据结构（如深度优先搜索一个非常深的树或图）也可能导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int value;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void traverse(TreeNode node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(node.left);</span><br><span class="line">        traverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        TreeNode current = root;</span><br><span class="line">        for (int i = 2; i &lt; 100000; i++) &#123;</span><br><span class="line">            current.left = new TreeNode(i);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈空间设置过小"><a href="#栈空间设置过小" class="headerlink" title="栈空间设置过小"></a>栈空间设置过小</h2><p>程序运行时，栈空间的大小是有限的。如果栈空间设置过小，也会更容易发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss128k</span><br></pre></td></tr></table></figure>

<p>通过-Xss参数设置 JVM 栈空间大小为 128KB，可能导致栈溢出。</p>
<h2 id="防止栈溢出的方法"><a href="#防止栈溢出的方法" class="headerlink" title="防止栈溢出的方法"></a>防止栈溢出的方法</h2><p><strong>优化递归</strong>：</p>
<p>确保递归函数有正确的终止条件。</p>
<p>使用尾递归优化（如果编译器或运行时支持）。</p>
<p>将递归转换为迭代。</p>
<p><strong>增加栈空间</strong>：</p>
<p>通过 JVM 参数-Xss增加栈空间大小。</p>
<p><strong>使用非递归算法</strong>：</p>
<p>对于深度优先搜索等场景，使用显式栈（如Stack类）代替递归调用。</p>
<p><strong>检查数据结构</strong>：</p>
<p>确保遍历的数据结构不会过深或过大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJVM%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJVM%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F/" itemprop="url">👌什么是JVM方法区？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是JVM方法区？"><a href="#👌什么是JVM方法区？" class="headerlink" title="👌什么是JVM方法区？"></a>👌什么是JVM方法区？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 方法区是 JVM 运行时数据区的一部分，用于存储与类和方法相关的元数据。它是所有线程共享的内存区域，包含了 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区的内容在 JVM 启动时创建，并在 JVM 运行期间动态扩展或收缩。</p>
<h2 id="方法区的主要内容"><a href="#方法区的主要内容" class="headerlink" title="方法区的主要内容"></a>方法区的主要内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+</span><br><span class="line">|         方法区 (Method Area)         |</span><br><span class="line">|  - 类信息                                    |</span><br><span class="line">|  - 运行时常量池                         |</span><br><span class="line">|  - 静态变量                                |</span><br><span class="line">|  - 即时编译器编译后的代码         |</span><br><span class="line">|  - 字段和方法信息                     |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>类信息</strong>：包括类名、父类名、访问修饰符、接口列表等的元数据。</li>
<li><strong>运行时常量池</strong>：存储编译期生成的各种字面量和符号引用，这些引用在类加载后被解析为直接引用。</li>
<li><strong>静态变量</strong>：类的静态字段，存储类级别的变量。</li>
<li><strong>即时编译器编译后的代码</strong>：即时编译器（JIT）将热点代码编译为本地机器码，存储在方法区中。</li>
<li><strong>字段和方法信息</strong>：包括字段描述、方法描述、方法字节码、方法的访问修饰符等。</li>
</ol>
<h2 id="方法区在不同-JVM-实现中的差异"><a href="#方法区在不同-JVM-实现中的差异" class="headerlink" title="方法区在不同 JVM 实现中的差异"></a>方法区在不同 JVM 实现中的差异</h2><p><strong>HotSpot JVM（Java 7 及之前）</strong>：方法区实现为永久代（Permanent Generation，PermGen）。永久代的内存空间固定，容易导致内存溢出（OutOfMemoryError）。</p>
<p><strong>HotSpot JVM（Java 8 及之后）</strong>：方法区实现为元空间（Metaspace）。元空间使用本地内存（Native Memory），默认情况下可以根据需要动态扩展，减少了内存溢出的风险。</p>
<h2 id="方法区的内存管理"><a href="#方法区的内存管理" class="headerlink" title="方法区的内存管理"></a>方法区的内存管理</h2><p>方法区的内存管理主要包括以下几个方面：</p>
<ol>
<li><strong>类加载</strong>：当一个类被加载时，其相关信息会被存储在方法区中。</li>
<li><strong>类卸载</strong>：当一个类不再被使用且没有任何引用时，垃圾收集器可以回收方法区中的类元数据。</li>
<li><strong>垃圾收集</strong>：方法区的垃圾收集主要针对废弃的类元数据和常量池中的无用常量。相比堆内存的垃圾收集，方法区的垃圾收集频率较低。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url">👌软引用和虚引用适用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌软引用和虚引用适用场景"><a href="#👌软引用和虚引用适用场景" class="headerlink" title="👌软引用和虚引用适用场景"></a>👌软引用和虚引用适用场景</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用主要用于实现内存敏感的缓存。</p>
<p>软引用可以用于缓存那些可以在内存不足时安全回收的对象。例如，图片缓存、数据缓存等场景。在内存充足时，缓存的对象不会被回收；当内存不足时，缓存的对象会被回收以释放内存。这种机制可以在不影响应用程序功能的前提下，最大限度地利用可用内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SoftReferenceCache&lt;K, V&gt; &#123;</span><br><span class="line">    private final Map&lt;K, SoftReference&lt;V&gt;&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void put(K key, V value) &#123;</span><br><span class="line">        cache.put(key, new SoftReference&lt;&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V get(K key) &#123;</span><br><span class="line">        SoftReference&lt;V&gt; ref = cache.get(key);</span><br><span class="line">        if (ref != null) &#123;</span><br><span class="line">            return ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SoftReferenceCache使用软引用来缓存对象，当内存不足时，缓存的对象可能会被回收。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用主要用于跟踪对象被垃圾收集器回收的时间，通常用于实现特殊的清理机制。</p>
<p>虚引用可以用于管理那些需要在对象被回收后进行清理的资源，例如直接内存（Direct Memory）、文件句柄等。</p>
<p>当对象被垃圾收集器回收时，虚引用会被放入引用队列（ReferenceQueue），通过处理这个队列，可以执行必要的清理操作。</p>
<p>虚引用可以用于监控对象何时被回收，从而在对象回收时执行一些特定的操作，例如记录日志、更新状态等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.PhantomReference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line">public class PhantomReferenceExample &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ReferenceQueue&lt;Object&gt; refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        Object obj = new Object();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = new PhantomReference&lt;&gt;(obj, refQueue);</span><br><span class="line"></span><br><span class="line">        obj = null; // 允许 obj 对象被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">        // 强制垃圾收集</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 检查引用队列</span><br><span class="line">        if (refQueue.poll() != null) &#123;</span><br><span class="line">            System.out.println(&quot;Object has been collected&quot;);</span><br><span class="line">            // 执行清理操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当obj被垃圾收集器回收时，phantomRef会被放入refQueue中，可以通过检查refQueue来执行清理操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/Gcroot%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/Gcroot%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌Gc root对象都包含哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Gc-root对象都包含哪些？"><a href="#👌Gc-root对象都包含哪些？" class="headerlink" title="👌Gc root对象都包含哪些？"></a>👌Gc root对象都包含哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root"></a>什么是GC Root</h2><p>GC Root是垃圾回收器确定对象是否可达的起始点。在Java中，GC Root是一组特殊的对象，GC Root对象保证了这些对象及其引用链不会被垃圾回收器回收，因为它们是程序的起始点，其他对象通过它们间接可达，它确保了内存中的对象能够正确地被管理和清理，避免内存泄漏和无效引用的问题。</p>
<h2 id="gcroot-对象"><a href="#gcroot-对象" class="headerlink" title="gcroot 对象"></a>gcroot 对象</h2><p><strong>虚拟机栈（栈帧中的本地变量表）中的引用</strong>：</p>
<p>每个线程都有一个虚拟机栈，栈帧中的本地变量表（Local Variable Table）包含了方法执行过程中用到的所有局部变量。这些局部变量可能包含对对象的引用。</p>
<p><strong>方法区中的类静态变量引用</strong>：</p>
<p>方法区中存储了类的元数据，包括类的静态变量。这些静态变量可能引用对象。</p>
<p><strong>方法区中的常量引用</strong>：</p>
<p>方法区还包含运行时常量池（Runtime Constant Pool），其中可能有对对象的引用。</p>
<p><strong>本地方法栈中的 JNI（Java Native Interface）引用</strong>：</p>
<p>本地方法栈（Native Method Stack）用于本地方法的调用。本地方法可以通过 JNI 引用 Java 对象，这些引用也是 GC Roots。</p>
<p><strong>活动线程</strong>：</p>
<p>所有正在运行的线程本身也是 GC Roots。</p>
<p><strong>类加载器</strong>：</p>
<p>类加载器本身也是 GC Roots，因为它们负责加载类，而类加载器的引用链可以追溯到所有被加载的类及其静态变量。</p>
<p><strong>系统类</strong>：</p>
<p>一些系统级的类，比如java.lang.Thread，java.lang.System等，也被视为 GC Roots。</p>
<p><strong>JNI 全局引用</strong>：</p>
<p>JNI 中的全局引用（Global References）也是 GC Roots。</p>
<p><strong>JVM 内部的某些数据结构</strong>：</p>
<p>JVM 内部的一些数据结构（如 JIT 编译器生成的代码中的引用）也可能被视为 GC Roots。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/" itemprop="url">👌一次完整的垃圾回收过程是什么样的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌一次完整的垃圾回收过程是什么样的？"><a href="#👌一次完整的垃圾回收过程是什么样的？" class="headerlink" title="👌一次完整的垃圾回收过程是什么样的？"></a>👌一次完整的垃圾回收过程是什么样的？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Jvm 垃圾回收的基本过程可以分为以下三个步骤：</p>
<p><img src="/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/x6V_Rb0Mao22_jty/1719147802226-96af4d13-19d6-4cf6-bdc9-c3c028ccd29e-914044.png" alt="1719147802226-96af4d13-19d6-4cf6-bdc9-c3c028ccd29e.png"></p>
<h1 id="垃圾分类"><a href="#垃圾分类" class="headerlink" title="垃圾分类"></a>垃圾分类</h1><p>首先我们的 jvm 在进行垃圾回收的过程，需要确定哪些对象是垃圾对象，哪些对象是存活对象。这个类似于我们在做一件事之前的规划。具体的分类方法一般情况下，垃圾回收器会从堆的根节点（如程序计数器、虚拟机栈、本地方法栈和方法区中的类静态属性等），也就是 gc root。开始遍历对象图，标记所有可以到达的对象为存活对象，未被标记的对象则被认为是垃圾对象。进过标记后，分类成功。</p>
<h1 id="垃圾查找"><a href="#垃圾查找" class="headerlink" title="垃圾查找"></a>垃圾查找</h1><p>分类后，已经知道了对象所处的一个状态，jvm 会根据分类后对象，先找出所有垃圾对象，以便进行清理。</p>
<p>不同的垃圾收集，其中的查找方式会产生相应的差异。随着现在 jdk 的 升级与发展，还会产生更加高效的算法，后面会有垃圾收集的算法详细介绍。</p>
<h2 id="垃圾清理"><a href="#垃圾清理" class="headerlink" title="垃圾清理"></a>垃圾清理</h2><p>标记完成后，进行最后的清理与删除。这里涉及不同的垃圾收集器，清理的方式也不同，常见的有</p>
<p>标记-清除算法，复制算法，标记-整理算法，分代算法。</p>
<p>需要注意的是，垃圾清理可能会引起应用程序的暂停，不同的垃圾回收器通过不同的方式来减少这种暂停时间，从而提高应用程序的性能和可靠性。</p>
<p>常见的垃圾收集器有</p>
<p>Serial GC</p>
<p>Parallel GC</p>
<p>CMS GC（Concurrent Mark Sweep）</p>
<p>G1 GC（Garbage First）</p>
<p>ZGC</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">194</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
