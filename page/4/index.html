<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/page/4/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/page/4/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E7%9A%84%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E7%9A%84%E7%B1%BB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F/" itemprop="url">👌JVM的类命名空间如何理解？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM的类命名空间如何理解？"><a href="#👌JVM的类命名空间如何理解？" class="headerlink" title="👌JVM的类命名空间如何理解？"></a>👌JVM的类命名空间如何理解？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的类命名空间是指 JVM 在运行时用来区分和管理不同类加载器加载的类的机制。</p>
<h2 id="类命名空间的基本概念"><a href="#类命名空间的基本概念" class="headerlink" title="类命名空间的基本概念"></a>类命名空间的基本概念</h2><p>在 JVM 中，每个类加载器都有自己的命名空间。一个类的完全限定名（即类的全路径名，例如com.example.MyClass）在 JVM 的命名空间中是唯一的，但同一个完全限定名的类可以由不同的类加载器加载，从而在不同的命名空间中存在多个版本。</p>
<h2 id="类命名空间的工作原理"><a href="#类命名空间的工作原理" class="headerlink" title="类命名空间的工作原理"></a>类命名空间的工作原理</h2><ol>
<li><strong>双亲委派模型</strong>：类加载器在加载一个类时，首先会将请求委派给父类加载器。如果父类加载器无法找到该类，才会由当前类加载器尝试加载。这种机制确保了核心类库的优先加载和安全性。</li>
<li><strong>类的唯一性</strong>：在 JVM 中，一个类由其完全限定名和加载它的类加载器共同决定。即使两个类的完全限定名相同，但如果它们是由不同的类加载器加载的，那么它们在 JVM 中被认为是不同的类。</li>
</ol>
<h2 id="类命名空间示例"><a href="#类命名空间示例" class="headerlink" title="类命名空间示例"></a>类命名空间示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderNamespaceDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 创建两个自定义类加载器</span><br><span class="line">        ClassLoader classLoader1 = new CustomClassLoader();</span><br><span class="line">        ClassLoader classLoader2 = new CustomClassLoader();</span><br><span class="line"></span><br><span class="line">        // 使用不同的类加载器加载同一个类</span><br><span class="line">        Class&lt;?&gt; class1 = classLoader1.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">        Class&lt;?&gt; class2 = classLoader2.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line"></span><br><span class="line">        // 比较两个类对象是否相同</span><br><span class="line">        System.out.println(class1 == class2); // 输出 false，说明类对象在不同的命名空间中</span><br><span class="line"></span><br><span class="line">        // 实例化对象并调用方法</span><br><span class="line">        Object obj1 = class1.getDeclaredConstructor().newInstance();</span><br><span class="line">        Object obj2 = class2.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        Method method1 = class1.getMethod(&quot;sayHello&quot;);</span><br><span class="line">        Method method2 = class2.getMethod(&quot;sayHello&quot;);</span><br><span class="line"></span><br><span class="line">        method1.invoke(obj1);</span><br><span class="line">        method2.invoke(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义类加载器</span><br><span class="line">class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        if (name.startsWith(&quot;com.example&quot;)) &#123;</span><br><span class="line">            // 自定义加载逻辑，例如从文件系统或网络加载类字节码</span><br><span class="line">            byte[] classData = getClassData(name);</span><br><span class="line">            if (classData != null) &#123;</span><br><span class="line">                return defineClass(name, classData, 0, classData.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassData(String className) &#123;</span><br><span class="line">        // 实现类加载的逻辑，例如从文件系统或网络加载类字节码</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CustomClassLoader是一个自定义类加载器。我们创建了两个CustomClassLoader实例，并分别使用它们加载同一个类com.example.MyClass。由于这两个类加载器是不同的，因此它们各自的命名空间也是不同的，即使类的完全限定名相同，加载后的类对象也是不同的。</p>
<h2 id="类命名空间的应用"><a href="#类命名空间的应用" class="headerlink" title="类命名空间的应用"></a>类命名空间的应用</h2><ol>
<li><strong>模块化</strong>：通过使用不同的类加载器，可以实现模块化的类加载，每个模块有自己的命名空间，互不干扰。</li>
<li><strong>隔离</strong>：在应用服务器（如 Tomcat）中，不同的应用程序使用不同的类加载器，从而实现类的隔离，避免类冲突。</li>
<li><strong>插件系统</strong>：在插件系统中，每个插件可以使用自己的类加载器加载类，确保插件之间的独立性和隔离性。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E7%B1%BB%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%8D%B8%E8%BD%BD%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E7%B1%BB%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%8D%B8%E8%BD%BD%EF%BC%9F/" itemprop="url">👌JVM类何时可以卸载？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM类何时可以卸载？"><a href="#👌JVM类何时可以卸载？" class="headerlink" title="👌JVM类何时可以卸载？"></a>👌JVM类何时可以卸载？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="类加载器被卸载"><a href="#类加载器被卸载" class="headerlink" title="类加载器被卸载"></a>类加载器被卸载</h2><p>类的卸载与类加载器的生命周期密切相关。只有当一个类加载器没有任何活动的引用时，JVM 才会考虑卸载由该加载器加载的所有类。因此，类的卸载通常发生在类加载器被卸载的时候。具体条件包括：</p>
<p><strong>类加载器没有活动的引用</strong>：即没有任何线程或静态变量引用该类加载器。</p>
<p><strong>类加载器加载的所有类都没有活动的引用</strong>：即这些类的实例、静态字段和方法都不再被引用。</p>
<h2 id="没有对类的实例的引用"><a href="#没有对类的实例的引用" class="headerlink" title="没有对类的实例的引用"></a>没有对类的实例的引用</h2><p>为了卸载一个类，JVM 需要确保没有对该类的实例的引用。</p>
<p>没有该类的对象实例在堆中。</p>
<p>没有对该类的静态字段的引用。</p>
<p>没有活动线程在执行该类的方法。</p>
<h2 id="没有对类的静态方法和静态字段的引用"><a href="#没有对类的静态方法和静态字段的引用" class="headerlink" title="没有对类的静态方法和静态字段的引用"></a>没有对类的静态方法和静态字段的引用</h2><p>如果一个类的静态方法或静态字段仍然被引用，那么该类将不会被卸载。因此，JVM 必须确保：没有线程在执行该类的静态方法。没有对该类的静态字段的引用。</p>
<h2 id="没有对类加载器的引用"><a href="#没有对类加载器的引用" class="headerlink" title="没有对类加载器的引用"></a>没有对类加载器的引用</h2><p>类的卸载需要确保类加载器本身也没有被引用。这意味着：</p>
<p>没有其他类加载器或对象引用该类加载器。该类加载器加载的所有类都可以被卸载。</p>
<h2 id="完成垃圾回收"><a href="#完成垃圾回收" class="headerlink" title="完成垃圾回收"></a>完成垃圾回收</h2><p>类的卸载通常发生在垃圾回收过程中。垃圾回收器会检查类加载器及其加载的类是否符合卸载条件。如果符合条件，垃圾回收器会卸载这些类并释放相关内存。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ClassUnloadingExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 创建一个新的类加载器</span><br><span class="line">        CustomClassLoader classLoader = new CustomClassLoader();</span><br><span class="line"></span><br><span class="line">        // 加载一个类</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(&quot;MyClass&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建类的实例</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        // 清除对类加载器和类实例的引用</span><br><span class="line">        classLoader = null;</span><br><span class="line">        instance = null;</span><br><span class="line"></span><br><span class="line">        // 请求垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 让垃圾回收器有时间运行</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Class unloading example completed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">            if (&quot;MyClass&quot;.equals(name)) &#123;</span><br><span class="line">                byte[] classData = getClassData();</span><br><span class="line">                return defineClass(name, classData, 0, classData.length);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private byte[] getClassData() &#123;</span><br><span class="line">            // 模拟加载类数据</span><br><span class="line">            return new byte[]&#123;/* class data */&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个自定义的类加载器CustomClassLoader，并使用它加载一个类MyClass。然后，我们清除对类加载器和类实例的引用，并请求垃圾回收。垃圾回收器在条件满足时会卸载MyClass类。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%90%97_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%90%97_/" itemprop="url">👌Java会存在内存泄露吗</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java会存在内存泄露吗"><a href="#👌Java会存在内存泄露吗" class="headerlink" title="👌Java会存在内存泄露吗?"></a>👌Java会存在内存泄露吗?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>内存泄漏指的是程序在运行过程中由于某种原因未能释放不再使用的内存，导致内存使用量不断增加，最终可能耗尽可用内存。通常是由于程序逻辑错误或不当的资源管理引起的。</p>
<h2 id="常见的内存泄漏情况"><a href="#常见的内存泄漏情况" class="headerlink" title="常见的内存泄漏情况"></a>常见的内存泄漏情况</h2><h3 id="静态集合类（如HashMap、ArrayList）持有对象引用"><a href="#静态集合类（如HashMap、ArrayList）持有对象引用" class="headerlink" title="静态集合类（如HashMap、ArrayList）持有对象引用"></a>静态集合类（如HashMap、ArrayList）持有对象引用</h3><p>静态集合类会在整个应用程序生命周期内存在，如果没有及时清理不再使用的对象引用，这些对象就无法被垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryLeakExample &#123;</span><br><span class="line">    private static List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addToList(Object obj) &#123;</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听器和回调函数"><a href="#监听器和回调函数" class="headerlink" title="监听器和回调函数"></a>监听器和回调函数</h3><p>如果注册的监听器或回调函数没有及时解除注册，它们持有的对象引用也会导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class EventSource &#123;</span><br><span class="line">    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void registerListener(EventListener listener) &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未关闭的资源"><a href="#未关闭的资源" class="headerlink" title="未关闭的资源"></a>未关闭的资源</h3><p>打开的文件、数据库连接、网络连接等资源如果没有及时关闭，会导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void readFile(String filePath) throws IOException &#123;</span><br><span class="line">    BufferedReader reader = new BufferedReader(new FileReader(filePath));</span><br><span class="line">    // 忘记关闭 reader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类和匿名类持有外部类引用："><a href="#内部类和匿名类持有外部类引用：" class="headerlink" title="内部类和匿名类持有外部类引用："></a>内部类和匿名类持有外部类引用：</h3><p>内部类和匿名类会持有外部类的引用，如果这些类的实例生命周期较长，会导致外部类无法被垃圾回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">    private String data;</span><br><span class="line"></span><br><span class="line">    public void startThread() &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存（Cache）没有清理："><a href="#缓存（Cache）没有清理：" class="headerlink" title="缓存（Cache）没有清理："></a>缓存（Cache）没有清理：</h3><p>使用缓存时，如果没有适当的清理策略（如 LRU 缓存），缓存中的对象会一直存在，导致内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CacheExample &#123;</span><br><span class="line">    private Map&lt;String, Object&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addToCache(String key, Object value) &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测和解决内存泄漏的方法"><a href="#检测和解决内存泄漏的方法" class="headerlink" title="检测和解决内存泄漏的方法"></a>检测和解决内存泄漏的方法</h2><h3 id="使用内存分析工具："><a href="#使用内存分析工具：" class="headerlink" title="使用内存分析工具："></a>使用内存分析工具：</h3><p>工具如 VisualVM、Eclipse MAT（Memory Analyzer Tool）可以帮助分析堆内存，找出可能的内存泄漏点。</p>
<h3 id="代码审查："><a href="#代码审查：" class="headerlink" title="代码审查："></a>代码审查：</h3><p>仔细审查代码，确保没有不必要的对象引用，及时释放资源。</p>
<h3 id="使用try-with-resources语句"><a href="#使用try-with-resources语句" class="headerlink" title="使用try-with-resources语句"></a>使用try-with-resources语句</h3><p>确保资源在使用完毕后被及时关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void readFile(String filePath) throws IOException &#123;</span><br><span class="line">    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class="line">        // 读取文件内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解除监听器注册"><a href="#解除监听器注册" class="headerlink" title="解除监听器注册"></a>解除监听器注册</h3><p>确保在不再需要监听器时解除注册。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class EventSource &#123;</span><br><span class="line">    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void registerListener(EventListener listener) &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unregisterListener(EventListener listener) &#123;</span><br><span class="line">        listeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B%EF%BC%9F/" itemprop="url">👌Java创建对象的主要流程？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java创建对象的主要流程？"><a href="#👌Java创建对象的主要流程？" class="headerlink" title="👌Java创建对象的主要流程？"></a>👌Java创建对象的主要流程？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h2><p>当使用new关键字创建对象时，JVM 首先检查类是否已经被加载、链接和初始化。如果类还没有被加载，JVM 会先执行类加载过程。类加载过程包括以下步骤：</p>
<p><strong>加载（Loading）</strong>：从文件系统或网络中读取类的二进制数据，并创建一个Class对象。</p>
<p><strong>链接（Linking）</strong>：包括验证（Verify）、准备（Prepare）和解析（Resolve）三个阶段。</p>
<ul>
<li><strong>验证</strong>：确保类的字节码符合 JVM 规范，没有安全问题。</li>
<li><strong>准备</strong>：为类的静态变量分配内存，并将其初始化为默认值。</li>
<li><strong>解析</strong>：将类的符号引用转换为直接引用。</li>
</ul>
<p><strong>初始化（Initialization）</strong>：执行类的静态初始化块和静态变量的初始化。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>一旦类被加载并初始化，JVM 会在堆中为新对象分配内存。内存分配的具体方式取决于 JVM 的实现，一般有以下几种方式：</p>
<p><strong>指针碰撞（Bump-the-pointer）</strong>：如果堆内存是规整的，所有已使用的内存都在一边，空闲内存都在另一边，中间有一个指针作为分界线。分配内存时，只需将指针向空闲内存方向移动一段与对象大小相等的距离。</p>
<p><strong>空闲列表（Free-list）</strong>：如果堆内存不规整，JVM 会维护一个空闲列表，记录哪些内存块是可用的。分配内存时，从空闲列表中找到一个足够大的内存块进行分配。</p>
<h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h2><p>在内存分配完成后，JVM 会将分配的内存空间初始化为零值。这一步确保了对象的实例变量在 Java 语言层面上有默认值（如0、false或null）。</p>
<h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>JVM 会在对象的内存区域中设置对象头（Object Header），对象头包含以下信息：</p>
<p><strong>Mark Word</strong>：存储对象的运行时数据，如哈希码、GC 分代年龄、锁状态等。</p>
<p><strong>Class Pointer</strong>：指向对象的类元数据，JVM 通过它来确定对象是哪个类的实例。</p>
<h2 id="执行构造器"><a href="#执行构造器" class="headerlink" title="执行构造器"></a>执行构造器</h2><p>最后，JVM 调用对象的构造器（Constructor）进行初始化。构造器初始化包括：</p>
<p><strong>执行父类构造器</strong>：如果类有父类，首先会调用父类的构造器。</p>
<p><strong>初始化实例变量</strong>：按照代码中定义的顺序初始化实例变量。</p>
<p><strong>执行构造器代码</strong>：执行构造器中的代码。</p>
<h2 id="返回对象引用"><a href="#返回对象引用" class="headerlink" title="返回对象引用"></a>返回对象引用</h2><p>构造器执行完毕后，JVM 返回新创建对象的引用。此时，对象已经完全初始化，可以被程序使用。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>展示对象创建的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    // 静态初始化块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Class MyClass is being initialized.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实例初始化块</span><br><span class="line">    &#123;</span><br><span class="line">        value = 10;</span><br><span class="line">        System.out.println(&quot;Instance initialization block.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构造器</span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        System.out.println(&quot;Constructor is called.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass obj = new MyClass();</span><br><span class="line">        System.out.println(&quot;Object created with value: &quot; + obj.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class MyClass is being initialized.</span><br><span class="line">Instance initialization block.</span><br><span class="line">Constructor is called.</span><br><span class="line">Object created with value: 10</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F/" itemprop="url">👌Java创建对象的几种方式？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java创建对象的几种方式？"><a href="#👌Java创建对象的几种方式？" class="headerlink" title="👌Java创建对象的几种方式？"></a>👌Java创建对象的几种方式？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用new关键字</h2><p>这是最常见和直接的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>

<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>通过Class类的newInstance()方法（已过时）或Constructor类的newInstance()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Class.newInstance() 方法（已过时）</span><br><span class="line">MyClass obj1 = MyClass.class.newInstance();</span><br><span class="line"></span><br><span class="line">// 使用 Constructor.newInstance() 方法</span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line">MyClass obj2 = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="使用clone-方法"><a href="#使用clone-方法" class="headerlink" title="使用clone()方法"></a>使用clone()方法</h2><p>通过实现Cloneable接口并重写clone()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass implements Cloneable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj1 = new MyClass();</span><br><span class="line">MyClass obj2 = (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>

<h2 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h2><p>通过ObjectInputStream进行反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 序列化对象</span><br><span class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">// 反序列化对象</span><br><span class="line">ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));</span><br><span class="line">MyClass obj = (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h2 id="使用工厂方法"><a href="#使用工厂方法" class="headerlink" title="使用工厂方法"></a>使用工厂方法</h2><p>通过工厂方法模式创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassFactory &#123;</span><br><span class="line">    public static MyClass createInstance() &#123;</span><br><span class="line">        return new MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = MyClassFactory.createInstance();</span><br></pre></td></tr></table></figure>

<h2 id="使用-Builder-模式"><a href="#使用-Builder-模式" class="headerlink" title="使用 Builder 模式"></a>使用 Builder 模式</h2><p>通过构建器模式创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private String field1;</span><br><span class="line">    private int field2;</span><br><span class="line"></span><br><span class="line">    private MyClass(Builder builder) &#123;</span><br><span class="line">        this.field1 = builder.field1;</span><br><span class="line">        this.field2 = builder.field2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String field1;</span><br><span class="line">        private int field2;</span><br><span class="line"></span><br><span class="line">        public Builder setField1(String field1) &#123;</span><br><span class="line">            this.field1 = field1;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setField2(int field2) &#123;</span><br><span class="line">            this.field2 = field2;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public MyClass build() &#123;</span><br><span class="line">            return new MyClass(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = new MyClass.Builder().setField1(&quot;value1&quot;).setField2(42).build();</span><br></pre></td></tr></table></figure>

<h2 id="通过Unsafe类"><a href="#通过Unsafe类" class="headerlink" title="通过Unsafe类"></a>通过Unsafe类</h2><p>使用sun.misc.Unsafe类（不建议在生产代码中使用，因为它依赖于内部 API，且不安全）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class UnsafeExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line"></span><br><span class="line">        MyClass obj = (MyClass) unsafe.allocateInstance(MyClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>new关键字</strong>：最常用，适用于大多数情况。</p>
<p><strong>反射</strong>：灵活但性能较差，适用于框架或工具类开发。</p>
<p><strong>clone()方法</strong>：适用于需要精确复制对象的情况。</p>
<p><strong>反序列化</strong>：适用于需要从持久化存储中恢复对象的情况。</p>
<p><strong>工厂方法和 Builder 模式</strong>：适用于需要复杂对象创建逻辑的情况。</p>
<p><strong>Unsafe类</strong>：不建议使用，除非在非常特殊的低级别操作中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E6%98%AF%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E6%98%AF%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80/" itemprop="url">👌Java是解释语言还是编译语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java是解释语言还是编译语言"><a href="#👌Java是解释语言还是编译语言" class="headerlink" title="👌Java是解释语言还是编译语言"></a>👌Java是解释语言还是编译语言</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 是一种既具有编译特性又具有解释特性的语言。它独特的运行机制使得它既不同于传统的编译语言（如 C 或 C++），也不同于传统的解释语言（如 Python 或 JavaScript）。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><strong>源代码编译</strong>：</p>
<p>Java 源代码文件（.java 文件）首先通过 Java 编译器（javac）编译成字节码文件（.class 文件）。这个编译过程将高层次的 Java 代码转换成一种中间表示形式，即字节码。这些字节码是平台无关的，可以在任何支持 Java 虚拟机（JVM）的系统上运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MyClass.java</span><br></pre></td></tr></table></figure>

<p><strong>字节码</strong>：字节码是一种中间语言，它并不是直接可执行的机器码，而是需要进一步解释或编译成机器码才能运行。</p>
<p>字节码的设计使得 Java 程序可以在不同的平台上运行，而无需重新编译源代码。</p>
<h2 id="解释阶段"><a href="#解释阶段" class="headerlink" title="解释阶段"></a>解释阶段</h2><p>当运行一个 Java 程序时，Java 虚拟机（JVM）会加载字节码并解释执行。JVM 内部包含一个解释器，它将字节码逐行解释成机器指令，然后执行这些指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyClass</span><br></pre></td></tr></table></figure>

<h2 id="Just-In-Time-JIT-编译"><a href="#Just-In-Time-JIT-编译" class="headerlink" title="Just-In-Time (JIT) 编译"></a>Just-In-Time (JIT) 编译</h2><p>为了提高性能，现代 JVM 实现通常包含一个 Just-In-Time (JIT) 编译器。JIT 编译器在程序运行时，将热点代码（即频繁执行的代码）动态编译成本地机器码，从而提高执行效率。这种动态编译使得 Java 结合了解释语言的灵活性和编译语言的高性能。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Java 既是一种编译语言，也是一种解释语言。它通过先编译成字节码，然后由 JVM 解释执行，并结合 JIT 编译优化性能。这种独特的机制使得 Java 具有跨平台性和高效性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B_/" itemprop="url">👌一次完整的垃圾回收过程是什么样的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java的类加载器有哪些"><a href="#👌Java的类加载器有哪些" class="headerlink" title="👌Java的类加载器有哪些?"></a>👌Java的类加载器有哪些?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，类加载器（ClassLoader）是负责将类文件加载到 JVM 中的组件。Java 提供了几种标准的类加载器，每种类加载器都有特定的职责和加载范围。</p>
<h2 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h2><p><strong>职责</strong>：加载 Java 核心类库，如java.lang.*、java.util.*等。</p>
<p><strong>实现</strong>：由本地代码（通常是 C++）实现，不是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或jrt:&#x2F;modules（在模块化系统中）。</p>
<p><strong>特点</strong>：是所有类加载器的顶层，没有父类加载器。</p>
<h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><p><strong>职责</strong>：加载扩展库中的类。</p>
<p><strong>实现</strong>：由sun.misc.Launcher$ExtClassLoader实现，是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录或由java.ext.dirs系统属性指定的目录。</p>
<p><strong>父类加载器</strong>：引导类加载器。</p>
<h2 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h2><p><strong>职责</strong>：加载应用程序类路径（classpath）中的类。</p>
<p><strong>实现</strong>：由sun.misc.Launcher$AppClassLoader实现，是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：由java.class.path系统属性指定的目录和 JAR 文件。</p>
<p><strong>父类加载器</strong>：扩展类加载器。</p>
<h2 id="自定义类加载器（Custom-ClassLoader）"><a href="#自定义类加载器（Custom-ClassLoader）" class="headerlink" title="自定义类加载器（Custom ClassLoader）"></a>自定义类加载器（Custom ClassLoader）</h2><p><strong>职责</strong>：满足特定需求的类加载器，通常在应用程序中自定义实现。</p>
<p><strong>实现</strong>：继承java.lang.ClassLoader并重写findClass方法。</p>
<p><strong>加载路径</strong>：由开发者自行定义，可以是文件系统、网络、数据库等。</p>
<p><strong>父类加载器</strong>：可以指定，也可以继承应用程序类加载器。</p>
<p>以下是一个简单的自定义类加载器示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/aldxe3g9bqszh1eh">https://www.yuque.com/jingdianjichi/xyxdsi/aldxe3g9bqszh1eh</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/java%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/java%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F_/" itemprop="url">👌java 加载 class 文件的几种方式?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌java-加载-class-文件的几种方式"><a href="#👌java-加载-class-文件的几种方式" class="headerlink" title="👌java 加载 class 文件的几种方式?"></a>👌java 加载 class 文件的几种方式?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="使用系统类加载器"><a href="#使用系统类加载器" class="headerlink" title="使用系统类加载器"></a>使用系统类加载器</h2><p>Java的系统类加载器（ClassLoader.getSystemClassLoader()）是默认的类加载器，可以用来加载类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = ClassLoader.getSystemClassLoader().loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义类加载器"><a href="#使用自定义类加载器" class="headerlink" title="使用自定义类加载器"></a>使用自定义类加载器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    byte[] classData = loadClassData(name);</span><br><span class="line">    if (classData == null) &#123;</span><br><span class="line">      throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line">    return defineClass(name, classData, 0, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private byte[] loadClassData(String name) &#123;</span><br><span class="line">    // 实现加载类数据的逻辑</span><br><span class="line">    return null; // 示例中返回null，实际应返回类的字节码数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      CustomClassLoader customClassLoader = new CustomClassLoader();</span><br><span class="line">      Class&lt;?&gt; clazz = customClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">      System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用URLClassLoader"><a href="#使用URLClassLoader" class="headerlink" title="使用URLClassLoader"></a>使用URLClassLoader</h2><p>URLClassLoader可以从指定的URL加载类，适用于从JAR文件或远程位置加载类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class URLClassLoaderExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      URL[] urls = &#123;new URL(&quot;file:///path/to/your/classes/&quot;)&#125;;</span><br><span class="line">      URLClassLoader urlClassLoader = new URLClassLoader(urls);</span><br><span class="line">      Class&lt;?&gt; clazz = urlClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">      System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>使用反射机制的Class.forName()方法加载类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Thread-currentThread-getContextClassLoader"><a href="#使用Thread-currentThread-getContextClassLoader" class="headerlink" title="使用Thread.currentThread().getContextClassLoader()"></a>使用Thread.currentThread().getContextClassLoader()</h2><p>获取当前线程的上下文类加载器来加载类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    Class&lt;?&gt; clazz = contextClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><font style="color:#2f5496;"></font></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/jvm%E7%9A%84%E7%B1%BB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/jvm%E7%9A%84%E7%B1%BB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88/" itemprop="url">👌jvm 的类缓存机制是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-的类缓存机制是什么"><a href="#👌jvm-的类缓存机制是什么" class="headerlink" title="👌jvm 的类缓存机制是什么"></a>👌jvm 的类缓存机制是什么</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的类缓存机制是指 JVM 在加载类时，将类的字节码和相关信息（如方法、字段、常量池等）存储在内存中的一种机制。这样做的目的是为了提高类加载的效率，避免重复加载相同的类。</p>
<h2 id="类缓存机制的工作原理"><a href="#类缓存机制的工作原理" class="headerlink" title="类缓存机制的工作原理"></a>类缓存机制的工作原理</h2><ol>
<li><strong>类加载器缓存</strong>：每个类加载器都有一个自己的缓存，用于存储已经加载的类。当需要加载一个类时，类加载器首先会检查其缓存中是否已经有该类的Class对象。如果有，则直接返回该对象；如果没有，则加载该类并将其缓存起来。</li>
<li><strong>双亲委派机制</strong>：在加载类时，类加载器会首先委派给其父类加载器进行加载。如果父类加载器无法加载该类，则由当前类加载器尝试加载。这种机制也有助于类缓存，因为父类加载器的缓存中可能已经有了该类。</li>
<li><strong>常量池缓存</strong>：JVM 会将类的常量池（constant pool）中的符号引用解析为直接引用，并将这些引用缓存起来，以便后续使用时可以快速访问。</li>
</ol>
<h2 id="类缓存的好处"><a href="#类缓存的好处" class="headerlink" title="类缓存的好处"></a>类缓存的好处</h2><p><strong>提高性能</strong>：通过缓存已经加载的类，可以避免重复加载相同的类，从而提高类加载的效率。</p>
<p><strong>减少内存消耗</strong>：缓存机制可以减少类加载过程中重复分配和初始化内存的开销。</p>
<p><strong>保证类的一致性</strong>：通过缓存机制，可以确保同一个类在 JVM 中只有一个Class对象，从而避免类加载冲突和不一致的问题。</p>
<h2 id="类缓存的实现"><a href="#类缓存的实现" class="headerlink" title="类缓存的实现"></a>类缓存的实现</h2><p>在 JVM 的实现中，类缓存通常由ClassLoader类的内部数据结构实现。例如，在 Oracle 的 HotSpot JVM 中，类缓存通常是一个HashMap，其中键是类的全限定名，值是类的Class对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderCacheDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        // 获取系统类加载器</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        // 加载类</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader.loadClass(&quot;java.lang.String&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader.loadClass(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">        // 比较两个类对象是否相同</span><br><span class="line">        System.out.println(clazz1 == clazz2); // 输出 true，说明类对象被缓存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用系统类加载器加载了两次java.lang.String类，并比较了两个Class对象。由于类加载器缓存的存在，两个Class对象实际上是相同的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E6%88%90%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E6%88%90%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F/" itemprop="url">👌为什么将永久代替换成元空间？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌为什么将永久代替换成元空间？"><a href="#👌为什么将永久代替换成元空间？" class="headerlink" title="👌为什么将永久代替换成元空间？"></a>👌为什么将永久代替换成元空间？</h1><p><strong>解决固定大小的限制</strong>：元空间可以动态扩展，减少内存不足的风险。</p>
<p><strong>改进内存管理</strong>：元空间的垃圾收集更为高效，减少了内存碎片和停顿时间。</p>
<p><strong>减少配置复杂性</strong>：默认动态扩展特性减少了对内存参数的调整需求。</p>
<p><strong>改进类卸载机制</strong>：提高了类卸载的效率，减少内存泄漏风险。</p>
<p><strong>提升兼容性和扩展性</strong>：更符合现代应用程序需求，支持未来 JVM 特性和优化。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>将永久代（PermGen）替换为元空间（Metaspace）是为了解决永久代在内存管理和性能方面的一些固有问题。</p>
<h2 id="固定大小的限制"><a href="#固定大小的限制" class="headerlink" title="固定大小的限制"></a>固定大小的限制</h2><p>永久代的大小是固定的，必须在 JVM 启动时通过参数（如-XX:PermSize和-XX:MaxPermSize）进行配置。固定大小导致了内存管理的刚性，应用程序在运行过程中如果需要加载大量类（例如使用大量反射或动态生成类），可能会导致永久代空间不足，从而抛出OutOfMemoryError: PermGen space异常。</p>
<hr>
<p>元空间使用本地内存（Native Memory），默认情况下可以根据需要动态扩展。动态扩展减少了内存不足的风险，提高了应用程序的稳定性和灵活性。</p>
<h2 id="更好的内存管理"><a href="#更好的内存管理" class="headerlink" title="更好的内存管理"></a>更好的内存管理</h2><p>永久代的垃圾收集与堆内存的垃圾收集有所不同，通常频率较低，且在垃圾收集时可能会导致较长的停顿时间。由于永久代的固定大小，垃圾收集器在回收永久代时需要考虑更多的复杂性，特别是在内存紧张的情况下。</p>
<hr>
<p>元空间的设计使得其垃圾收集更为高效，减少了内存碎片和停顿时间。元空间使用本地内存，减少了 JVM 堆内存的压力，使得堆内存的管理更加简单和高效。</p>
<h2 id="减少配置复杂性"><a href="#减少配置复杂性" class="headerlink" title="减少配置复杂性"></a>减少配置复杂性</h2><p>永久代需要在部署应用程序时仔细调整永久代的大小参数，以避免内存溢出，这增加了配置的复杂性和维护成本。</p>
<hr>
<p>元空间的默认动态扩展特性减少了开发者对内存参数的调整需求。即使需要限制元空间的大小，也可以通过-XX:MaxMetaspaceSize参数进行简单配置。</p>
<h3 id="兼容和扩展"><a href="#兼容和扩展" class="headerlink" title="兼容和扩展"></a>兼容和扩展</h3><p>永久代固定大小的永久代在面对不断变化的应用程序需求和新特性时，显得不够灵活。</p>
<p>元空间的设计更符合现代应用程序的需求，特别是在云计算和大规模分布式系统中。动态扩展和使用本地内存的特性使得元空间更具扩展性和兼容性，能够更好地支持未来的 JVM 特性和优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_/" itemprop="url">👌什么是java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是java内存模型"><a href="#👌什么是java内存模型" class="headerlink" title="👌什么是java内存模型?"></a>👌什么是java内存模型?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 内存模型（Java Memory Model, JMM）是 Java 虚拟机规范的一部分，定义了多线程环境下共享变量的访问规则以及不同线程之间如何通过内存进行交互。JMM 主要解决在多线程编程中可能出现的可见性、原子性和有序性问题。</p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p><strong>线程与主内存</strong>：</p>
<p>每个线程都有自己的工作内存（也称为本地内存），工作内存保存了该线程使用到的变量的副本。主内存是共享内存区域，所有线程都可以访问主内存中的变量。</p>
<p><strong>可见性</strong>：</p>
<p>可见性问题是指一个线程对共享变量的修改，另一个线程是否能够立即看到。JMM 通过volatile关键字、锁机制（如synchronized）等来保证变量的可见性。</p>
<p><strong>原子性</strong>：</p>
<p>原子性问题是指一个操作是否是不可分割的，即操作要么全部执行完成，要么完全不执行。JMM 保证了基本数据类型的读写操作的原子性，但对于复合操作（如 i++）则不保证。</p>
<p><strong>有序性</strong>：</p>
<p>有序性问题是指代码执行的顺序是否与程序的顺序一致。编译器和处理器可能会对指令进行重排序，以提高性能。JMM 通过volatile关键字、锁机制等来保证必要的有序性。</p>
<h2 id="内存模型中的同步机制"><a href="#内存模型中的同步机制" class="headerlink" title="内存模型中的同步机制"></a>内存模型中的同步机制</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile变量保证了对该变量的读写操作的可见性和有序性。</p>
<p>读volatile变量时，总是从主内存中读取最新的值。</p>
<p>写volatile变量时，总是将最新的值写回主内存。</p>
<h3 id="synchronized关键字："><a href="#synchronized关键字：" class="headerlink" title="synchronized关键字："></a>synchronized关键字：</h3><p>synchronized块或方法保证了进入临界区的线程对共享变量的独占访问。</p>
<p>退出synchronized块时，会将工作内存中的变量更新到主内存。</p>
<p>进入synchronized块时，会从主内存中读取最新的变量值。</p>
<h3 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h3><p>final变量在构造器中初始化后，其他线程可以立即看到初始化后的值。</p>
<p>final变量的引用不会被修改，因此可以确保其可见性。</p>
<h2 id="可见性问题示例"><a href="#可见性问题示例" class="headerlink" title="可见性问题示例"></a>可见性问题示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class VisibilityExample &#123;</span><br><span class="line">    private static boolean stop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (!stop) &#123;</span><br><span class="line">                // busy-wait</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true; // 另一个线程可能不会立即看到这个修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程修改了stop变量，但另一个线程可能不会立即看到修改，导致循环无法终止。可以使用volatile关键字解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class VisibilityExample &#123;</span><br><span class="line">    private static volatile boolean stop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (!stop) &#123;</span><br><span class="line">                // busy-wait</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true; // 另一个线程会立即看到这个修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA_/" itemprop="url">👌什么情况会发生栈溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么情况会发生栈溢出"><a href="#👌什么情况会发生栈溢出" class="headerlink" title="👌什么情况会发生栈溢出?"></a>👌什么情况会发生栈溢出?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>栈溢出（Stack Overflow）是指程序在运行过程中，由于调用栈（stack）空间被耗尽而导致的错误。调用栈是用来存储方法调用信息（如局部变量、方法参数和返回地址等）的内存区域。</p>
<h2 id="递归调用过深"><a href="#递归调用过深" class="headerlink" title="递归调用过深"></a>递归调用过深</h2><p>最常见的栈溢出情况是递归调用过深。递归函数在每次调用时都会在栈上分配新的栈帧，如果递归深度过大，栈空间很快就会耗尽。recursiveMethod方法无限递归调用自己，导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无终止条件的递归"><a href="#无终止条件的递归" class="headerlink" title="无终止条件的递归"></a>无终止条件的递归</h2><p>递归函数如果没有正确的终止条件，也会导致栈溢出。recursiveMethod方法的递归调用没有正确的终止条件，导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod(int num) &#123;</span><br><span class="line">        if (num == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        recursiveMethod(num); // 无终止条件的递归</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历深度过大的数据结构"><a href="#遍历深度过大的数据结构" class="headerlink" title="遍历深度过大的数据结构"></a>遍历深度过大的数据结构</h2><p>遍历深度过大的数据结构（如深度优先搜索一个非常深的树或图）也可能导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int value;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void traverse(TreeNode node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(node.left);</span><br><span class="line">        traverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        TreeNode current = root;</span><br><span class="line">        for (int i = 2; i &lt; 100000; i++) &#123;</span><br><span class="line">            current.left = new TreeNode(i);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈空间设置过小"><a href="#栈空间设置过小" class="headerlink" title="栈空间设置过小"></a>栈空间设置过小</h2><p>程序运行时，栈空间的大小是有限的。如果栈空间设置过小，也会更容易发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss128k</span><br></pre></td></tr></table></figure>

<p>通过-Xss参数设置 JVM 栈空间大小为 128KB，可能导致栈溢出。</p>
<h2 id="防止栈溢出的方法"><a href="#防止栈溢出的方法" class="headerlink" title="防止栈溢出的方法"></a>防止栈溢出的方法</h2><p><strong>优化递归</strong>：</p>
<p>确保递归函数有正确的终止条件。</p>
<p>使用尾递归优化（如果编译器或运行时支持）。</p>
<p>将递归转换为迭代。</p>
<p><strong>增加栈空间</strong>：</p>
<p>通过 JVM 参数-Xss增加栈空间大小。</p>
<p><strong>使用非递归算法</strong>：</p>
<p>对于深度优先搜索等场景，使用显式栈（如Stack类）代替递归调用。</p>
<p><strong>检查数据结构</strong>：</p>
<p>确保遍历的数据结构不会过深或过大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJVM%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJVM%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F/" itemprop="url">👌什么是JVM方法区？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是JVM方法区？"><a href="#👌什么是JVM方法区？" class="headerlink" title="👌什么是JVM方法区？"></a>👌什么是JVM方法区？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 方法区是 JVM 运行时数据区的一部分，用于存储与类和方法相关的元数据。它是所有线程共享的内存区域，包含了 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区的内容在 JVM 启动时创建，并在 JVM 运行期间动态扩展或收缩。</p>
<h2 id="方法区的主要内容"><a href="#方法区的主要内容" class="headerlink" title="方法区的主要内容"></a>方法区的主要内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+</span><br><span class="line">|         方法区 (Method Area)         |</span><br><span class="line">|  - 类信息                                    |</span><br><span class="line">|  - 运行时常量池                         |</span><br><span class="line">|  - 静态变量                                |</span><br><span class="line">|  - 即时编译器编译后的代码         |</span><br><span class="line">|  - 字段和方法信息                     |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>类信息</strong>：包括类名、父类名、访问修饰符、接口列表等的元数据。</li>
<li><strong>运行时常量池</strong>：存储编译期生成的各种字面量和符号引用，这些引用在类加载后被解析为直接引用。</li>
<li><strong>静态变量</strong>：类的静态字段，存储类级别的变量。</li>
<li><strong>即时编译器编译后的代码</strong>：即时编译器（JIT）将热点代码编译为本地机器码，存储在方法区中。</li>
<li><strong>字段和方法信息</strong>：包括字段描述、方法描述、方法字节码、方法的访问修饰符等。</li>
</ol>
<h2 id="方法区在不同-JVM-实现中的差异"><a href="#方法区在不同-JVM-实现中的差异" class="headerlink" title="方法区在不同 JVM 实现中的差异"></a>方法区在不同 JVM 实现中的差异</h2><p><strong>HotSpot JVM（Java 7 及之前）</strong>：方法区实现为永久代（Permanent Generation，PermGen）。永久代的内存空间固定，容易导致内存溢出（OutOfMemoryError）。</p>
<p><strong>HotSpot JVM（Java 8 及之后）</strong>：方法区实现为元空间（Metaspace）。元空间使用本地内存（Native Memory），默认情况下可以根据需要动态扩展，减少了内存溢出的风险。</p>
<h2 id="方法区的内存管理"><a href="#方法区的内存管理" class="headerlink" title="方法区的内存管理"></a>方法区的内存管理</h2><p>方法区的内存管理主要包括以下几个方面：</p>
<ol>
<li><strong>类加载</strong>：当一个类被加载时，其相关信息会被存储在方法区中。</li>
<li><strong>类卸载</strong>：当一个类不再被使用且没有任何引用时，垃圾收集器可以回收方法区中的类元数据。</li>
<li><strong>垃圾收集</strong>：方法区的垃圾收集主要针对废弃的类元数据和常量池中的无用常量。相比堆内存的垃圾收集，方法区的垃圾收集频率较低。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url">👌软引用和虚引用适用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌软引用和虚引用适用场景"><a href="#👌软引用和虚引用适用场景" class="headerlink" title="👌软引用和虚引用适用场景"></a>👌软引用和虚引用适用场景</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用主要用于实现内存敏感的缓存。</p>
<p>软引用可以用于缓存那些可以在内存不足时安全回收的对象。例如，图片缓存、数据缓存等场景。在内存充足时，缓存的对象不会被回收；当内存不足时，缓存的对象会被回收以释放内存。这种机制可以在不影响应用程序功能的前提下，最大限度地利用可用内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SoftReferenceCache&lt;K, V&gt; &#123;</span><br><span class="line">    private final Map&lt;K, SoftReference&lt;V&gt;&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void put(K key, V value) &#123;</span><br><span class="line">        cache.put(key, new SoftReference&lt;&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V get(K key) &#123;</span><br><span class="line">        SoftReference&lt;V&gt; ref = cache.get(key);</span><br><span class="line">        if (ref != null) &#123;</span><br><span class="line">            return ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SoftReferenceCache使用软引用来缓存对象，当内存不足时，缓存的对象可能会被回收。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用主要用于跟踪对象被垃圾收集器回收的时间，通常用于实现特殊的清理机制。</p>
<p>虚引用可以用于管理那些需要在对象被回收后进行清理的资源，例如直接内存（Direct Memory）、文件句柄等。</p>
<p>当对象被垃圾收集器回收时，虚引用会被放入引用队列（ReferenceQueue），通过处理这个队列，可以执行必要的清理操作。</p>
<p>虚引用可以用于监控对象何时被回收，从而在对象回收时执行一些特定的操作，例如记录日志、更新状态等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.PhantomReference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line">public class PhantomReferenceExample &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ReferenceQueue&lt;Object&gt; refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        Object obj = new Object();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = new PhantomReference&lt;&gt;(obj, refQueue);</span><br><span class="line"></span><br><span class="line">        obj = null; // 允许 obj 对象被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">        // 强制垃圾收集</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 检查引用队列</span><br><span class="line">        if (refQueue.poll() != null) &#123;</span><br><span class="line">            System.out.println(&quot;Object has been collected&quot;);</span><br><span class="line">            // 执行清理操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当obj被垃圾收集器回收时，phantomRef会被放入refQueue中，可以通过检查refQueue来执行清理操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/Gcroot%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/Gcroot%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌Gc root对象都包含哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Gc-root对象都包含哪些？"><a href="#👌Gc-root对象都包含哪些？" class="headerlink" title="👌Gc root对象都包含哪些？"></a>👌Gc root对象都包含哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root"></a>什么是GC Root</h2><p>GC Root是垃圾回收器确定对象是否可达的起始点。在Java中，GC Root是一组特殊的对象，GC Root对象保证了这些对象及其引用链不会被垃圾回收器回收，因为它们是程序的起始点，其他对象通过它们间接可达，它确保了内存中的对象能够正确地被管理和清理，避免内存泄漏和无效引用的问题。</p>
<h2 id="gcroot-对象"><a href="#gcroot-对象" class="headerlink" title="gcroot 对象"></a>gcroot 对象</h2><p><strong>虚拟机栈（栈帧中的本地变量表）中的引用</strong>：</p>
<p>每个线程都有一个虚拟机栈，栈帧中的本地变量表（Local Variable Table）包含了方法执行过程中用到的所有局部变量。这些局部变量可能包含对对象的引用。</p>
<p><strong>方法区中的类静态变量引用</strong>：</p>
<p>方法区中存储了类的元数据，包括类的静态变量。这些静态变量可能引用对象。</p>
<p><strong>方法区中的常量引用</strong>：</p>
<p>方法区还包含运行时常量池（Runtime Constant Pool），其中可能有对对象的引用。</p>
<p><strong>本地方法栈中的 JNI（Java Native Interface）引用</strong>：</p>
<p>本地方法栈（Native Method Stack）用于本地方法的调用。本地方法可以通过 JNI 引用 Java 对象，这些引用也是 GC Roots。</p>
<p><strong>活动线程</strong>：</p>
<p>所有正在运行的线程本身也是 GC Roots。</p>
<p><strong>类加载器</strong>：</p>
<p>类加载器本身也是 GC Roots，因为它们负责加载类，而类加载器的引用链可以追溯到所有被加载的类及其静态变量。</p>
<p><strong>系统类</strong>：</p>
<p>一些系统级的类，比如java.lang.Thread，java.lang.System等，也被视为 GC Roots。</p>
<p><strong>JNI 全局引用</strong>：</p>
<p>JNI 中的全局引用（Global References）也是 GC Roots。</p>
<p><strong>JVM 内部的某些数据结构</strong>：</p>
<p>JVM 内部的一些数据结构（如 JIT 编译器生成的代码中的引用）也可能被视为 GC Roots。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/" itemprop="url">👌一次完整的垃圾回收过程是什么样的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌一次完整的垃圾回收过程是什么样的？"><a href="#👌一次完整的垃圾回收过程是什么样的？" class="headerlink" title="👌一次完整的垃圾回收过程是什么样的？"></a>👌一次完整的垃圾回收过程是什么样的？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Jvm 垃圾回收的基本过程可以分为以下三个步骤：</p>
<p><img src="/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/x6V_Rb0Mao22_jty/1719147802226-96af4d13-19d6-4cf6-bdc9-c3c028ccd29e-914044.png" alt="1719147802226-96af4d13-19d6-4cf6-bdc9-c3c028ccd29e.png"></p>
<h1 id="垃圾分类"><a href="#垃圾分类" class="headerlink" title="垃圾分类"></a>垃圾分类</h1><p>首先我们的 jvm 在进行垃圾回收的过程，需要确定哪些对象是垃圾对象，哪些对象是存活对象。这个类似于我们在做一件事之前的规划。具体的分类方法一般情况下，垃圾回收器会从堆的根节点（如程序计数器、虚拟机栈、本地方法栈和方法区中的类静态属性等），也就是 gc root。开始遍历对象图，标记所有可以到达的对象为存活对象，未被标记的对象则被认为是垃圾对象。进过标记后，分类成功。</p>
<h1 id="垃圾查找"><a href="#垃圾查找" class="headerlink" title="垃圾查找"></a>垃圾查找</h1><p>分类后，已经知道了对象所处的一个状态，jvm 会根据分类后对象，先找出所有垃圾对象，以便进行清理。</p>
<p>不同的垃圾收集，其中的查找方式会产生相应的差异。随着现在 jdk 的 升级与发展，还会产生更加高效的算法，后面会有垃圾收集的算法详细介绍。</p>
<h2 id="垃圾清理"><a href="#垃圾清理" class="headerlink" title="垃圾清理"></a>垃圾清理</h2><p>标记完成后，进行最后的清理与删除。这里涉及不同的垃圾收集器，清理的方式也不同，常见的有</p>
<p>标记-清除算法，复制算法，标记-整理算法，分代算法。</p>
<p>需要注意的是，垃圾清理可能会引起应用程序的暂停，不同的垃圾回收器通过不同的方式来减少这种暂停时间，从而提高应用程序的性能和可靠性。</p>
<p>常见的垃圾收集器有</p>
<p>Serial GC</p>
<p>Parallel GC</p>
<p>CMS GC（Concurrent Mark Sweep）</p>
<p>G1 GC（Garbage First）</p>
<p>ZGC</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%87%8F%E5%B0%91FULLGC%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%87%8F%E5%B0%91FULLGC%EF%BC%9F/" itemprop="url">👌如何优化减少 FULL GC？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如何优化减少-FULL-GC？"><a href="#👌如何优化减少-FULL-GC？" class="headerlink" title="👌如何优化减少 FULL GC？"></a>👌如何优化减少 FULL GC？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="调整堆内存大小"><a href="#调整堆内存大小" class="headerlink" title="调整堆内存大小"></a>调整堆内存大小</h2><p><strong>增加堆内存大小</strong>：适当增加堆内存大小，可以减少老年代空间不足的情况，从而减少 Full GC 的发生。可以通过-Xmx和-Xms参数调整最大和最小堆内存大小。</p>
<p><strong>调整新生代大小</strong>：适当增加新生代（Young Generation）的大小，可以减少对象晋升到老年代的频率，从而减少老年代的压力。可以通过-XX:NewSize和-XX:MaxNewSize参数调整新生代大小。</p>
<h2 id="调整垃圾收集器参数"><a href="#调整垃圾收集器参数" class="headerlink" title="调整垃圾收集器参数"></a>调整垃圾收集器参数</h2><p>根据应用程序的具体需求，调整垃圾收集器的参数，可以优化垃圾收集行为，比如</p>
<p><strong>G1 GC 参数</strong>：</p>
<p>-XX:MaxGCPauseMillis&#x3D;<N>：设置目标最大 GC 暂停时间，G1 GC 会尝试在这个目标时间内完成 GC。</N></p>
<p>-XX:InitiatingHeapOccupancyPercent&#x3D;<N>：设置触发混合回收的老年代占用比例。</N></p>
<p><strong>CMS 参数</strong>：</p>
<p>-XX:CMSInitiatingOccupancyFraction&#x3D;<N>：设置触发 CMS GC 的老年代占用比例。</N></p>
<p>-XX:+UseCMSInitiatingOccupancyOnly：仅在老年代占用达到设定比例时触发 CMS GC。</p>
<h2 id="优化对象分配和生命周期"><a href="#优化对象分配和生命周期" class="headerlink" title="优化对象分配和生命周期"></a>优化对象分配和生命周期</h2><p>减少对象分配和优化对象生命周期，可以减轻垃圾收集器的负担，从而减少 Full GC 的发生：</p>
<p><strong>减少短生命周期对象</strong>：尽量减少短生命周期对象的创建，或将其分配在栈上而不是堆上。</p>
<p><strong>缓存和重用对象</strong>：使用对象池（Object Pool）缓存和重用对象，减少对象分配和垃圾回收的频率。</p>
<h2 id="避免显式调用System-gc"><a href="#避免显式调用System-gc" class="headerlink" title="避免显式调用System.gc()"></a>避免显式调用System.gc()</h2><p>显式调用System.gc()会请求 JVM 进行 Full GC，尽量避免在代码中使用System.gc()，除非有充分的理由和必要性。</p>
<h2 id="调整元空间（Metaspace）大小"><a href="#调整元空间（Metaspace）大小" class="headerlink" title="调整元空间（Metaspace）大小"></a>调整元空间（Metaspace）大小</h2><p>适当增加元空间大小，可以减少因元空间不足而触发的 Full GC</p>
<p>-XX:MetaspaceSize&#x3D;<size>：设置初始元空间大小。</size></p>
<p>-XX:MaxMetaspaceSize&#x3D;<size>：设置最大元空间大小。</size></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" itemprop="url">👌如何破坏双亲委派模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如何破坏双亲委派模型"><a href="#👌如何破坏双亲委派模型" class="headerlink" title="👌如何破坏双亲委派模型"></a>👌如何破坏双亲委派模型</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通过创建自定义类加载器并覆盖loadClass方法，可以实现不同于双亲委派机制的类加载策略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        // 如果是特定的类，不使用双亲委派机制</span><br><span class="line">        if (name.startsWith(&quot;com.example&quot;)) &#123;</span><br><span class="line">            // 自定义加载逻辑</span><br><span class="line">            byte[] classData = getClassData(name);</span><br><span class="line">            if (classData != null) &#123;</span><br><span class="line">                return defineClass(name, classData, 0, classData.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则，使用默认的双亲委派机制</span><br><span class="line">        return super.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassData(String className) &#123;</span><br><span class="line">        // 实现类加载的逻辑，例如从文件系统或网络加载类字节码</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过反射机制"><a href="#通过反射机制" class="headerlink" title="通过反射机制"></a>通过反射机制</h2><p>利用反射机制直接操作类加载器的父类加载器，绕过双亲委派机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class BreakParentDelegation &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CustomClassLoader customClassLoader = new CustomClassLoader();</span><br><span class="line">        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        // 获取系统类加载器的父类加载器（扩展类加载器）</span><br><span class="line">        Field parentField = ClassLoader.class.getDeclaredField(&quot;parent&quot;);</span><br><span class="line">        parentField.setAccessible(true);</span><br><span class="line">        parentField.set(appClassLoader, customClassLoader);</span><br><span class="line"></span><br><span class="line">        // 现在系统类加载器的父类加载器被替换为自定义类加载器</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;, true, appClassLoader);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OSGi-框架"><a href="#OSGi-框架" class="headerlink" title="OSGi 框架"></a>OSGi 框架</h2><p>OSGi 框架提供了一种模块化的类加载机制，允许每个模块（Bundle）有自己的类加载器，从而可以打破双亲委派机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// OSGi 中的 BundleActivator 示例</span><br><span class="line">public class MyBundleActivator implements BundleActivator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void start(BundleContext context) throws Exception &#123;</span><br><span class="line">        // 在 OSGi 环境中，每个 Bundle 有自己的类加载器</span><br><span class="line">        ClassLoader bundleClassLoader = getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt; clazz = bundleClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop(BundleContext context) throws Exception &#123;</span><br><span class="line">        // 停止 Bundle 时的清理工作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-SPI（Service-Provider-Interface）"><a href="#使用-SPI（Service-Provider-Interface）" class="headerlink" title="使用 SPI（Service Provider Interface）"></a>使用 SPI（Service Provider Interface）</h2><p>某些服务提供者接口的实现中，可能需要打破双亲委派机制来加载服务实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;MyService&gt; loader = ServiceLoader.load(MyService.class);</span><br><span class="line">        <span class="keyword">for</span> (MyService service : loader) &#123;</span><br><span class="line">            service.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在META-INF&#x2F;services目录下创建一个文件，文件名为接口的全限定名，文件内容为实现类的全限定名。通过这种方式，JVM 会使用Thread.contextClassLoader来加载服务实现类，从而可以打破双亲委派机制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/24/JVM/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/24/JVM/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F/" itemprop="url">👌如何判断对象是否可以被回收？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-24T13:33:41+00:00">
                2025-04-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如何判断对象是否可以被回收？"><a href="#👌如何判断对象是否可以被回收？" class="headerlink" title="👌如何判断对象是否可以被回收？"></a>👌如何判断对象是否可以被回收？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>引用计数法和可达性分析法是两种不同的内存管理和垃圾回收算法。引用计数法通过维护引用计数器来跟踪对象的引用数量，具有实时性好、简单高效等优点，但存在循环引用等问题；而可达性分析法则通过分析对象的引用关系来判断对象是否可达，从而决定对象是否可以被回收，具有准确性高、效率好等优点，是JVM中常用的垃圾回收算法之一。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法（Reference Counting）是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。</p>
<p>当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>实时性好：当没有引用指向一个对象时，该对象可以立即被回收，释放内存资源。</p>
<p>简单高效：引用计数法是一种相对简单的内存管理技术，实现起来较为高效。</p>
<p>无需沿指针查找：与GC标记-清除算法不同，引用计数法无需从根节点开始沿指针查找。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>循环引用问题：当存在循环引用的情况下，对象之间的引用计数可能永远不会为零，导致内存泄漏的发生。</p>
<p>额外开销：每个对象都需要维护一个引用计数器，这会带来一定的额外开销。</p>
<p>不支持并发：在多线程环境下，引用计数法需要进行额外的同步操作，以确保引用计数的准确性，可能导致性能损失。</p>
<h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>可达性分析算法是JVM垃圾回收中的一种算法，它通过分析对象的引用关系，判断对象是否可达，从而决定对象是否可以被回收。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>GC Roots：在Java中，GC Roots通常包括虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区（静态变量）中引用的对象、本地方法栈中JNI（Native方法）引用的对象等。</li>
<li>搜索过程：可达性分析算法从GC Roots开始，递归地访问所有可达的对象，并给它们打上标记。这个过程可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等图遍历算法来实现。</li>
<li>回收判定：如果一个对象到GC Roots没有任何引用链相连（即该对象从GC Roots不可达），则证明该对象是不可用的，可以判定为可回收对象。</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>准确性：通过从GC Roots开始搜索引用链，可以准确地判断哪些对象是可回收的。</p>
<p>效率：结合现代JVM的优化技术，如增量标记、并发标记等，可以提高可达性分析算法的效率。</p>
<p>灵活性：可达性分析算法可以与不同的垃圾回收策略（如标记-清除、标记-整理等）结合使用，以适应不同的应用场景和硬件环境。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/23/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%BB%A5%E5%8F%8A%E5%85%83%E7%A9%BA%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/23/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%BB%A5%E5%8F%8A%E5%85%83%E7%A9%BA%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" itemprop="url">👌方法区和永久代以及元空间有什么区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-23T13:33:41+00:00">
                2025-04-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌方法区和永久代以及元空间有什么区别"><a href="#👌方法区和永久代以及元空间有什么区别" class="headerlink" title="👌方法区和永久代以及元空间有什么区别"></a>👌方法区和永久代以及元空间有什么区别</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区是 JVM 运行时数据区的一部分，用于存储类元数据、常量、静态变量、即时编译器编译后的代码等信息，是 JVM 规范的一部分，但规范并未规定其具体实现方式，是所有线程共享的内存区域。</p>
<h2 id="永久代（Permanent-Generation-PermGen）"><a href="#永久代（Permanent-Generation-PermGen）" class="headerlink" title="永久代（Permanent Generation, PermGen）"></a>永久代（Permanent Generation, PermGen）</h2><p>永久代是 HotSpot JVM 在 Java 7 及之前版本中对方法区的一种具体实现。</p>
<p>永久代的内存空间是固定的，默认情况下不能动态扩展，容易导致内存溢出（OutOfMemoryError）。</p>
<p>主要存储类元数据、运行时常量池、静态变量、即时编译器编译后的代码等。</p>
<p>由于固定大小，容易出现内存不足的情况，尤其是在大量动态生成类或使用大量反射的应用中。</p>
<h3 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h3><p>元空间是 HotSpot JVM 在 Java 8 及之后版本中对方法区的一种新的实现方式，替代了永久代。</p>
<p>元空间使用本地内存（Native Memory）而不是 JVM 堆内存。默认情况下，元空间可以根据需要动态扩展，减少了内存溢出的风险。可以通过 JVM 参数（如-XX:MaxMetaspaceSize）来控制元空间的最大大小。</p>
<p>与永久代类似，元空间也存储类元数据、运行时常量池、静态变量、即时编译器编译后的代码等。由于使用本地内存并且可以动态扩展，元空间更灵活，减少了内存溢出的风险。</p>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>方法区 (Method Area)</th>
<th>永久代 (PermGen)</th>
<th>元空间 (Metaspace)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>JVM 规范的一部分</td>
<td>方法区的实现之一</td>
<td>方法区的实现之一</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>类元数据、常量、静态变量、即时编译器编译后的代码</td>
<td>类元数据、常量、静态变量、即时编译器编译后的代码</td>
<td>类元数据、常量、静态变量、即时编译器编译后的代码</td>
</tr>
<tr>
<td><strong>内存类型</strong></td>
<td>JVM 内存的一部分</td>
<td>JVM 堆内存的一部分</td>
<td>本地内存</td>
</tr>
<tr>
<td><strong>内存大小</strong></td>
<td>规范未定义</td>
<td>固定大小</td>
<td>动态扩展</td>
</tr>
<tr>
<td><strong>垃圾收集</strong></td>
<td>规范未定义</td>
<td>有，但频率较低</td>
<td>有，但频率较低</td>
</tr>
<tr>
<td><strong>适用 JVM 版本</strong></td>
<td>所有版本</td>
<td>Java 7 及之前</td>
<td>Java 8 及之后</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>规范未定义</td>
<td>固定大小，容易溢出</td>
<td>动态扩展，减少溢出风险</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">232</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiaoyaofeihu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
