<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/page/4/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/page/4/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F/" itemprop="url">👌Java创建对象的几种方式？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java创建对象的几种方式？"><a href="#👌Java创建对象的几种方式？" class="headerlink" title="👌Java创建对象的几种方式？"></a>👌Java创建对象的几种方式？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用new关键字</h2><p>这是最常见和直接的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>

<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>通过Class类的newInstance()方法（已过时）或Constructor类的newInstance()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Class.newInstance() 方法（已过时）</span><br><span class="line">MyClass obj1 = MyClass.class.newInstance();</span><br><span class="line"></span><br><span class="line">// 使用 Constructor.newInstance() 方法</span><br><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line">MyClass obj2 = constructor.newInstance();</span><br></pre></td></tr></table></figure>

<h2 id="使用clone-方法"><a href="#使用clone-方法" class="headerlink" title="使用clone()方法"></a>使用clone()方法</h2><p>通过实现Cloneable接口并重写clone()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass implements Cloneable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj1 = new MyClass();</span><br><span class="line">MyClass obj2 = (MyClass) obj1.clone();</span><br></pre></td></tr></table></figure>

<h2 id="使用反序列化"><a href="#使用反序列化" class="headerlink" title="使用反序列化"></a>使用反序列化</h2><p>通过ObjectInputStream进行反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 序列化对象</span><br><span class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));</span><br><span class="line">out.writeObject(obj);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">// 反序列化对象</span><br><span class="line">ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));</span><br><span class="line">MyClass obj = (MyClass) in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h2 id="使用工厂方法"><a href="#使用工厂方法" class="headerlink" title="使用工厂方法"></a>使用工厂方法</h2><p>通过工厂方法模式创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassFactory &#123;</span><br><span class="line">    public static MyClass createInstance() &#123;</span><br><span class="line">        return new MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = MyClassFactory.createInstance();</span><br></pre></td></tr></table></figure>

<h2 id="使用-Builder-模式"><a href="#使用-Builder-模式" class="headerlink" title="使用 Builder 模式"></a>使用 Builder 模式</h2><p>通过构建器模式创建对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private String field1;</span><br><span class="line">    private int field2;</span><br><span class="line"></span><br><span class="line">    private MyClass(Builder builder) &#123;</span><br><span class="line">        this.field1 = builder.field1;</span><br><span class="line">        this.field2 = builder.field2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String field1;</span><br><span class="line">        private int field2;</span><br><span class="line"></span><br><span class="line">        public Builder setField1(String field1) &#123;</span><br><span class="line">            this.field1 = field1;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setField2(int field2) &#123;</span><br><span class="line">            this.field2 = field2;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public MyClass build() &#123;</span><br><span class="line">            return new MyClass(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass obj = new MyClass.Builder().setField1(&quot;value1&quot;).setField2(42).build();</span><br></pre></td></tr></table></figure>

<h2 id="通过Unsafe类"><a href="#通过Unsafe类" class="headerlink" title="通过Unsafe类"></a>通过Unsafe类</h2><p>使用sun.misc.Unsafe类（不建议在生产代码中使用，因为它依赖于内部 API，且不安全）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sun.misc.Unsafe;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class UnsafeExample &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class="line"></span><br><span class="line">        MyClass obj = (MyClass) unsafe.allocateInstance(MyClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>new关键字</strong>：最常用，适用于大多数情况。</p>
<p><strong>反射</strong>：灵活但性能较差，适用于框架或工具类开发。</p>
<p><strong>clone()方法</strong>：适用于需要精确复制对象的情况。</p>
<p><strong>反序列化</strong>：适用于需要从持久化存储中恢复对象的情况。</p>
<p><strong>工厂方法和 Builder 模式</strong>：适用于需要复杂对象创建逻辑的情况。</p>
<p><strong>Unsafe类</strong>：不建议使用，除非在非常特殊的低级别操作中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E6%98%AF%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E6%98%AF%E8%A7%A3%E9%87%8A%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80/" itemprop="url">👌Java是解释语言还是编译语言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java是解释语言还是编译语言"><a href="#👌Java是解释语言还是编译语言" class="headerlink" title="👌Java是解释语言还是编译语言"></a>👌Java是解释语言还是编译语言</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 是一种既具有编译特性又具有解释特性的语言。它独特的运行机制使得它既不同于传统的编译语言（如 C 或 C++），也不同于传统的解释语言（如 Python 或 JavaScript）。</p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><strong>源代码编译</strong>：</p>
<p>Java 源代码文件（.java 文件）首先通过 Java 编译器（javac）编译成字节码文件（.class 文件）。这个编译过程将高层次的 Java 代码转换成一种中间表示形式，即字节码。这些字节码是平台无关的，可以在任何支持 Java 虚拟机（JVM）的系统上运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac MyClass.java</span><br></pre></td></tr></table></figure>

<p><strong>字节码</strong>：字节码是一种中间语言，它并不是直接可执行的机器码，而是需要进一步解释或编译成机器码才能运行。</p>
<p>字节码的设计使得 Java 程序可以在不同的平台上运行，而无需重新编译源代码。</p>
<h2 id="解释阶段"><a href="#解释阶段" class="headerlink" title="解释阶段"></a>解释阶段</h2><p>当运行一个 Java 程序时，Java 虚拟机（JVM）会加载字节码并解释执行。JVM 内部包含一个解释器，它将字节码逐行解释成机器指令，然后执行这些指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java MyClass</span><br></pre></td></tr></table></figure>

<h2 id="Just-In-Time-JIT-编译"><a href="#Just-In-Time-JIT-编译" class="headerlink" title="Just-In-Time (JIT) 编译"></a>Just-In-Time (JIT) 编译</h2><p>为了提高性能，现代 JVM 实现通常包含一个 Just-In-Time (JIT) 编译器。JIT 编译器在程序运行时，将热点代码（即频繁执行的代码）动态编译成本地机器码，从而提高执行效率。这种动态编译使得 Java 结合了解释语言的灵活性和编译语言的高性能。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Java 既是一种编译语言，也是一种解释语言。它通过先编译成字节码，然后由 JVM 解释执行，并结合 JIT 编译优化性能。这种独特的机制使得 Java 具有跨平台性和高效性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B_/" itemprop="url">👌一次完整的垃圾回收过程是什么样的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java的类加载器有哪些"><a href="#👌Java的类加载器有哪些" class="headerlink" title="👌Java的类加载器有哪些?"></a>👌Java的类加载器有哪些?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，类加载器（ClassLoader）是负责将类文件加载到 JVM 中的组件。Java 提供了几种标准的类加载器，每种类加载器都有特定的职责和加载范围。</p>
<h2 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h2><p><strong>职责</strong>：加载 Java 核心类库，如java.lang.*、java.util.*等。</p>
<p><strong>实现</strong>：由本地代码（通常是 C++）实现，不是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或jrt:&#x2F;modules（在模块化系统中）。</p>
<p><strong>特点</strong>：是所有类加载器的顶层，没有父类加载器。</p>
<h2 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h2><p><strong>职责</strong>：加载扩展库中的类。</p>
<p><strong>实现</strong>：由sun.misc.Launcher$ExtClassLoader实现，是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：$JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext目录或由java.ext.dirs系统属性指定的目录。</p>
<p><strong>父类加载器</strong>：引导类加载器。</p>
<h2 id="应用程序类加载器（Application-ClassLoader）"><a href="#应用程序类加载器（Application-ClassLoader）" class="headerlink" title="应用程序类加载器（Application ClassLoader）"></a>应用程序类加载器（Application ClassLoader）</h2><p><strong>职责</strong>：加载应用程序类路径（classpath）中的类。</p>
<p><strong>实现</strong>：由sun.misc.Launcher$AppClassLoader实现，是java.lang.ClassLoader的子类。</p>
<p><strong>加载路径</strong>：由java.class.path系统属性指定的目录和 JAR 文件。</p>
<p><strong>父类加载器</strong>：扩展类加载器。</p>
<h2 id="自定义类加载器（Custom-ClassLoader）"><a href="#自定义类加载器（Custom-ClassLoader）" class="headerlink" title="自定义类加载器（Custom ClassLoader）"></a>自定义类加载器（Custom ClassLoader）</h2><p><strong>职责</strong>：满足特定需求的类加载器，通常在应用程序中自定义实现。</p>
<p><strong>实现</strong>：继承java.lang.ClassLoader并重写findClass方法。</p>
<p><strong>加载路径</strong>：由开发者自行定义，可以是文件系统、网络、数据库等。</p>
<p><strong>父类加载器</strong>：可以指定，也可以继承应用程序类加载器。</p>
<p>以下是一个简单的自定义类加载器示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/aldxe3g9bqszh1eh">https://www.yuque.com/jingdianjichi/xyxdsi/aldxe3g9bqszh1eh</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/java%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/java%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F_/" itemprop="url">👌java 加载 class 文件的几种方式?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌java-加载-class-文件的几种方式"><a href="#👌java-加载-class-文件的几种方式" class="headerlink" title="👌java 加载 class 文件的几种方式?"></a>👌java 加载 class 文件的几种方式?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="使用系统类加载器"><a href="#使用系统类加载器" class="headerlink" title="使用系统类加载器"></a>使用系统类加载器</h2><p>Java的系统类加载器（ClassLoader.getSystemClassLoader()）是默认的类加载器，可以用来加载类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = ClassLoader.getSystemClassLoader().loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用自定义类加载器"><a href="#使用自定义类加载器" class="headerlink" title="使用自定义类加载器"></a>使用自定义类加载器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    byte[] classData = loadClassData(name);</span><br><span class="line">    if (classData == null) &#123;</span><br><span class="line">      throw new ClassNotFoundException();</span><br><span class="line">    &#125;</span><br><span class="line">    return defineClass(name, classData, 0, classData.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private byte[] loadClassData(String name) &#123;</span><br><span class="line">    // 实现加载类数据的逻辑</span><br><span class="line">    return null; // 示例中返回null，实际应返回类的字节码数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      CustomClassLoader customClassLoader = new CustomClassLoader();</span><br><span class="line">      Class&lt;?&gt; clazz = customClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">      System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用URLClassLoader"><a href="#使用URLClassLoader" class="headerlink" title="使用URLClassLoader"></a>使用URLClassLoader</h2><p>URLClassLoader可以从指定的URL加载类，适用于从JAR文件或远程位置加载类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line">public class URLClassLoaderExample &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      URL[] urls = &#123;new URL(&quot;file:///path/to/your/classes/&quot;)&#125;;</span><br><span class="line">      URLClassLoader urlClassLoader = new URLClassLoader(urls);</span><br><span class="line">      Class&lt;?&gt; clazz = urlClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">      System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><p>使用反射机制的Class.forName()方法加载类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Thread-currentThread-getContextClassLoader"><a href="#使用Thread-currentThread-getContextClassLoader" class="headerlink" title="使用Thread.currentThread().getContextClassLoader()"></a>使用Thread.currentThread().getContextClassLoader()</h2><p>获取当前线程的上下文类加载器来加载类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    Class&lt;?&gt; clazz = contextClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">    System.out.println(&quot;Class loaded: &quot; + clazz.getName());</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><font style="color:#2f5496;"></font></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/jvm%E7%9A%84%E7%B1%BB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/jvm%E7%9A%84%E7%B1%BB%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88/" itemprop="url">👌jvm 的类缓存机制是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-的类缓存机制是什么"><a href="#👌jvm-的类缓存机制是什么" class="headerlink" title="👌jvm 的类缓存机制是什么"></a>👌jvm 的类缓存机制是什么</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的类缓存机制是指 JVM 在加载类时，将类的字节码和相关信息（如方法、字段、常量池等）存储在内存中的一种机制。这样做的目的是为了提高类加载的效率，避免重复加载相同的类。</p>
<h2 id="类缓存机制的工作原理"><a href="#类缓存机制的工作原理" class="headerlink" title="类缓存机制的工作原理"></a>类缓存机制的工作原理</h2><ol>
<li><strong>类加载器缓存</strong>：每个类加载器都有一个自己的缓存，用于存储已经加载的类。当需要加载一个类时，类加载器首先会检查其缓存中是否已经有该类的Class对象。如果有，则直接返回该对象；如果没有，则加载该类并将其缓存起来。</li>
<li><strong>双亲委派机制</strong>：在加载类时，类加载器会首先委派给其父类加载器进行加载。如果父类加载器无法加载该类，则由当前类加载器尝试加载。这种机制也有助于类缓存，因为父类加载器的缓存中可能已经有了该类。</li>
<li><strong>常量池缓存</strong>：JVM 会将类的常量池（constant pool）中的符号引用解析为直接引用，并将这些引用缓存起来，以便后续使用时可以快速访问。</li>
</ol>
<h2 id="类缓存的好处"><a href="#类缓存的好处" class="headerlink" title="类缓存的好处"></a>类缓存的好处</h2><p><strong>提高性能</strong>：通过缓存已经加载的类，可以避免重复加载相同的类，从而提高类加载的效率。</p>
<p><strong>减少内存消耗</strong>：缓存机制可以减少类加载过程中重复分配和初始化内存的开销。</p>
<p><strong>保证类的一致性</strong>：通过缓存机制，可以确保同一个类在 JVM 中只有一个Class对象，从而避免类加载冲突和不一致的问题。</p>
<h2 id="类缓存的实现"><a href="#类缓存的实现" class="headerlink" title="类缓存的实现"></a>类缓存的实现</h2><p>在 JVM 的实现中，类缓存通常由ClassLoader类的内部数据结构实现。例如，在 Oracle 的 HotSpot JVM 中，类缓存通常是一个HashMap，其中键是类的全限定名，值是类的Class对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ClassLoaderCacheDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        // 获取系统类加载器</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        // 加载类</span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader.loadClass(&quot;java.lang.String&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader.loadClass(&quot;java.lang.String&quot;);</span><br><span class="line"></span><br><span class="line">        // 比较两个类对象是否相同</span><br><span class="line">        System.out.println(clazz1 == clazz2); // 输出 true，说明类对象被缓存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用系统类加载器加载了两次java.lang.String类，并比较了两个Class对象。由于类加载器缓存的存在，两个Class对象实际上是相同的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E6%88%90%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9B%BF%E6%8D%A2%E6%88%90%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%9F/" itemprop="url">👌为什么将永久代替换成元空间？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌为什么将永久代替换成元空间？"><a href="#👌为什么将永久代替换成元空间？" class="headerlink" title="👌为什么将永久代替换成元空间？"></a>👌为什么将永久代替换成元空间？</h1><p><strong>解决固定大小的限制</strong>：元空间可以动态扩展，减少内存不足的风险。</p>
<p><strong>改进内存管理</strong>：元空间的垃圾收集更为高效，减少了内存碎片和停顿时间。</p>
<p><strong>减少配置复杂性</strong>：默认动态扩展特性减少了对内存参数的调整需求。</p>
<p><strong>改进类卸载机制</strong>：提高了类卸载的效率，减少内存泄漏风险。</p>
<p><strong>提升兼容性和扩展性</strong>：更符合现代应用程序需求，支持未来 JVM 特性和优化。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>将永久代（PermGen）替换为元空间（Metaspace）是为了解决永久代在内存管理和性能方面的一些固有问题。</p>
<h2 id="固定大小的限制"><a href="#固定大小的限制" class="headerlink" title="固定大小的限制"></a>固定大小的限制</h2><p>永久代的大小是固定的，必须在 JVM 启动时通过参数（如-XX:PermSize和-XX:MaxPermSize）进行配置。固定大小导致了内存管理的刚性，应用程序在运行过程中如果需要加载大量类（例如使用大量反射或动态生成类），可能会导致永久代空间不足，从而抛出OutOfMemoryError: PermGen space异常。</p>
<hr>
<p>元空间使用本地内存（Native Memory），默认情况下可以根据需要动态扩展。动态扩展减少了内存不足的风险，提高了应用程序的稳定性和灵活性。</p>
<h2 id="更好的内存管理"><a href="#更好的内存管理" class="headerlink" title="更好的内存管理"></a>更好的内存管理</h2><p>永久代的垃圾收集与堆内存的垃圾收集有所不同，通常频率较低，且在垃圾收集时可能会导致较长的停顿时间。由于永久代的固定大小，垃圾收集器在回收永久代时需要考虑更多的复杂性，特别是在内存紧张的情况下。</p>
<hr>
<p>元空间的设计使得其垃圾收集更为高效，减少了内存碎片和停顿时间。元空间使用本地内存，减少了 JVM 堆内存的压力，使得堆内存的管理更加简单和高效。</p>
<h2 id="减少配置复杂性"><a href="#减少配置复杂性" class="headerlink" title="减少配置复杂性"></a>减少配置复杂性</h2><p>永久代需要在部署应用程序时仔细调整永久代的大小参数，以避免内存溢出，这增加了配置的复杂性和维护成本。</p>
<hr>
<p>元空间的默认动态扩展特性减少了开发者对内存参数的调整需求。即使需要限制元空间的大小，也可以通过-XX:MaxMetaspaceSize参数进行简单配置。</p>
<h3 id="兼容和扩展"><a href="#兼容和扩展" class="headerlink" title="兼容和扩展"></a>兼容和扩展</h3><p>永久代固定大小的永久代在面对不断变化的应用程序需求和新特性时，显得不够灵活。</p>
<p>元空间的设计更符合现代应用程序的需求，特别是在云计算和大规模分布式系统中。动态扩展和使用本地内存的特性使得元空间更具扩展性和兼容性，能够更好地支持未来的 JVM 特性和优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B_/" itemprop="url">👌什么是java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是java内存模型"><a href="#👌什么是java内存模型" class="headerlink" title="👌什么是java内存模型?"></a>👌什么是java内存模型?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 内存模型（Java Memory Model, JMM）是 Java 虚拟机规范的一部分，定义了多线程环境下共享变量的访问规则以及不同线程之间如何通过内存进行交互。JMM 主要解决在多线程编程中可能出现的可见性、原子性和有序性问题。</p>
<h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p><strong>线程与主内存</strong>：</p>
<p>每个线程都有自己的工作内存（也称为本地内存），工作内存保存了该线程使用到的变量的副本。主内存是共享内存区域，所有线程都可以访问主内存中的变量。</p>
<p><strong>可见性</strong>：</p>
<p>可见性问题是指一个线程对共享变量的修改，另一个线程是否能够立即看到。JMM 通过volatile关键字、锁机制（如synchronized）等来保证变量的可见性。</p>
<p><strong>原子性</strong>：</p>
<p>原子性问题是指一个操作是否是不可分割的，即操作要么全部执行完成，要么完全不执行。JMM 保证了基本数据类型的读写操作的原子性，但对于复合操作（如 i++）则不保证。</p>
<p><strong>有序性</strong>：</p>
<p>有序性问题是指代码执行的顺序是否与程序的顺序一致。编译器和处理器可能会对指令进行重排序，以提高性能。JMM 通过volatile关键字、锁机制等来保证必要的有序性。</p>
<h2 id="内存模型中的同步机制"><a href="#内存模型中的同步机制" class="headerlink" title="内存模型中的同步机制"></a>内存模型中的同步机制</h2><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile变量保证了对该变量的读写操作的可见性和有序性。</p>
<p>读volatile变量时，总是从主内存中读取最新的值。</p>
<p>写volatile变量时，总是将最新的值写回主内存。</p>
<h3 id="synchronized关键字："><a href="#synchronized关键字：" class="headerlink" title="synchronized关键字："></a>synchronized关键字：</h3><p>synchronized块或方法保证了进入临界区的线程对共享变量的独占访问。</p>
<p>退出synchronized块时，会将工作内存中的变量更新到主内存。</p>
<p>进入synchronized块时，会从主内存中读取最新的变量值。</p>
<h3 id="final关键字："><a href="#final关键字：" class="headerlink" title="final关键字："></a>final关键字：</h3><p>final变量在构造器中初始化后，其他线程可以立即看到初始化后的值。</p>
<p>final变量的引用不会被修改，因此可以确保其可见性。</p>
<h2 id="可见性问题示例"><a href="#可见性问题示例" class="headerlink" title="可见性问题示例"></a>可见性问题示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class VisibilityExample &#123;</span><br><span class="line">    private static boolean stop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (!stop) &#123;</span><br><span class="line">                // busy-wait</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true; // 另一个线程可能不会立即看到这个修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程修改了stop变量，但另一个线程可能不会立即看到修改，导致循环无法终止。可以使用volatile关键字解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class VisibilityExample &#123;</span><br><span class="line">    private static volatile boolean stop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (!stop) &#123;</span><br><span class="line">                // busy-wait</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        stop = true; // 另一个线程会立即看到这个修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E6%BA%A2%E5%87%BA_/" itemprop="url">👌什么情况会发生栈溢出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么情况会发生栈溢出"><a href="#👌什么情况会发生栈溢出" class="headerlink" title="👌什么情况会发生栈溢出?"></a>👌什么情况会发生栈溢出?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>栈溢出（Stack Overflow）是指程序在运行过程中，由于调用栈（stack）空间被耗尽而导致的错误。调用栈是用来存储方法调用信息（如局部变量、方法参数和返回地址等）的内存区域。</p>
<h2 id="递归调用过深"><a href="#递归调用过深" class="headerlink" title="递归调用过深"></a>递归调用过深</h2><p>最常见的栈溢出情况是递归调用过深。递归函数在每次调用时都会在栈上分配新的栈帧，如果递归深度过大，栈空间很快就会耗尽。recursiveMethod方法无限递归调用自己，导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="无终止条件的递归"><a href="#无终止条件的递归" class="headerlink" title="无终止条件的递归"></a>无终止条件的递归</h2><p>递归函数如果没有正确的终止条件，也会导致栈溢出。recursiveMethod方法的递归调用没有正确的终止条件，导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod(int num) &#123;</span><br><span class="line">        if (num == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        recursiveMethod(num); // 无终止条件的递归</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历深度过大的数据结构"><a href="#遍历深度过大的数据结构" class="headerlink" title="遍历深度过大的数据结构"></a>遍历深度过大的数据结构</h2><p>遍历深度过大的数据结构（如深度优先搜索一个非常深的树或图）也可能导致栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int value;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void traverse(TreeNode node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(node.left);</span><br><span class="line">        traverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        TreeNode current = root;</span><br><span class="line">        for (int i = 2; i &lt; 100000; i++) &#123;</span><br><span class="line">            current.left = new TreeNode(i);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈空间设置过小"><a href="#栈空间设置过小" class="headerlink" title="栈空间设置过小"></a>栈空间设置过小</h2><p>程序运行时，栈空间的大小是有限的。如果栈空间设置过小，也会更容易发生栈溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss128k</span><br></pre></td></tr></table></figure>

<p>通过-Xss参数设置 JVM 栈空间大小为 128KB，可能导致栈溢出。</p>
<h2 id="防止栈溢出的方法"><a href="#防止栈溢出的方法" class="headerlink" title="防止栈溢出的方法"></a>防止栈溢出的方法</h2><p><strong>优化递归</strong>：</p>
<p>确保递归函数有正确的终止条件。</p>
<p>使用尾递归优化（如果编译器或运行时支持）。</p>
<p>将递归转换为迭代。</p>
<p><strong>增加栈空间</strong>：</p>
<p>通过 JVM 参数-Xss增加栈空间大小。</p>
<p><strong>使用非递归算法</strong>：</p>
<p>对于深度优先搜索等场景，使用显式栈（如Stack类）代替递归调用。</p>
<p><strong>检查数据结构</strong>：</p>
<p>确保遍历的数据结构不会过深或过大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJVM%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJVM%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F/" itemprop="url">👌什么是JVM方法区？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌什么是JVM方法区？"><a href="#👌什么是JVM方法区？" class="headerlink" title="👌什么是JVM方法区？"></a>👌什么是JVM方法区？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 方法区是 JVM 运行时数据区的一部分，用于存储与类和方法相关的元数据。它是所有线程共享的内存区域，包含了 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区的内容在 JVM 启动时创建，并在 JVM 运行期间动态扩展或收缩。</p>
<h2 id="方法区的主要内容"><a href="#方法区的主要内容" class="headerlink" title="方法区的主要内容"></a>方法区的主要内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------+</span><br><span class="line">|         方法区 (Method Area)         |</span><br><span class="line">|  - 类信息                                    |</span><br><span class="line">|  - 运行时常量池                         |</span><br><span class="line">|  - 静态变量                                |</span><br><span class="line">|  - 即时编译器编译后的代码         |</span><br><span class="line">|  - 字段和方法信息                     |</span><br><span class="line">+-----------------------------+</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>类信息</strong>：包括类名、父类名、访问修饰符、接口列表等的元数据。</li>
<li><strong>运行时常量池</strong>：存储编译期生成的各种字面量和符号引用，这些引用在类加载后被解析为直接引用。</li>
<li><strong>静态变量</strong>：类的静态字段，存储类级别的变量。</li>
<li><strong>即时编译器编译后的代码</strong>：即时编译器（JIT）将热点代码编译为本地机器码，存储在方法区中。</li>
<li><strong>字段和方法信息</strong>：包括字段描述、方法描述、方法字节码、方法的访问修饰符等。</li>
</ol>
<h2 id="方法区在不同-JVM-实现中的差异"><a href="#方法区在不同-JVM-实现中的差异" class="headerlink" title="方法区在不同 JVM 实现中的差异"></a>方法区在不同 JVM 实现中的差异</h2><p><strong>HotSpot JVM（Java 7 及之前）</strong>：方法区实现为永久代（Permanent Generation，PermGen）。永久代的内存空间固定，容易导致内存溢出（OutOfMemoryError）。</p>
<p><strong>HotSpot JVM（Java 8 及之后）</strong>：方法区实现为元空间（Metaspace）。元空间使用本地内存（Native Memory），默认情况下可以根据需要动态扩展，减少了内存溢出的风险。</p>
<h2 id="方法区的内存管理"><a href="#方法区的内存管理" class="headerlink" title="方法区的内存管理"></a>方法区的内存管理</h2><p>方法区的内存管理主要包括以下几个方面：</p>
<ol>
<li><strong>类加载</strong>：当一个类被加载时，其相关信息会被存储在方法区中。</li>
<li><strong>类卸载</strong>：当一个类不再被使用且没有任何引用时，垃圾收集器可以回收方法区中的类元数据。</li>
<li><strong>垃圾收集</strong>：方法区的垃圾收集主要针对废弃的类元数据和常量池中的无用常量。相比堆内存的垃圾收集，方法区的垃圾收集频率较低。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/26/JVM/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/26/JVM/%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url">👌软引用和虚引用适用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-26T13:33:41+00:00">
                2025-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌软引用和虚引用适用场景"><a href="#👌软引用和虚引用适用场景" class="headerlink" title="👌软引用和虚引用适用场景"></a>👌软引用和虚引用适用场景</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用主要用于实现内存敏感的缓存。</p>
<p>软引用可以用于缓存那些可以在内存不足时安全回收的对象。例如，图片缓存、数据缓存等场景。在内存充足时，缓存的对象不会被回收；当内存不足时，缓存的对象会被回收以释放内存。这种机制可以在不影响应用程序功能的前提下，最大限度地利用可用内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SoftReferenceCache&lt;K, V&gt; &#123;</span><br><span class="line">    private final Map&lt;K, SoftReference&lt;V&gt;&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void put(K key, V value) &#123;</span><br><span class="line">        cache.put(key, new SoftReference&lt;&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V get(K key) &#123;</span><br><span class="line">        SoftReference&lt;V&gt; ref = cache.get(key);</span><br><span class="line">        if (ref != null) &#123;</span><br><span class="line">            return ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SoftReferenceCache使用软引用来缓存对象，当内存不足时，缓存的对象可能会被回收。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用主要用于跟踪对象被垃圾收集器回收的时间，通常用于实现特殊的清理机制。</p>
<p>虚引用可以用于管理那些需要在对象被回收后进行清理的资源，例如直接内存（Direct Memory）、文件句柄等。</p>
<p>当对象被垃圾收集器回收时，虚引用会被放入引用队列（ReferenceQueue），通过处理这个队列，可以执行必要的清理操作。</p>
<p>虚引用可以用于监控对象何时被回收，从而在对象回收时执行一些特定的操作，例如记录日志、更新状态等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.PhantomReference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line">public class PhantomReferenceExample &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ReferenceQueue&lt;Object&gt; refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        Object obj = new Object();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = new PhantomReference&lt;&gt;(obj, refQueue);</span><br><span class="line"></span><br><span class="line">        obj = null; // 允许 obj 对象被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">        // 强制垃圾收集</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 检查引用队列</span><br><span class="line">        if (refQueue.poll() != null) &#123;</span><br><span class="line">            System.out.println(&quot;Object has been collected&quot;);</span><br><span class="line">            // 执行清理操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当obj被垃圾收集器回收时，phantomRef会被放入refQueue中，可以通过检查refQueue来执行清理操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/Gcroot%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/Gcroot%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌Gc root对象都包含哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Gc-root对象都包含哪些？"><a href="#👌Gc-root对象都包含哪些？" class="headerlink" title="👌Gc root对象都包含哪些？"></a>👌Gc root对象都包含哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root"></a>什么是GC Root</h2><p>GC Root是垃圾回收器确定对象是否可达的起始点。在Java中，GC Root是一组特殊的对象，GC Root对象保证了这些对象及其引用链不会被垃圾回收器回收，因为它们是程序的起始点，其他对象通过它们间接可达，它确保了内存中的对象能够正确地被管理和清理，避免内存泄漏和无效引用的问题。</p>
<h2 id="gcroot-对象"><a href="#gcroot-对象" class="headerlink" title="gcroot 对象"></a>gcroot 对象</h2><p><strong>虚拟机栈（栈帧中的本地变量表）中的引用</strong>：</p>
<p>每个线程都有一个虚拟机栈，栈帧中的本地变量表（Local Variable Table）包含了方法执行过程中用到的所有局部变量。这些局部变量可能包含对对象的引用。</p>
<p><strong>方法区中的类静态变量引用</strong>：</p>
<p>方法区中存储了类的元数据，包括类的静态变量。这些静态变量可能引用对象。</p>
<p><strong>方法区中的常量引用</strong>：</p>
<p>方法区还包含运行时常量池（Runtime Constant Pool），其中可能有对对象的引用。</p>
<p><strong>本地方法栈中的 JNI（Java Native Interface）引用</strong>：</p>
<p>本地方法栈（Native Method Stack）用于本地方法的调用。本地方法可以通过 JNI 引用 Java 对象，这些引用也是 GC Roots。</p>
<p><strong>活动线程</strong>：</p>
<p>所有正在运行的线程本身也是 GC Roots。</p>
<p><strong>类加载器</strong>：</p>
<p>类加载器本身也是 GC Roots，因为它们负责加载类，而类加载器的引用链可以追溯到所有被加载的类及其静态变量。</p>
<p><strong>系统类</strong>：</p>
<p>一些系统级的类，比如java.lang.Thread，java.lang.System等，也被视为 GC Roots。</p>
<p><strong>JNI 全局引用</strong>：</p>
<p>JNI 中的全局引用（Global References）也是 GC Roots。</p>
<p><strong>JVM 内部的某些数据结构</strong>：</p>
<p>JVM 内部的一些数据结构（如 JIT 编译器生成的代码中的引用）也可能被视为 GC Roots。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/" itemprop="url">👌一次完整的垃圾回收过程是什么样的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌一次完整的垃圾回收过程是什么样的？"><a href="#👌一次完整的垃圾回收过程是什么样的？" class="headerlink" title="👌一次完整的垃圾回收过程是什么样的？"></a>👌一次完整的垃圾回收过程是什么样的？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Jvm 垃圾回收的基本过程可以分为以下三个步骤：</p>
<p><img src="/2025/04/25/JVM/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/x6V_Rb0Mao22_jty/1719147802226-96af4d13-19d6-4cf6-bdc9-c3c028ccd29e-914044.png" alt="1719147802226-96af4d13-19d6-4cf6-bdc9-c3c028ccd29e.png"></p>
<h1 id="垃圾分类"><a href="#垃圾分类" class="headerlink" title="垃圾分类"></a>垃圾分类</h1><p>首先我们的 jvm 在进行垃圾回收的过程，需要确定哪些对象是垃圾对象，哪些对象是存活对象。这个类似于我们在做一件事之前的规划。具体的分类方法一般情况下，垃圾回收器会从堆的根节点（如程序计数器、虚拟机栈、本地方法栈和方法区中的类静态属性等），也就是 gc root。开始遍历对象图，标记所有可以到达的对象为存活对象，未被标记的对象则被认为是垃圾对象。进过标记后，分类成功。</p>
<h1 id="垃圾查找"><a href="#垃圾查找" class="headerlink" title="垃圾查找"></a>垃圾查找</h1><p>分类后，已经知道了对象所处的一个状态，jvm 会根据分类后对象，先找出所有垃圾对象，以便进行清理。</p>
<p>不同的垃圾收集，其中的查找方式会产生相应的差异。随着现在 jdk 的 升级与发展，还会产生更加高效的算法，后面会有垃圾收集的算法详细介绍。</p>
<h2 id="垃圾清理"><a href="#垃圾清理" class="headerlink" title="垃圾清理"></a>垃圾清理</h2><p>标记完成后，进行最后的清理与删除。这里涉及不同的垃圾收集器，清理的方式也不同，常见的有</p>
<p>标记-清除算法，复制算法，标记-整理算法，分代算法。</p>
<p>需要注意的是，垃圾清理可能会引起应用程序的暂停，不同的垃圾回收器通过不同的方式来减少这种暂停时间，从而提高应用程序的性能和可靠性。</p>
<p>常见的垃圾收集器有</p>
<p>Serial GC</p>
<p>Parallel GC</p>
<p>CMS GC（Concurrent Mark Sweep）</p>
<p>G1 GC（Garbage First）</p>
<p>ZGC</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%87%8F%E5%B0%91FULLGC%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%87%8F%E5%B0%91FULLGC%EF%BC%9F/" itemprop="url">👌如何优化减少 FULL GC？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如何优化减少-FULL-GC？"><a href="#👌如何优化减少-FULL-GC？" class="headerlink" title="👌如何优化减少 FULL GC？"></a>👌如何优化减少 FULL GC？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="调整堆内存大小"><a href="#调整堆内存大小" class="headerlink" title="调整堆内存大小"></a>调整堆内存大小</h2><p><strong>增加堆内存大小</strong>：适当增加堆内存大小，可以减少老年代空间不足的情况，从而减少 Full GC 的发生。可以通过-Xmx和-Xms参数调整最大和最小堆内存大小。</p>
<p><strong>调整新生代大小</strong>：适当增加新生代（Young Generation）的大小，可以减少对象晋升到老年代的频率，从而减少老年代的压力。可以通过-XX:NewSize和-XX:MaxNewSize参数调整新生代大小。</p>
<h2 id="调整垃圾收集器参数"><a href="#调整垃圾收集器参数" class="headerlink" title="调整垃圾收集器参数"></a>调整垃圾收集器参数</h2><p>根据应用程序的具体需求，调整垃圾收集器的参数，可以优化垃圾收集行为，比如</p>
<p><strong>G1 GC 参数</strong>：</p>
<p>-XX:MaxGCPauseMillis&#x3D;<N>：设置目标最大 GC 暂停时间，G1 GC 会尝试在这个目标时间内完成 GC。</N></p>
<p>-XX:InitiatingHeapOccupancyPercent&#x3D;<N>：设置触发混合回收的老年代占用比例。</N></p>
<p><strong>CMS 参数</strong>：</p>
<p>-XX:CMSInitiatingOccupancyFraction&#x3D;<N>：设置触发 CMS GC 的老年代占用比例。</N></p>
<p>-XX:+UseCMSInitiatingOccupancyOnly：仅在老年代占用达到设定比例时触发 CMS GC。</p>
<h2 id="优化对象分配和生命周期"><a href="#优化对象分配和生命周期" class="headerlink" title="优化对象分配和生命周期"></a>优化对象分配和生命周期</h2><p>减少对象分配和优化对象生命周期，可以减轻垃圾收集器的负担，从而减少 Full GC 的发生：</p>
<p><strong>减少短生命周期对象</strong>：尽量减少短生命周期对象的创建，或将其分配在栈上而不是堆上。</p>
<p><strong>缓存和重用对象</strong>：使用对象池（Object Pool）缓存和重用对象，减少对象分配和垃圾回收的频率。</p>
<h2 id="避免显式调用System-gc"><a href="#避免显式调用System-gc" class="headerlink" title="避免显式调用System.gc()"></a>避免显式调用System.gc()</h2><p>显式调用System.gc()会请求 JVM 进行 Full GC，尽量避免在代码中使用System.gc()，除非有充分的理由和必要性。</p>
<h2 id="调整元空间（Metaspace）大小"><a href="#调整元空间（Metaspace）大小" class="headerlink" title="调整元空间（Metaspace）大小"></a>调整元空间（Metaspace）大小</h2><p>适当增加元空间大小，可以减少因元空间不足而触发的 Full GC</p>
<p>-XX:MetaspaceSize&#x3D;<size>：设置初始元空间大小。</size></p>
<p>-XX:MaxMetaspaceSize&#x3D;<size>：设置最大元空间大小。</size></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/25/JVM/%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" itemprop="url">👌如何破坏双亲委派模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-25T13:33:41+00:00">
                2025-04-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如何破坏双亲委派模型"><a href="#👌如何破坏双亲委派模型" class="headerlink" title="👌如何破坏双亲委派模型"></a>👌如何破坏双亲委派模型</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通过创建自定义类加载器并覆盖loadClass方法，可以实现不同于双亲委派机制的类加载策略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        // 如果是特定的类，不使用双亲委派机制</span><br><span class="line">        if (name.startsWith(&quot;com.example&quot;)) &#123;</span><br><span class="line">            // 自定义加载逻辑</span><br><span class="line">            byte[] classData = getClassData(name);</span><br><span class="line">            if (classData != null) &#123;</span><br><span class="line">                return defineClass(name, classData, 0, classData.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则，使用默认的双亲委派机制</span><br><span class="line">        return super.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] getClassData(String className) &#123;</span><br><span class="line">        // 实现类加载的逻辑，例如从文件系统或网络加载类字节码</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过反射机制"><a href="#通过反射机制" class="headerlink" title="通过反射机制"></a>通过反射机制</h2><p>利用反射机制直接操作类加载器的父类加载器，绕过双亲委派机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class BreakParentDelegation &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CustomClassLoader customClassLoader = new CustomClassLoader();</span><br><span class="line">        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        // 获取系统类加载器的父类加载器（扩展类加载器）</span><br><span class="line">        Field parentField = ClassLoader.class.getDeclaredField(&quot;parent&quot;);</span><br><span class="line">        parentField.setAccessible(true);</span><br><span class="line">        parentField.set(appClassLoader, customClassLoader);</span><br><span class="line"></span><br><span class="line">        // 现在系统类加载器的父类加载器被替换为自定义类加载器</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;, true, appClassLoader);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OSGi-框架"><a href="#OSGi-框架" class="headerlink" title="OSGi 框架"></a>OSGi 框架</h2><p>OSGi 框架提供了一种模块化的类加载机制，允许每个模块（Bundle）有自己的类加载器，从而可以打破双亲委派机制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// OSGi 中的 BundleActivator 示例</span><br><span class="line">public class MyBundleActivator implements BundleActivator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void start(BundleContext context) throws Exception &#123;</span><br><span class="line">        // 在 OSGi 环境中，每个 Bundle 有自己的类加载器</span><br><span class="line">        ClassLoader bundleClassLoader = getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt; clazz = bundleClassLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stop(BundleContext context) throws Exception &#123;</span><br><span class="line">        // 停止 Bundle 时的清理工作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-SPI（Service-Provider-Interface）"><a href="#使用-SPI（Service-Provider-Interface）" class="headerlink" title="使用 SPI（Service Provider Interface）"></a>使用 SPI（Service Provider Interface）</h2><p>某些服务提供者接口的实现中，可能需要打破双亲委派机制来加载服务实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ServiceLoader&lt;MyService&gt; loader = ServiceLoader.load(MyService.class);</span><br><span class="line">        <span class="keyword">for</span> (MyService service : loader) &#123;</span><br><span class="line">            service.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在META-INF&#x2F;services目录下创建一个文件，文件名为接口的全限定名，文件内容为实现类的全限定名。通过这种方式，JVM 会使用Thread.contextClassLoader来加载服务实现类，从而可以打破双亲委派机制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/24/JVM/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/24/JVM/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F/" itemprop="url">👌如何判断对象是否可以被回收？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-24T13:33:41+00:00">
                2025-04-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如何判断对象是否可以被回收？"><a href="#👌如何判断对象是否可以被回收？" class="headerlink" title="👌如何判断对象是否可以被回收？"></a>👌如何判断对象是否可以被回收？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>引用计数法和可达性分析法是两种不同的内存管理和垃圾回收算法。引用计数法通过维护引用计数器来跟踪对象的引用数量，具有实时性好、简单高效等优点，但存在循环引用等问题；而可达性分析法则通过分析对象的引用关系来判断对象是否可达，从而决定对象是否可以被回收，具有准确性高、效率好等优点，是JVM中常用的垃圾回收算法之一。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法（Reference Counting）是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。</p>
<p>当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>实时性好：当没有引用指向一个对象时，该对象可以立即被回收，释放内存资源。</p>
<p>简单高效：引用计数法是一种相对简单的内存管理技术，实现起来较为高效。</p>
<p>无需沿指针查找：与GC标记-清除算法不同，引用计数法无需从根节点开始沿指针查找。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>循环引用问题：当存在循环引用的情况下，对象之间的引用计数可能永远不会为零，导致内存泄漏的发生。</p>
<p>额外开销：每个对象都需要维护一个引用计数器，这会带来一定的额外开销。</p>
<p>不支持并发：在多线程环境下，引用计数法需要进行额外的同步操作，以确保引用计数的准确性，可能导致性能损失。</p>
<h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>可达性分析算法是JVM垃圾回收中的一种算法，它通过分析对象的引用关系，判断对象是否可达，从而决定对象是否可以被回收。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li>GC Roots：在Java中，GC Roots通常包括虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区（静态变量）中引用的对象、本地方法栈中JNI（Native方法）引用的对象等。</li>
<li>搜索过程：可达性分析算法从GC Roots开始，递归地访问所有可达的对象，并给它们打上标记。这个过程可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等图遍历算法来实现。</li>
<li>回收判定：如果一个对象到GC Roots没有任何引用链相连（即该对象从GC Roots不可达），则证明该对象是不可用的，可以判定为可回收对象。</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>准确性：通过从GC Roots开始搜索引用链，可以准确地判断哪些对象是可回收的。</p>
<p>效率：结合现代JVM的优化技术，如增量标记、并发标记等，可以提高可达性分析算法的效率。</p>
<p>灵活性：可达性分析算法可以与不同的垃圾回收策略（如标记-清除、标记-整理等）结合使用，以适应不同的应用场景和硬件环境。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/23/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%BB%A5%E5%8F%8A%E5%85%83%E7%A9%BA%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/23/JVM/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%BB%A5%E5%8F%8A%E5%85%83%E7%A9%BA%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" itemprop="url">👌方法区和永久代以及元空间有什么区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-23T13:33:41+00:00">
                2025-04-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌方法区和永久代以及元空间有什么区别"><a href="#👌方法区和永久代以及元空间有什么区别" class="headerlink" title="👌方法区和永久代以及元空间有什么区别"></a>👌方法区和永久代以及元空间有什么区别</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区是 JVM 运行时数据区的一部分，用于存储类元数据、常量、静态变量、即时编译器编译后的代码等信息，是 JVM 规范的一部分，但规范并未规定其具体实现方式，是所有线程共享的内存区域。</p>
<h2 id="永久代（Permanent-Generation-PermGen）"><a href="#永久代（Permanent-Generation-PermGen）" class="headerlink" title="永久代（Permanent Generation, PermGen）"></a>永久代（Permanent Generation, PermGen）</h2><p>永久代是 HotSpot JVM 在 Java 7 及之前版本中对方法区的一种具体实现。</p>
<p>永久代的内存空间是固定的，默认情况下不能动态扩展，容易导致内存溢出（OutOfMemoryError）。</p>
<p>主要存储类元数据、运行时常量池、静态变量、即时编译器编译后的代码等。</p>
<p>由于固定大小，容易出现内存不足的情况，尤其是在大量动态生成类或使用大量反射的应用中。</p>
<h3 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h3><p>元空间是 HotSpot JVM 在 Java 8 及之后版本中对方法区的一种新的实现方式，替代了永久代。</p>
<p>元空间使用本地内存（Native Memory）而不是 JVM 堆内存。默认情况下，元空间可以根据需要动态扩展，减少了内存溢出的风险。可以通过 JVM 参数（如-XX:MaxMetaspaceSize）来控制元空间的最大大小。</p>
<p>与永久代类似，元空间也存储类元数据、运行时常量池、静态变量、即时编译器编译后的代码等。由于使用本地内存并且可以动态扩展，元空间更灵活，减少了内存溢出的风险。</p>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>方法区 (Method Area)</th>
<th>永久代 (PermGen)</th>
<th>元空间 (Metaspace)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>JVM 规范的一部分</td>
<td>方法区的实现之一</td>
<td>方法区的实现之一</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>类元数据、常量、静态变量、即时编译器编译后的代码</td>
<td>类元数据、常量、静态变量、即时编译器编译后的代码</td>
<td>类元数据、常量、静态变量、即时编译器编译后的代码</td>
</tr>
<tr>
<td><strong>内存类型</strong></td>
<td>JVM 内存的一部分</td>
<td>JVM 堆内存的一部分</td>
<td>本地内存</td>
</tr>
<tr>
<td><strong>内存大小</strong></td>
<td>规范未定义</td>
<td>固定大小</td>
<td>动态扩展</td>
</tr>
<tr>
<td><strong>垃圾收集</strong></td>
<td>规范未定义</td>
<td>有，但频率较低</td>
<td>有，但频率较低</td>
</tr>
<tr>
<td><strong>适用 JVM 版本</strong></td>
<td>所有版本</td>
<td>Java 7 及之前</td>
<td>Java 8 及之后</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>规范未定义</td>
<td>固定大小，容易溢出</td>
<td>动态扩展，减少溢出风险</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/22/JVM/%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E5%9C%A8%E5%93%AA%E5%9D%97%E5%8C%BA%E5%9F%9F%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/22/JVM/%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82%E5%9C%A8%E5%93%AA%E5%9D%97%E5%8C%BA%E5%9F%9F%EF%BC%9F/" itemprop="url">👌方法的形参在哪块区域？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-22T13:33:41+00:00">
                2025-04-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌方法的形参在哪块区域？"><a href="#👌方法的形参在哪块区域？" class="headerlink" title="👌方法的形参在哪块区域？"></a>👌方法的形参在哪块区域？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在Java虚拟机（JVM）中，方法的形参（即方法的参数）在方法调用时存储在<strong>栈帧</strong>（Stack Frame）中。栈帧是 JVM 栈（Java Stack）中的一个数据结构，每当一个方法被调用时，JVM 会为该方法创建一个新的栈帧。</p>
<p>一个栈帧主要包含以下几个部分：</p>
<ol>
<li><strong>局部变量表（Local Variable Array）</strong>：用于存储方法的局部变量和形参。</li>
<li><strong>操作数栈（Operand Stack）</strong>：用于执行字节码指令时的操作数。</li>
<li><strong>帧数据（Frame Data）</strong>：包括方法的返回地址、动态链接、方法的调用者等。</li>
</ol>
<p>方法的形参在方法调用时会被传递到局部变量表中。局部变量表是栈帧的一部分，用于存储方法的局部变量和形参。每个局部变量在局部变量表中的位置是通过索引来访问的，这些索引是从0开始的。</p>
<h2 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h2><p>假设有以下Java方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    int sum = a + b;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>add(5, 10)</code>时，JVM 会执行以下步骤：</p>
<ol>
<li><strong>创建栈帧</strong>：为<code>add</code>方法创建一个新的栈帧。</li>
<li><strong>初始化局部变量表</strong>：</li>
</ol>
<p><code>a</code>被存储在局部变量表的索引0处。</p>
<p><code>b</code>被存储在局部变量表的索引1处。</p>
<ol start="3">
<li><strong>执行方法体</strong>：</li>
</ol>
<p><code>int sum = a + b;</code>会在操作数栈上执行，然后将结果存储在局部变量表的索引2处。</p>
<ol start="4">
<li><strong>返回结果</strong>：将<code>sum</code>的值从局部变量表中取出，并作为方法的返回值。</li>
</ol>
<h2 id="栈帧结构示意图"><a href="#栈帧结构示意图" class="headerlink" title="栈帧结构示意图"></a>栈帧结构示意图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|  局部变量表        |</span><br><span class="line">|--------------------|</span><br><span class="line">|  索引0: a = 5      |</span><br><span class="line">|  索引1: b = 10     |</span><br><span class="line">|  索引2: sum = 15   |</span><br><span class="line">+--------------------+</span><br><span class="line">|  操作数栈          |</span><br><span class="line">+--------------------+</span><br><span class="line">|  帧数据            |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>在这个过程中，<code>a</code>和<code>b</code>作为方法的形参被存储在局部变量表中。因此，方法的形参在JVM中存储于栈帧的局部变量表中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/21/JVM/%E8%A7%A6%E5%8F%91FULLGC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/21/JVM/%E8%A7%A6%E5%8F%91FULLGC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5_/" itemprop="url">👌触发FULL GC的几种情况?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-21T13:33:41+00:00">
                2025-04-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌触发FULL-GC的几种情况"><a href="#👌触发FULL-GC的几种情况" class="headerlink" title="👌触发FULL GC的几种情况?"></a>👌触发FULL GC的几种情况?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h2><p>当老年代的空间不足以容纳新的对象时，会触发 Full GC。具体情况包括：</p>
<p><strong>对象晋升</strong>：在 Minor GC 过程中，如果 Survivor 区空间不足，存活对象会被晋升到老年代。如果老年代空间不足以容纳这些晋升的对象，就会触发 Full GC。</p>
<p><strong>大对象分配</strong>：分配大对象（如大型数组或字符串）时，如果老年代空间不足以分配这些大对象，也会触发 Full GC。</p>
<h2 id="永久代或元空间空间不足"><a href="#永久代或元空间空间不足" class="headerlink" title="永久代或元空间空间不足"></a>永久代或元空间空间不足</h2><p>在使用旧版 JVM（如 Java 7 及之前）时，永久代（Permanent Generation）用于存储类的元数据。如果永久代空间不足，会触发 Full GC。在 Java 8 及之后，永久代被元空间（Metaspace）取代，用于存储类的元数据。如果元空间不足，也会触发 Full GC。</p>
<h2 id="调用System-gc"><a href="#调用System-gc" class="headerlink" title="调用System.gc()"></a>调用System.gc()</h2><p>调用System.gc()方法会显式请求 JVM 进行 Full GC。尽管 JVM 不保证一定会执行 Full GC，但通常情况下会触发一次 Full GC。</p>
<h2 id="CMS垃圾收集器的失败"><a href="#CMS垃圾收集器的失败" class="headerlink" title="CMS垃圾收集器的失败"></a>CMS垃圾收集器的失败</h2><p>在使用 CMS 垃圾收集器时，如果并发收集过程中老年代空间不足，CMS 会触发一次 Full GC 作为后备措施。这种情况通常被称为 “promotion failure” 或 “concurrent mode failure”。</p>
<h2 id="JNI-代码导致的内存不足"><a href="#JNI-代码导致的内存不足" class="headerlink" title="JNI 代码导致的内存不足"></a>JNI 代码导致的内存不足</h2><p>某些本地代码（JNI）可能会在堆内存中分配大量对象，导致堆内存不足，从而触发 Full GC。</p>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>如果堆内存中存在大量碎片，导致无法找到足够大的连续空间来分配新对象，也可能触发 Full GC 以尝试压缩内存和清理碎片。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/20/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86Eden%E5%92%8CSurvivor_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/20/JVM/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86Eden%E5%92%8CSurvivor_/" itemprop="url">👌为什么要分Eden和Survivor?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-20T13:33:41+00:00">
                2025-04-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌为什么要分Eden和Survivor"><a href="#👌为什么要分Eden和Survivor" class="headerlink" title="👌为什么要分Eden和Survivor?"></a>👌为什么要分Eden和Survivor?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中将新生代（Young Generation）分为 Eden 区和两个 Survivor 区（S0 和 S1）的主要原因是为了优化垃圾回收的效率和性能。这种分区策略基于对象的生命周期特点，利用复制算法来减少内存碎片和提高垃圾回收的效率。</p>
<h2 id="优化垃圾回收效率"><a href="#优化垃圾回收效率" class="headerlink" title="优化垃圾回收效率"></a>优化垃圾回收效率</h2><p>新生代的垃圾回收通常使用复制算法，这种算法的核心思想是将存活的对象从一个区域复制到另一个区域，而不是在原地进行标记和清除。复制算法的步骤如下：</p>
<p><strong>对象分配</strong>：新创建的对象首先分配在 Eden 区。</p>
<p><strong>Minor GC 触发</strong>：当 Eden 区填满时，会触发一次 Minor GC。</p>
<p><strong>对象复制</strong>：在 Minor GC 过程中，存活的对象会从 Eden 区和当前使用的 Survivor 区（例如 S0）复制到另一个 Survivor 区（例如 S1）。复制完成后，Eden 区和当前使用的 Survivor 区将被清空。</p>
<p><strong>区域交换</strong>：两个 Survivor 区在每次 GC 后交替使用。</p>
<p>假设有一个新生代大小为 1 GB，其中 Eden 区占 80%（800 MB），两个 Survivor 区各占 10%（100 MB）。对象首先分配在 Eden 区，当 Eden 区填满时，触发 Minor GC，将存活对象复制到一个 Survivor 区。下次 GC 时，再将存活对象从当前 Survivor 区复制到另一个 Survivor 区。</p>
<p>这种算法的优点是：</p>
<p><strong>减少内存碎片</strong>：复制算法通过将存活对象紧密排列在一起，避免了内存碎片的问题。</p>
<p><strong>提高回收速度</strong>：复制算法只需要遍历存活对象，而不需要遍历整个内存区域，这使得垃圾回收的速度更快。</p>
<h2 id="优化内存分配"><a href="#优化内存分配" class="headerlink" title="优化内存分配"></a>优化内存分配</h2><p>将新生代分为 Eden 区和两个 Survivor 区，能够更好地管理对象的生命周期：</p>
<p><strong>大多数对象生命周期短</strong>：大多数新创建的对象很快就会变得不可达并被回收。Eden 区专门用于存储这些短生命周期对象，提高了内存分配和回收的效率。</p>
<p><strong>幸存者对象管理</strong>：那些在一次或多次 Minor GC 后仍然存活的对象会被复制到 Survivor 区。通过在两个 Survivor 区之间复制和交换，可以有效管理这些对象的生命周期，直到它们被提升到老年代。</p>
<h2 id="减少-GC-停顿时间"><a href="#减少-GC-停顿时间" class="headerlink" title="减少 GC 停顿时间"></a>减少 GC 停顿时间</h2><p>复制算法和分区策略有助于减少 GC 停顿时间（GC Pause Time），提高应用程序的响应速度：</p>
<p><strong>Minor GC 更快速</strong>：由于新生代通常较小，并且复制算法只处理存活对象，Minor GC 的停顿时间通常较短。</p>
<p><strong>老年代 GC 减少</strong>：通过有效管理新生代的对象，减少了老年代的对象数量和垃圾回收频率，从而减少了 Major GC 或 Full GC 的次数和停顿时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/20/JVM/%E5%B8%B8%E8%A7%81%E7%9A%84jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/20/JVM/%E5%B8%B8%E8%A7%81%E7%9A%84jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌常见的jvm垃圾收集器有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-20T13:33:41+00:00">
                2025-04-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-16T01:59:28+00:00">
                2025-05-16
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌常见的jvm垃圾收集器有哪些？"><a href="#👌常见的jvm垃圾收集器有哪些？" class="headerlink" title="👌常见的jvm垃圾收集器有哪些？"></a>👌常见的jvm垃圾收集器有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>按照堆内存分代管理的思想，目前主要的垃圾收集器有：</p>
<p><img src="/2025/04/20/JVM/%E5%B8%B8%E8%A7%81%E7%9A%84jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/jrzDa7tRwAqZ-X9T/1719153437245-6b20a86f-da22-4468-a839-248939d27401-853517.png" alt="1719153437245-6b20a86f-da22-4468-a839-248939d27401.png"></p>
<h2 id="Serial-和Serial-Old收集器"><a href="#Serial-和Serial-Old收集器" class="headerlink" title="Serial 和Serial Old收集器"></a>Serial 和Serial Old收集器</h2><p>Serial是jvm中最早一批的收集器之一，它是一款单线程收集器。在进行垃圾收集时，需要暂停所有的用户线程（Stop-The-World）</p>
<blockquote>
<p>它的设计初衷是为了适应早期的硬件环境和应用场景。在那个时候，硬件配置相对较低，主要特点包括内存容量较小、CPU 单核、并发应用场景相对较少。</p>
</blockquote>
<p>基于这些限制条件，Serial 系列的垃圾收集器采用了简单高效、资源消耗最少、单线程收集的设计思路</p>
<p>简单高效：由于硬件资源有限，垃圾回收器需要设计得简单高效，以减少系统资源的占用。Serial 系列的垃圾收集器实现简单，适用于小型应用或者简单的测试场景。</p>
<p>资源消耗最少：考虑到当时硬件资源有限，Serial 系列的垃圾收集器尽可能地减少了对系统资源的占用。通过使用单线程执行垃圾回收操作，避免了多线程切换的开销，从而最大程度地节约了系统资源。</p>
<p>单线程收集：由于早期的硬件环境和应用场景下，并发需求较低，采用单线程收集的设计方案足以满足当时的需求。单线程收集简化了垃圾回收器的实现，并降低了系统复杂性，使得垃圾回收过程更加可控和稳定。</p>
<p>Serial采用复制算法进行垃圾收集，Serial Old 收集器是 Serial 的老年代版本，同样是一个单线程收集器，采用标记整理法进行垃圾收集</p>
<h2 id="Parallel-Scavenge-和-Parallel-Old收集器"><a href="#Parallel-Scavenge-和-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge 和 Parallel Old收集器"></a>Parallel Scavenge 和 Parallel Old收集器</h2><p>与ParNew类似，也是一款用于新生代的多线程收集器。但Parallel Scavenge的目标是达到一个可控制的吞吐量，而ParNew的目标是尽可能缩短垃圾收集时用户线程的停顿时间。</p>
<blockquote>
<p>随着硬件资源的升级，包括内存空间的增大和 CPU 的多核化，传统的 Serial 垃圾收集器面临着性能瓶颈。由于它采用单线程执行垃圾回收操作，无法充分利用多核 CPU 的优势，导致在处理大内存空间时性能下降，垃圾回收时间变得更长。为了充分发挥多核 CPU 的优势，JVM 推出了 Parallel 收集器系列。Parallel 收集器的设计思想是利用多线程并行执行垃圾回收操作，以提高整个垃圾收集过程的并行度和性能。</p>
</blockquote>
<p>Parallel 收集器的核心特点包括</p>
<p>多线程并行执行：Parallel 收集器利用了多核 CPU 的优势，通过多个线程同时执行垃圾回收操作，加快了垃圾收集的速度。</p>
<p>高吞吐量：由于并行执行垃圾收集操作，Parallel 收集器适用于吞吐量要求较高的应用场景。它能够在保证吞吐量的同时，尽可能地减少垃圾收集的停顿时间。</p>
<p>适用于大内存堆：随着内存空间的扩大，Parallel 收集器能够更好地应对大内存堆的情况，通过并行执行垃圾收集操作，提高了整个垃圾收集过程的效率。</p>
<p>相比于传统的 Serial 收集器，Parallel 收集器能更好地适应现代应用的需求，特别是大型内存堆和高吞吐量的场景。</p>
<p>Parallel Scavenge是一款采用复制算法进行垃圾收集的新生代收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，也是一款多线程的收集器，采用标记整理法进行垃圾收集</p>
<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>ParNew 和 Parallel Scavenge 垃圾收集器都属于并行垃圾收集器。但ParNew的目标是尽可能缩短垃圾收集时用户线程的停顿时间。</p>
<blockquote>
<p> ParNew 垃圾收集器之所以应用更加广泛，一个重要原因是它是唯一能与 CMS（Concurrent Mark-Sweep）收集器配合使用的新生代收集器，特别适用于那些对停顿时间要求较高的应用场景。</p>
</blockquote>
<p>以下是 ParNew 垃圾收集器的一些特点和与 CMS 配合的优势</p>
<p>与 CMS 配合：ParNew 垃圾收集器能够与 CMS 垃圾收集器配合使用，用于处理老年代的垃圾回收。在这种组合中，ParNew 负责新生代的垃圾收集，而 CMS 负责老年代的并发垃圾收集。这种分工合作可以有效地减少应用程序的停顿时间，满足对低停顿时间的需求。</p>
<p>并行收集：ParNew 垃圾收集器采用多线程并行收集的方式，类似于 Parallel Scavenge 收集器。它能够充分利用多核 CPU 的优势，加快垃圾收集的速度，提高整个应用程序的性能。</p>
<p>应对停顿时间要求高的场景：由于 ParNew 与 CMS 配合使用，可以针对那些对停顿时间要求较高的应用场景。CMS 收集器通过并发执行垃圾回收操作，尽量减少停顿时间，而 ParNew 则能够在新生代中高效地执行垃圾回收操作，进一步降低停顿时间。</p>
<p>ParNew采用复制算法进行垃圾收集，是一款新生代的并行收集器</p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS 垃圾收集器的设计初衷是允许垃圾收集器在进行垃圾回收的同时，与应用程序的线程并发执行，不需要长时间暂停应用程序线程。它的工作原理是通过并发标记和清除的方式，先标记所有的存活对象，然后清除未被标记的对象。允许在垃圾收集过程中与应用程序并发执行，从而降低了垃圾收集的停顿时间，提高了系统的响应性和用户体验。</p>
<blockquote>
<p>随着硬件技术的发展，可用内存越来越大，这为应用程序提供了更多的内存空间，从而能够创建更多的对象，减少了垃圾收集的频率。然而，随着内存空间的增大，垃圾收集的时间也相应增加，可能导致长时间的停顿，影响用户体验。在这种情况下，传统的垃圾收集器需要暂停应用程序线程进行垃圾收集，这会导致用户在执行某些操作时出现延迟甚至停顿的情况，这是无法接受的。</p>
</blockquote>
<p>CMS 垃圾收集器的优势</p>
<p>并发标记和清除：CMS 垃圾收集器采用了并发标记和清除的方式，允许在垃圾收集过程中与应用程序并发执行。这意味着垃圾收集过程中只有一小部分时间需要暂停应用程序线程。</p>
<p>低停顿时间：由于并发执行的特性，CMS 垃圾收集器能够在较短的时间内完成垃圾回收操作，从而减少了应用程序的停顿时间。通常情况下，CMS 垃圾收集器能够将停顿时间控制在几百毫秒甚至更低。</p>
<p>CMS 垃圾收集器主要针对老年代进行垃圾回收，对于新生代则通常使用 ParNew 收集器。这种分代收集的方式能够更好地适应不同内存区域的特点和垃圾回收需求。使用了标记清除法+标记整理法</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>CMS 垃圾收集器开创了垃圾收集器的一个新时代，实现了垃圾收集和用户线程同时执行，从而达到了垃圾收集的过程不停止用户线程的目标。这种并发垃圾收集的思路为后续垃圾收集器的发展提供了重要的参考。</p>
<blockquote>
<p>随着硬件资源的不断升级，可用的内存资源越来越多，这对于垃圾收集器的发展提出了新的挑战。传统的垃圾收集器采用物理分区的方式将内存分为老年代、新生代、永久代或 MetaSpace，但随着可用内存的增加，某一分代区域的大小可能会达到几十上百 GB。在这种情况下，传统的物理分区收集方式会导致垃圾扫描和清理时间变得更长，性能下降。</p>
</blockquote>
<p>G1 垃圾收集器摒弃了传统的物理分区方式</p>
<p>将整个内存分成若干个大小不同的 Region 区域。每个 Region 在逻辑上组合成各个分代，这样做的好处是可以以 Region 为单位进行更细粒度的垃圾回收。G1 垃圾收集器在进行垃圾回收时，可以针对单个或多个 Region 进行回收，从而提高了收集效率和性能。</p>
<p>G1 垃圾收集器吸取了 CMS 垃圾收集器的优良思路并通过摒弃物理分区、采用 Region 分区的方式，实现了更细粒度的垃圾回收，从而提高了整个系统的性能和可用性。 G1 垃圾收集器在大内存环境下的表现更加出色，成为了现代 Java 应用中的重要选择。</p>
<h3 id="Region（局部收集）"><a href="#Region（局部收集）" class="headerlink" title="Region（局部收集）"></a>Region（局部收集）</h3><p>G1 垃圾收集器的最核心分区基本单位是 Region。与传统的垃圾收集器不同，G1 不再将堆内存划分为固定连续的几块区域，而是完全舍弃了物理分区，而是将堆内存拆分成大小为 1MB 到 32MB 的 Region 块。然后，以 Region 为单位自由地组合成新生代、老年代、Eden 区、Survivor 区和大对象区（Humongous Region）等。随着垃圾回收和对象分配的进行，每个 Region 也不会一直固定属于某个分代，它们可以随时扮演任何一个分代区域的内存角色。</p>
<h3 id="Collect-Set（智能收集）"><a href="#Collect-Set（智能收集）" class="headerlink" title="Collect Set（智能收集）"></a>Collect Set（智能收集）</h3><p>在G1里面会维护一个Collect Set集合。这个集合记录了待回收的 Region 块的信息，包括每个 Region 块可回收的大小空间。有了这个 CSet 信息，G1 在进行垃圾收集时可以根据用户设定的可接受停顿时间来进行分析，找出在设定的时间范围内收集哪些区域最划算，然后优先收集这些区域。这样做不仅可以优先收集垃圾最多的 Region，还可以根据用户的设定来计算收集哪些 Region 可以达到用户所期望的垃圾收集时间。</p>
<p>通过 CSet，G1 垃圾收集器的性能得到了极大的提升，并且能够实现可预测的停顿时间要求。这使得垃圾回收过程变得更加智能化，更加适应不同的应用场景和用户需求。需要注意的是，用户设定的时间应该合理，官方建议在 100ms 到 300ms 之间，以平衡垃圾收集的效率和停顿时间的需求。</p>
<p>G1采用标记复制法进行垃圾收集，是一款适用于整个堆内存的并行收集器</p>
<h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>ZGC（Z Garbage Collector）是一种低延迟的垃圾回收器，是 JDK 11 引入的一项重要特性。ZGC 的出现为 Java 应用提供了一种更加高效、可预测的垃圾回收解决方案，与传统的垃圾回收器相比，ZGC 的主要目标是实现极低的垃圾回收停顿时间，使得 Java 应用能够以更可预测的方式运行，尤其在大内存堆上表现良好。</p>
<p>ZGC 的优势和特点包括：</p>
<p>低停顿时间：ZGC 致力于将垃圾回收的停顿时间降至最低。它通过并发标记、并发清理等技术，在整个垃圾回收过程中尽量减少对应用程序的影响，从而实现了极低的垃圾回收停顿时间。这使得 Java 应用能够更加平滑地运行，减少了因垃圾回收而导致的不可预测性和性能波动。</p>
<p>可预测性：ZGC 的设计注重可预测性，即使在大内存堆上，也能够提供稳定的性能和可预测的垃圾回收行为。这使得开发人员能够更加信任和依赖于 Java 应用在生产环境中的稳定性和可靠性。</p>
<p>适用于大内存堆：ZGC 的低停顿时间特性使其特别适用于大内存堆的场景。在这种场景下，传统的垃圾回收器可能会面临长时间的停顿，影响应用的响应性和用户体验，而 ZGC 能够有效地缓解这一问题，保持较低的停顿时间，从而确保应用的流畅运行。</p>
<p>ZGC采用并发标记法+并发清理进行垃圾收集，是一款适用整个堆内存并行收集器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">225</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
