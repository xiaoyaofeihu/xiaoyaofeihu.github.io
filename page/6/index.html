<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/page/6/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/page/6/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/List%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/List%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/" itemprop="url">List中的遍历方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在Java中，遍历并修改一个List集合是一个常见的操作，但如果不小心处理，可能会遇到<code>ConcurrentModificationException</code>异常，这通常是因为在遍历过程中直接修改了集合的结构（如添加、删除元素）。下面是你提到的几种处理方案及其详细解释：</li>
</ul>
<ol>
<li><p><strong>通过普通的for循环（不建议，可能会漏删）</strong>：<br>使用普通的for循环遍历List，并通过索引直接修改或删除元素。这种方法的问题是，如果删除元素后没有相应地调整索引（例如，连续删除元素时），可能会导致跳过某些元素的检查或索引越界异常。</p>
</li>
<li><p><strong>通过普通的for循环进行倒序遍历</strong>：<br>倒序遍历可以避免因删除元素而导致的索引调整问题，因为即使删除了元素，后面的元素索引也不会改变（相对于当前遍历方向）。这种方法可以有效避免漏删的问题。</p>
</li>
<li><p><strong>使用迭代器循环</strong>：<br>迭代器提供了一种安全的方式来遍历并修改集合。使用迭代器的<code>remove</code>方法可以安全地删除当前元素，而不会触发<code>ConcurrentModificationException</code>。注意，不能使用集合的<code>remove</code>方法，而应该使用迭代器的<code>remove</code>方法。</p>
</li>
<li><p><strong>复制列表</strong>：<br>创建一个原始列表的副本，遍历原始列表，同时在副本上进行删除操作。这种方法是fail-safe的，因为遍历和修改发生在不同的列表上。但这种方法相对复杂，且需要额外的内存来存储副本。此外，如果列表中的元素是复杂对象，可能需要正确地实现<code>equals</code>和<code>hashCode</code>方法以确保正确的删除。</p>
</li>
<li><p><strong>使用并发安全的集合类</strong>：<br>使用如<code>CopyOnWriteArrayList</code>这样的线程安全的集合类。这种集合类在修改时创建集合的副本，因此遍历和修改可以安全地进行，但这也可能导致在大量修改时性能下降，因为每次修改都需要复制整个集合。</p>
</li>
<li><p><strong>使用Stream的过滤方法</strong>：<br>Java 8引入的Stream API提供了一种声明性的方式来处理集合。通过<code>filter</code>方法，可以创建一个新的Stream，只包含满足特定条件的元素。然后，可以使用<code>collect</code>方法将结果收集到一个新的列表中。这种方法简单高效，因为它避免了在遍历过程中直接修改原始集合。</p>
</li>
<li><p><strong>通过<code>removeIf</code>方法</strong>：<br>Java 8的<code>List</code>接口引入了<code>removeIf</code>方法，它接受一个谓词（Predicate），并删除所有满足该谓词的元素。这是一个非常简洁和高效的方法，用于根据条件删除元素。</p>
</li>
</ol>
<p>综上所述，每种方法都有其适用的场景和优缺点。在选择方法时，应考虑集合的大小、修改的频率、内存使用以及对性能的要求。对于大多数情况，使用<code>removeIf</code>或Stream的<code>filter</code>方法是推荐的做法，因为它们既简单又高效。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/ThreadLocal/" itemprop="url">ThreadLocal的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。"><a href="#ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。" class="headerlink" title="ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。"></a>ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。</h2><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现主要依赖于一个内部类ThreadLocalMap。这个Map以ThreadLocal对象为键，以线程独有的变量为值。每个线程都维护着一个ThreadLocalMap的引用，这样线程就可以通过ThreadLocal对象作为键，在其自己的ThreadLocalMap中查找或设置值。</p>
<ol>
<li><p><strong>ThreadLocalMap的结构</strong>：</p>
<ul>
<li>ThreadLocalMap是一个哈希表，它的键（Key）是ThreadLocal对象本身的一个弱引用（WeakReference），而值（Value）则是线程独有的变量。</li>
<li>使用弱引用作为键的好处是，当ThreadLocal对象被垃圾回收时，不会因为ThreadLocalMap中的引用而阻止其被回收。但这也带来了一个问题，即如果ThreadLocal对象被回收了，而ThreadLocalMap中的Entry还存在（且Value还未被回收），那么就会出现键为null的情况，这需要在ThreadLocalMap的操作中特别处理。</li>
</ul>
</li>
<li><p><strong>ThreadLocal的方法</strong>：</p>
<ul>
<li><code>initialValue()</code>：返回此线程局部变量的初始值。</li>
<li><code>get()</code>：返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则通过调用<code>initialValue()</code>方法创建并初始化此副本。</li>
<li><code>set(T value)</code>：将此线程局部变量的当前线程副本中的值设置为指定值。</li>
<li><code>remove()</code>：移除此线程局部变量的值。这是一个清理操作，有助于避免内存泄漏，特别是在使用线程池时。</li>
</ul>
</li>
<li><p><strong>ThreadLocalMap的扩容和清理</strong>：</p>
<ul>
<li>ThreadLocalMap的扩容机制与HashMap类似，当元素数量超过阈值时，会进行扩容。</li>
<li>由于ThreadLocalMap的键是弱引用，当没有强引用指向ThreadLocal对象时，ThreadLocal对象可以被垃圾回收。但是，如果ThreadLocal对象被回收了，而对应的Value对象还有强引用存在（即还没有被线程显式地调用<code>remove()</code>方法移除），那么这些Value对象就变成了“孤儿对象”，可能会导致内存泄漏。因此，在使用ThreadLocal时，建议显式地调用<code>remove()</code>方法来清理不再需要的线程局部变量。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>ThreadLocal的典型使用场景包括：</p>
<ul>
<li>在多线程环境中，每个线程需要维护一个独立的、不与其他线程共享的状态或数据。</li>
<li>在处理用户请求时，将用户相关的信息（如用户ID、会话信息等）保存在ThreadLocal中，以便在同一个请求处理流程中方便地访问这些信息，而不需要通过参数传递。</li>
</ul>
<h3 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h3><ul>
<li><strong>内存泄漏</strong>：指的是程序中分配的内存在不再需要时没有被正确释放或回收的情况。随着时间的推移，可用内存逐渐减少，最终可能导致程序性能下降或崩溃。</li>
<li><strong>内存溢出</strong>（OOM, Out of Memory）：当程序运行时，如果请求的内存超出了可用内存的限制，就会抛出内存溢出异常。内存泄漏如果不及时解决，最终可能导致内存溢出。</li>
</ul>
<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p>ThreadLocal是一个用于创建线程本地变量的类。每个线程都拥有自己独立的、初始化为null的变量副本，这些变量对其他线程是不可见的。然而，ThreadLocal的内存泄漏问题是一个比较典型的问题。</p>
<h4 id="ThreadLocal内存泄漏的来源"><a href="#ThreadLocal内存泄漏的来源" class="headerlink" title="ThreadLocal内存泄漏的来源"></a>ThreadLocal内存泄漏的来源</h4><ol>
<li><p><strong>ThreadLocal对象在堆上存储的ThreadLocalMap</strong>：</p>
<ul>
<li>ThreadLocalMap是ThreadLocal的内部类，用于存储线程局部变量。</li>
<li>ThreadLocalMap的key是ThreadLocal对象，value是线程变量的值。</li>
</ul>
</li>
<li><p><strong>ThreadLocal的引用链</strong>：</p>
<ul>
<li>ThreadLocal对象有两个引用源：一个是栈上的ThreadLocal引用（方法内创建），一个是ThreadLocalMap中的key对它的引用。</li>
<li>如果栈上的ThreadLocal引用不再使用（方法结束），但ThreadLocal对象因为还有ThreadLocalMap中的key引用而无法被回收，就会导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>线程对象被重复使用</strong>：</p>
<ul>
<li>在线程池场景中，线程对象会被重复使用。如果线程中的ThreadLocalMap没有及时清理，就会导致内存泄漏。</li>
</ul>
</li>
</ol>
<h4 id="弱引用解决部分内存泄漏问题"><a href="#弱引用解决部分内存泄漏问题" class="headerlink" title="弱引用解决部分内存泄漏问题"></a>弱引用解决部分内存泄漏问题</h4><p>为了解决ThreadLocal对象因为ThreadLocalMap中的key引用而无法被回收的问题，ThreadLocalMap使用了弱引用。</p>
<ul>
<li><strong>弱引用</strong>：如果一个对象只具有弱引用，那么这个对象就会在下次垃圾回收时被回收。</li>
<li>在ThreadLocalMap中，key（ThreadLocal对象）是弱引用。这意味着，当栈上的ThreadLocal引用不再使用时，ThreadLocal对象可以被垃圾回收器回收，从而避免了因为ThreadLocal对象无法被回收而导致的内存泄漏。</li>
</ul>
<p>然而，即使使用了弱引用，ThreadLocal的内存泄漏问题并没有完全解决。因为value（线程变量的值）还是强引用，如果线程对象被重复使用（如在线程池中），并且ThreadLocalMap没有及时清理，那么value所占用的内存仍然无法被回收。因此，开发者还需要在使用完ThreadLocal后，显式地调用<code>remove()</code>方法来清理ThreadLocalMap中的entry，以避免内存泄漏。</p>
<p>综上所述，ThreadLocal的内存泄漏问题是一个复杂的问题，需要开发者和JDK共同解决。JDK通过使用弱引用来解决了一部分问题，但开发者还需要在使用完ThreadLocal后显式地调用<code>remove()</code>方法来避免内存泄漏。<br>总之，ThreadLocal是一个强大的工具，它可以帮助我们在多线程环境中实现数据的隔离和线程安全。但是，使用时也需要注意其潜在的内存泄漏问题，特别是在使用线程池时。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/" itemprop="url">创建线程的方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p><strong>继承<code>Thread</code>类创建线程</strong>：</p>
<ul>
<li>这种方式是通过创建一个新的类，该类继承自<code>Thread</code>类，并重写<code>run</code>方法。然后，通过创建该类的实例并调用其<code>start</code>方法来启动线程。</li>
<li>优点：代码简单，易于理解。</li>
<li>缺点：由于Java是单继承的，继承<code>Thread</code>类后就不能再继承其他类了，这在一定程度上限制了类的扩展性。</li>
</ul>
</li>
<li><p><strong>实现<code>Runnable</code>接口创建线程</strong>：</p>
<ul>
<li>这种方式是通过创建一个实现了<code>Runnable</code>接口的类，并实现其<code>run</code>方法。然后，将该类的实例作为参数传递给<code>Thread</code>类的构造器，创建<code>Thread</code>对象并调用其<code>start</code>方法来启动线程。</li>
<li>优点：由于Java支持接口的多实现，因此这种方式更具灵活性，可以继承其他类并实现<code>Runnable</code>接口。</li>
<li>缺点：相对于继承<code>Thread</code>类，代码稍显复杂。</li>
</ul>
</li>
<li><p><strong>通过<code>Callable</code>和<code>FutureTask</code>创建线程</strong>：</p>
<ul>
<li><code>Callable</code>接口类似于<code>Runnable</code>接口，但它可以返回结果并且可以抛出受检异常（checked exception）。</li>
<li><code>FutureTask</code>是<code>Future</code>接口的一个实现，它包装了一个<code>Callable</code>对象，可以提交给<code>Executor</code>（如线程池）来执行。</li>
<li>这种方式通常用于需要获取线程执行结果或处理受检异常的场景。</li>
</ul>
</li>
<li><p><strong>通过线程池创建线程</strong>：</p>
<ul>
<li>线程池是提前创建好一批线程，并保存在池中。当有任务需要执行时，从池中取出一个线程来执行任务。这种方式可以显著提高资源的利用率和性能。</li>
<li>Java中的<code>ExecutorService</code>接口提供了管理线程池的方法，如<code>newFixedThreadPool</code>、<code>newCachedThreadPool</code>等。</li>
<li>优点：提高资源利用率、性能；简化线程管理。</li>
<li>缺点：增加了代码的复杂性；需要合理配置线程池的大小以避免资源耗尽或性能下降。</li>
</ul>
</li>
</ol>
<p>关于<code>Runnable</code>和<code>Callable</code>的区别：</p>
<ul>
<li><code>Runnable</code>的<code>run</code>方法无返回值，而<code>Callable</code>的<code>call</code>方法有返回值。</li>
<li><code>Callable</code>中可以抛出受检异常，而<code>Runnable</code>不可以。</li>
<li><code>Callable</code>和<code>Runnable</code>都可以应用于<code>executors</code>（执行器），但<code>Thread</code>类只支持<code>Runnable</code>。</li>
</ul>
<p>关于<code>Future</code>和<code>FutureTask</code>：</p>
<ul>
<li><code>Future</code>是一个接口，代表了一个异步执行的结果。它提供了检查执行是否完成、等待完成和获取执行结果的方法。</li>
<li><code>FutureTask</code>是<code>Future</code>接口的一个实现，它实现了一个可以提交给<code>Executor</code>执行的任务，并且可以用来检查任务的执行状态和获取任务的执行结果。</li>
</ul>
<p>最后，线程池是池化技术的一种典型实现，用于提高资源的利用率和性能。在编程中，线程池通常用于管理大量并发任务的执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91/" itemprop="url">并发笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="同一时刻只能一个线程执行代码块"><a href="#同一时刻只能一个线程执行代码块" class="headerlink" title="同一时刻只能一个线程执行代码块"></a>同一时刻只能一个线程执行代码块</h3><h3 id="可以修饰方法和代码块"><a href="#可以修饰方法和代码块" class="headerlink" title="可以修饰方法和代码块"></a>可以修饰方法和代码块</h3><h3 id="如何实现可见性问题"><a href="#如何实现可见性问题" class="headerlink" title="如何实现可见性问题"></a>如何实现可见性问题</h3><ul>
<li><p>实现可见性的过程</p>
<ul>
<li><p>获取互斥锁</p>
</li>
<li><p>清空本地代码，将主内存中的最新拷贝到本地内存</p>
</li>
<li><p>将更改后共享变量值刷新到主内存</p>
</li>
<li><p>释放互斥锁</p>
</li>
</ul>
</li>
</ul>
<h3 id="如何实现同步"><a href="#如何实现同步" class="headerlink" title="如何实现同步"></a>如何实现同步</h3><ul>
<li><p>都是使用mointorenter和monitorexit两个JVM指令实现</p>
</li>
<li><p>什么是管程</p>
<ul>
<li><p>管理共享变量以及对共享变量操作过程，使得支持并发</p>
</li>
<li><p>线程可以对monitor执行lock和unlock操作进行加锁和释放锁</p>
</li>
<li><p>解决互斥问题的思路：将共享变量及对共享变量的操作统一封装起来</p>
</li>
</ul>
</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul>
<li><p>同步锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁</p>
</li>
<li><p>偏向锁：一个线程加锁</p>
</li>
<li><p>轻量级锁：两个线程交替自旋</p>
</li>
<li><p>同步锁锁定资源是对象</p>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="可见性：对变量的修改对所有线程可见"><a href="#可见性：对变量的修改对所有线程可见" class="headerlink" title="可见性：对变量的修改对所有线程可见"></a>可见性：对变量的修改对所有线程可见</h3><ul>
<li><p>可见性</p>
<ul>
<li>volatile在写操作的时候，JVM会发一条lock前缀的指令，将这个缓存的变量会写到系统主存中；其他的使用的时候会从主存读取最新的数据。所以可见</li>
</ul>
</li>
</ul>
<h3 id="内存屏障（Memory-Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。"><a href="#内存屏障（Memory-Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。" class="headerlink" title="内存屏障（Memory Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。"></a>内存屏障（Memory Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。</h3><p>Java编译器会根据内存屏障的规则禁止重排序</p>
<ul>
<li><p>为了保障volatile变量的可见性和禁止指令重排序，java在字节码中插入内存屏障实现</p>
<ul>
<li><p>内存屏障解决指令重排</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序性：禁止指令重排，遵循happens-before原则"><a href="#有序性：禁止指令重排，遵循happens-before原则" class="headerlink" title="有序性：禁止指令重排，遵循happens-before原则"></a>有序性：禁止指令重排，遵循happens-before原则</h3><h3 id="双重检验锁必须加volatile，因为内存屏障"><a href="#双重检验锁必须加volatile，因为内存屏障" class="headerlink" title="双重检验锁必须加volatile，因为内存屏障"></a>双重检验锁必须加volatile，因为内存屏障</h3><ul>
<li><p>双重校验锁实现一个单例</p>
</li>
<li><p>否则会出现空指针</p>
</li>
</ul>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul>
<li><p>不满足原子性</p>
<ul>
<li><p>解决方法</p>
<ul>
<li><p>使用syn</p>
</li>
<li><p>使用可重入锁</p>
</li>
<li><p>使用原子类</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="与syn的区别"><a href="#与syn的区别" class="headerlink" title="与syn的区别"></a>与syn的区别</h3><ul>
<li><p>volatile不需要加锁，不会阻塞线程</p>
</li>
<li><p>volatile是一种简单的同步机制</p>
</li>
</ul>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h3 id="CAS：一条CPU的原子指令，可以保证共享变量修改的原子性"><a href="#CAS：一条CPU的原子指令，可以保证共享变量修改的原子性" class="headerlink" title="CAS：一条CPU的原子指令，可以保证共享变量修改的原子性"></a>CAS：一条CPU的原子指令，可以保证共享变量修改的原子性</h3><ul>
<li><p>使用unsafe类实现，其中都是native方法</p>
</li>
<li><p>根据内存偏移量找到待更新的原值的准确内存地址，使用compareAndSwaplant将待更新的值和预期值进行比较</p>
</li>
<li><p>CAS缺陷</p>
<ul>
<li><p>循环时间太长</p>
</li>
<li><p>只能保证一个共享变量原子操作</p>
</li>
<li><p>ABA问题</p>
<ul>
<li>解决方案：AtomicStampedReference（加个时间作为版本号）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="问题：Thread-的join方法"><a href="#问题：Thread-的join方法" class="headerlink" title="问题：Thread 的join方法"></a>问题：Thread 的join方法</h3><h3 id="与syn的比较"><a href="#与syn的比较" class="headerlink" title="与syn的比较"></a>与syn的比较</h3><ul>
<li><p>syn在以下情况下释放锁</p>
<ul>
<li><p>线程执行完释放</p>
</li>
<li><p>线程执行时发生异常，JVM会自动释放</p>
</li>
<li><p>锁方法执行了wait方法，进行释放锁</p>
</li>
</ul>
</li>
<li><p>syn的问题</p>
<ul>
<li><p>无法控制阻塞时长——&gt;JUC trylock()解决</p>
</li>
<li><p>阻塞不可中断——&gt;lockInterruptibly解决</p>
</li>
<li><p>syn不支持读写锁分离——&gt;JUC的ReentrantReadWriteLock锁</p>
</li>
</ul>
</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><ul>
<li><p>先进先出队列+CAS+volatile</p>
<ul>
<li>维护一个volatile的int类型的state变量，state&#x3D;1是获取到锁；state的值变化是由CAS完成的</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><p>CAS操作提供原子性避免锁</p>
</li>
<li><p>volatile确保修改的可见性和内存操作的有序性</p>
</li>
</ul>
</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="解决并发问题，在线程中传递数据"><a href="#解决并发问题，在线程中传递数据" class="headerlink" title="解决并发问题，在线程中传递数据"></a>解决并发问题，在线程中传递数据</h3><h3 id="通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响"><a href="#通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响" class="headerlink" title="通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响"></a>通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响</h3><h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><ul>
<li><p>为什么</p>
<ul>
<li><p>key ThreadLocal的引用缘</p>
<ul>
<li><p>栈上的ThreadLocal引用</p>
</li>
<li><p>ThreadLocalMap中的key对他的引用</p>
</li>
</ul>
</li>
<li><p>value</p>
<ul>
<li>引用只有一条，从Thread过来的引用</li>
</ul>
</li>
<li><p>出现的问题</p>
<ul>
<li><p>ThreadLocal栈上的引用不见了，但是Threadlocal对象因为还有一个引用，索引无法回收</p>
<ul>
<li>解决方法：ThreadLocal的key改成弱引用</li>
</ul>
</li>
<li><p>Thread对象一直被使用，无法释放</p>
<ul>
<li>解决方法：对于value，Thread一直没有释放，只有在一个ThreadLocal用完的时候，手动调用一下remove方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解决</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E6%8E%92%E5%BA%8F/" itemprop="url">Java中几种集合的排序方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>包括实现Comparable接口、借助Comparator比较器进行排序，以及通过Stream API进行排序。同时还解释了Comparable和Comparator的区别、compareTo和equals的使用场景差异，以及Set集合的排序问题。</li>
</ul>
<ol>
<li><strong>实现Comparable接口</strong>：<ul>
<li>Java中的类可以通过实现Comparable接口来具备排序能力。</li>
<li>实现Comparable接口的类需要重写compareTo方法，该方法定义了对象的排序规则。</li>
<li>例如，学生类（Student）可以实现Comparable接口，并按照姓名和年龄进行排序。</li>
</ul>
</li>
<li><strong>借助Comparator比较器进行排序</strong>：<ul>
<li>当类本身没有实现Comparable接口，或者需要不同的排序规则时，可以使用Comparator接口。</li>
<li>Comparator是一个函数式接口，可以独立于原类之外定义排序逻辑。</li>
<li>例如，可以使用Comparator对学生对象按照姓名和年龄进行排序。</li>
</ul>
</li>
<li><strong>通过Stream API进行排序</strong>：<ul>
<li>Java 8引入了Stream API，可以方便地对集合进行排序操作。</li>
<li>Stream API的sorted方法可以接受一个Comparator作为参数来进行排序。</li>
<li>例如，使用Stream对学生列表进行排序，可以简化排序的代码。</li>
</ul>
</li>
<li><strong>Comparable与Comparator的区别</strong>：<ul>
<li>Comparable用于使类本身具备排序能力，通过实现compareTo方法实现。</li>
<li>Comparator是一个独立的比较器，可以为不具备排序能力的类提供排序逻辑，或者提供不同的排序规则。</li>
</ul>
</li>
<li><strong>compareTo与equals的使用场景</strong>：<ul>
<li>compareTo主要用于排序和数值比较，如BigDecimal的比较。</li>
<li>equals主要用于判断两个对象在业务语义上是否相同，如String的比较通常使用equals来判断字面意义是否相同。</li>
</ul>
</li>
<li><strong>Set集合的排序问题</strong>：<ul>
<li>Set集合本身是无序的，即元素的插入顺序不保证。</li>
<li>但是，SortedSet接口可以保证元素的排序，通过要求元素实现Comparable接口来实现。</li>
<li>LinkedHashSet类通过双向链表记录插入顺序，实现了插入有序的Set。</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E6%AD%BB%E9%94%81/" itemprop="url">死锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>死锁是指两个或两个以上的进程（或线程）在执行过程中，因竞争资源或彼此通信而造成的一种阻塞现象。当这些进程都在等待对方释放资源时，就会形成一个无法打破的僵局，若无外力作用，它们都将无法继续执行。此时，系统处于死锁状态。</p>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ol>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li>
<li><strong>占有且等待</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不可抢占</strong>：进程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h3><p>解决死锁的方法主要分为预防死锁、避免死锁、检测死锁和解除死锁四种。</p>
<ol>
<li><p><strong>预防死锁</strong>：</p>
<ul>
<li>破坏互斥条件：允许资源被多个进程同时访问（但某些资源可能无法这样做）。</li>
<li>破坏占有且等待条件：要求进程一次性申请所有所需资源，或者允许进程在持有资源的同时申请其他资源（但可能降低系统效率）。</li>
<li>破坏不可抢占条件：允许进程被抢占已分配的资源（但可能导致数据不一致等问题）。</li>
<li>破坏循环等待条件：对资源编号，要求进程按编号顺序申请资源（但可能增加资源管理的复杂性）。</li>
</ul>
</li>
<li><p><strong>避免死锁</strong>：</p>
<ul>
<li>使用银行家算法等算法来动态地检查资源分配的安全性，确保系统不会进入不安全状态。</li>
<li>在资源分配过程中，采用资源预分配策略或资源按需分配策略，并监控系统的资源使用情况。</li>
</ul>
</li>
<li><p><strong>检测死锁</strong>：</p>
<ul>
<li>定期检查系统是否存在死锁现象，如使用资源分配图等方法。</li>
<li>一旦发现死锁，立即采取措施进行解除。</li>
</ul>
</li>
<li><p><strong>解除死锁</strong>：</p>
<ul>
<li>终止一个或多个进程，以打破循环等待条件。</li>
<li>回滚到安全状态，重新分配资源。</li>
<li>在数据库系统中，可以采用自动回滚事务、重启事务等方法来解除死锁。</li>
</ul>
</li>
</ol>
<h3 id="数据库死锁的发生与解决"><a href="#数据库死锁的发生与解决" class="headerlink" title="数据库死锁的发生与解决"></a>数据库死锁的发生与解决</h3><p>在数据库中，死锁通常发生在多个事务并发执行时。当事务A持有资源A的锁并尝试获取资源B的锁时，而事务B持有资源B的锁并尝试获取资源A的锁时，就会发生死锁。</p>
<p>解决数据库死锁的方法包括：</p>
<ul>
<li>避免并发修改：尽量减少多个事务对同一资源的并发访问。</li>
<li>保证操作顺序：确保多个事务按照相同的顺序访问资源。</li>
<li>使用锁超时机制：设置锁的超时时间，当事务持有锁超过一定时间时自动释放锁。</li>
<li>使用乐观锁或悲观锁等锁策略来管理资源访问。</li>
</ul>
<p>综上所述，死锁是并发系统中常见的问题之一。通过理解死锁的产生条件、掌握解决死锁的方法以及合理设计资源访问策略，可以有效地预防和解决死锁问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B/" itemprop="url">线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程状态的详细解释"><a href="#线程状态的详细解释" class="headerlink" title="线程状态的详细解释"></a>线程状态的详细解释</h3><ol>
<li><p><strong>初始(NEW)</strong></p>
<p>线程对象被创建，但尚未调用<code>start()</code>方法。此时线程还未开始执行，只是作为一个对象存在于内存中。</p>
</li>
<li><p><strong>运行(RUNNABLE)</strong></p>
<ul>
<li><strong>就绪(READY)</strong>: 线程对象创建后，通过调用<code>start()</code>方法启动。此时线程进入就绪状态，等待操作系统的调度，以获取CPU时间片。</li>
<li><strong>运行中(RUNNING)</strong>: 当就绪状态的线程获得CPU时间片时，开始执行程序代码，进入运行状态。</li>
</ul>
<p>在Java中，由于就绪和运行状态的切换非常频繁，且难以准确区分，因此将两者统称为“运行(RUNNABLE)”状态。</p>
</li>
<li><p><strong>阻塞(BLOCKED)</strong></p>
<p>线程尝试获取某个对象的锁（如通过<code>synchronized</code>关键字），但锁已被其他线程持有。此时线程进入阻塞状态，直到锁被释放并成功获取。</p>
</li>
<li><p><strong>等待(WAITING)</strong></p>
<p>线程通过调用<code>Object</code>类的<code>wait()</code>方法或其他等待方法（如<code>Condition</code>的<code>await()</code>方法）进入等待状态。此时线程需要等待其他线程的通知（通过<code>notify()</code>或<code>notifyAll()</code>方法）或中断来唤醒。</p>
</li>
<li><p><strong>超时等待(TIMED_WAITING)</strong></p>
<p>线程通过调用带有超时参数的等待方法（如<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>等）进入超时等待状态。此时线程在指定的时间内等待，如果超时时间到达或收到其他线程的通知，则线程会被唤醒。</p>
</li>
<li><p><strong>终止(TERMINATED)</strong></p>
<p>线程执行完毕或由于异常等原因终止执行，进入终止状态。此时线程不再占用系统资源。</p>
</li>
</ol>
<h3 id="状态流转的细化"><a href="#状态流转的细化" class="headerlink" title="状态流转的细化"></a>状态流转的细化</h3><ul>
<li>从<strong>初始(NEW)<strong>到</strong>运行(RUNNABLE)</strong>: 调用<code>start()</code>方法。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>阻塞(BLOCKED)</strong>: 尝试获取锁失败。</li>
<li>从<strong>阻塞(BLOCKED)<strong>到</strong>运行(RUNNABLE)</strong>: 成功获取锁。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>等待(WAITING)</strong>: 调用<code>wait()</code>等方法。</li>
<li>从<strong>等待(WAITING)<strong>到</strong>运行(RUNNABLE)</strong>: 收到其他线程的通知或中断。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>超时等待(TIMED_WAITING)</strong>: 调用带有超时参数的等待方法。</li>
<li>从<strong>超时等待(TIMED_WAITING)<strong>到</strong>运行(RUNNABLE)</strong>: 超时时间到达或收到其他线程的通知。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>终止(TERMINATED)</strong>: 线程执行完毕或异常终止。</li>
</ul>
<h3 id="关于RUNNING状态的缺失"><a href="#关于RUNNING状态的缺失" class="headerlink" title="关于RUNNING状态的缺失"></a>关于RUNNING状态的缺失</h3><p>如你所述，由于CPU时间片的分配和线程状态的频繁切换，很难准确区分线程是处于就绪状态还是运行状态。因此，Java将两者统称为“运行(RUNNABLE)”状态，以表示线程当前是可执行的，只要获得CPU时间片就能立即执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解线程的状态及其流转对于编写高效、可靠的并发程序至关重要。通过合理管理线程状态，可以确保程序的正确性和性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>线程池的解释与实现原理</strong></p>
<p><strong>一、线程池的概念</strong></p>
<p>线程池是池化技术的一种典型实现，所谓池化技术就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化技术可以大大提高资源的利用率，提升性能等。线程池，即提前创建好一批线程，并保存在线程池中。当有任务需要执行时，从线程池中选一个线程来执行任务。这样可以避免频繁地创建和销毁线程，从而提高系统的效率和响应速度。</p>
<p><strong>二、线程池的实现</strong></p>
<ol>
<li><p><strong>Java中的线程池</strong></p>
<p>Java中的线程池通过实现<code>ExecutorService</code>接口来提供线程池的功能。<code>Executors</code>类提供了几种创建线程池的方法，如<code>newFixedThreadPool(int Threads)</code>创建固定数目线程的线程池，<code>newCachedThreadPool()</code>创建一个可缓存的线程池，<code>newSingleThreadExecutor()</code>创建一个单线程化的Executor，以及<code>newScheduledThreadPool(int corePoolSize)</code>创建一个支持定时及周期性的任务执行的线程池。</p>
</li>
<li><p><strong>线程池的主要参数</strong></p>
<ul>
<li><code>corePoolSize</code>：核心线程数量，可以类比为正式员工数量，常驻线程数量。</li>
<li><code>maximumPoolSize</code>：最大的线程数量，公司最多雇佣员工数量，包括常驻和临时线程数量。</li>
<li><code>workQueue</code>：多余任务等待队列，当任务数量超过当前线程处理能力时，任务会放入此队列等待执行。</li>
<li><code>keepAliveTime</code>：非核心线程空闲时间，即外包人员等待任务的时间，如果超过这个时间还没有任务执行，则会被销毁。</li>
<li><code>threadFactory</code>：创建线程的工厂，可以在这里统一设置创建的线程的属性。</li>
<li><code>handler</code>：线程池拒绝策略，当任务数量超过线程池的处理能力（包括核心线程、最大线程和任务队列）时，会执行此策略，默认是抛出异常。</li>
</ul>
</li>
<li><p><strong>线程池的工作原理</strong></p>
<p>线程池的工作流程大致如下：</p>
<ul>
<li>当有任务提交到线程池时，首先判断当前线程数量是否小于核心线程数量。如果是，则创建新的线程来执行任务。</li>
<li>如果当前线程数量已经达到核心线程数量，但任务队列未满，则将任务放入任务队列等待执行。</li>
<li>如果任务队列已满，但当前线程数量小于最大线程数量，则创建新的非核心线程来执行任务。</li>
<li>如果当前线程数量已经达到最大线程数量，且任务队列已满，则根据拒绝策略处理新提交的任务。</li>
</ul>
</li>
<li><p><strong>线程池的<code>execute</code>方法</strong></p>
<p><code>execute</code>方法是线程池的核心方法，用于向线程池中添加一个任务。该方法的实现逻辑相对复杂，但大致可以分为以下几个步骤：</p>
<ul>
<li>首先判断线程池的状态和当前线程数量，以及任务队列的状态。</li>
<li>如果满足条件，则尝试创建新的线程来执行任务。</li>
<li>如果不满足条件，则根据拒绝策略处理新提交的任务。</li>
</ul>
</li>
<li><p><strong>添加工作线程</strong></p>
<p>添加工作线程的过程是通过<code>addWorker</code>方法实现的。该方法首先判断线程池的状态和当前线程数量，然后尝试创建新的线程。创建线程的过程可能会受到多种因素的影响，如核心线程数量、最大线程数量、任务队列状态等。</p>
</li>
</ol>
<p><strong>三、总结</strong></p>
<p>线程池是一种高效的并发处理机制，通过提前创建并保存一批线程，当有任务需要执行时，从线程池中选取一个线程来执行任务。这样可以避免频繁地创建和销毁线程，从而提高系统的效率和响应速度。Java中的线程池通过实现<code>ExecutorService</code>接口来提供线程池的功能，并提供了多种创建线程池的方法和参数配置选项。了解线程池的工作原理和实现机制对于编写高效、可扩展的并发程序具有重要意义。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/" itemprop="url">java中的集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java中的集合类有哪些？如何分类的？"><a href="#Java中的集合类有哪些？如何分类的？" class="headerlink" title="Java中的集合类有哪些？如何分类的？"></a>Java中的集合类有哪些？如何分类的？</h1><h2 id="Java的集合框架中主要包含以下几种数据结构："><a href="#Java的集合框架中主要包含以下几种数据结构：" class="headerlink" title="Java的集合框架中主要包含以下几种数据结构："></a>Java的集合框架中主要包含以下几种数据结构：</h2><ol>
<li>List（列表）：有序集合，可以包含重复元素。常见的实现类有ArrayList（基于动态数组实现）和LinkedList（基于链表实现）。</li>
<li>Set（集合）：无序集合，不包含重复元素。常见的实现类有HashSet（基于哈希表实现）和TreeSet（基于红黑树实现）。</li>
<li>Queue（队列）：一种先进先出（FIFO）的数据结构。常见的实现类有LinkedList（也可以作为队列使用）、ArrayDeque（双端队列）和PriorityQueue（优先队列）。</li>
<li>Stack（栈）：一种后进先出（LIFO）的数据结构。在Java中，Stack类继承自Vector类，但现在推荐使用Deque接口的实现类（如ArrayDeque）来代替Stack。</li>
<li>Map（映射）：存储键值对（K-V对）的数据结构。常见的实现类有HashMap（基于哈希表实现）和TreeMap（基于红黑树实现）。</li>
</ol>
<p>从继承关系上讲，List、Set和Queue都是Collection接口的子接口，而Collection接口又继承了Iterable接口。这意味着这些集合都是可以遍历的。</p>
<p>从功能上讲：</p>
<ul>
<li>List代表一个有序容器，元素可以重复。</li>
<li>Set是无序的（除了TreeSet，它是有序的），并且元素不可重复。</li>
<li>Map存储键值对，通过键来访问值。</li>
</ul>
<p>从实现上讲：</p>
<ul>
<li>List可以通过链表（如LinkedList）或数组（如ArrayList）实现。</li>
<li>Queue可以有不同的实现，如优先队列（PriorityQueue）和双端队列（ArrayDeque）。</li>
<li>Map的实现包括普通的HashMap和可以排序的TreeMap。</li>
</ul>
<p>知识扩展：</p>
<p>Collection和Collections有什么区别？</p>
<ol>
<li>Collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法。它是List、Set等的父接口。</li>
<li>Collections是一个包装类，包含各种有关集合操作的静态多态方法。它不能实例化，就像一个工具类，服务于Java的Collection框架。</li>
</ol>
<p>Java中的Collection如何遍历迭代？</p>
<ol>
<li>传统的for循环遍历，基于计数器。</li>
<li>迭代器遍历，使用Iterator接口。</li>
<li>foreach循环遍历，内部也是采用了Iterator的方式实现。</li>
<li>迭代器遍历，使用Enumeration接口，这是Iterator的“古老版本”。</li>
<li>Stream API，JDK 1.8中新增，使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。</li>
</ol>
<p>Iterable和Iterator如何使用?</p>
<ul>
<li>Iterator接口代表迭代的方式，包含next和hasNext方法。</li>
<li>Iterable接口代表的是是否可以迭代，如果可以迭代，会返回Iterator接口，即返回迭代方式。</li>
</ul>
<p>为什么不把Iterable和Iterator合成一个使用？</p>
<ol>
<li>Iterable和Iterator并不是同时出现的，Iterator先于Iterable出现，目的是为了代替Enumeration。</li>
<li>将“是否可以迭代”和“迭代方式”抽出来，更符合单一职责原则，使得迭代方式可以被多个可迭代的集合复用，更符合面向对象的特点。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98/LinkedList%E7%9C%9F%E7%9A%84%E6%AF%94ArrayList%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%BF%AB%E5%90%97_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98/LinkedList%E7%9C%9F%E7%9A%84%E6%AF%94ArrayList%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%BF%AB%E5%90%97_/" itemprop="url">LinkedList 真的比 ArrayList 添加元素快吗</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-16T13:33:41+00:00">
                2024-09-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌LinkedList-真的比-ArrayList-添加元素快吗"><a href="#👌LinkedList-真的比-ArrayList-添加元素快吗" class="headerlink" title="👌LinkedList 真的比 ArrayList 添加元素快吗?"></a>👌LinkedList 真的比 ArrayList 添加元素快吗?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>性能的比较需要根据具体的操作和数据分布来分析。</p>
<h2 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h2><p><strong>ArrayList</strong>：在尾部插入元素时，当数据量较小时，由于ArrayList需要频繁扩容，可能会稍显慢一些。但当数据量较大时，ArrayList的扩容策略（通常是当前容量的1.5倍）可以一次提供很多空间，减少了扩容的次数，从而在尾部插入效率上可能超过LinkedList。</p>
<p><strong>LinkedList</strong>：在数据量较小时，尾部插入数据较快，因为每次添加只需要新建一个节点并调整指针。但当数据量大时，每次add()操作都会新建一个节点，这可能会增加时间消耗。</p>
<h2 id="首部插入"><a href="#首部插入" class="headerlink" title="首部插入"></a>首部插入</h2><p><strong>ArrayList</strong>：在首部插入元素时，由于需要将原数组所有元素向后移动一个位置（通过System.arraycopy方法），效率相对较低。</p>
<p><strong>LinkedList</strong>：在首部插入元素时，只需要调整首尾节点的指针，时间复杂度为O(1)，因此效率较高。</p>
<h2 id="中间插入"><a href="#中间插入" class="headerlink" title="中间插入"></a>中间插入</h2><p><strong>ArrayList</strong>：在中间插入元素时，同样需要将原数组的元素向后移动以腾出位置，时间复杂度为O(n)，其中n为数组长度。但插入位置越往后，需要复制后移的数据越少，效率相对会高一些。</p>
<p><strong>LinkedList</strong>：在中间插入元素时，需要遍历链表找到插入位置，然后从两端向中间搜索，index越往中间遍历越久，因此效率相对较低。但在数据量较小时，LinkedList的性能可能会超过ArrayList，因为ArrayList在数据量小时需要频繁扩容。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>内存消耗</strong>：LinkedList的每个节点都需要额外的空间来存储指针信息，因此在内存消耗上可能会比ArrayList稍大。</p>
<p><strong>线程安全</strong>：ArrayList和LinkedList都不是线程安全的。如果需要在多线程环境下使用，需要考虑额外的同步措施。</p>
<p>综上所述，LinkedList和ArrayList在添加元素时的性能优劣取决于具体的操作和数据分布。在尾部插入大量数据时，ArrayList可能更优；在首部插入数据时，LinkedList更优；而在中间插入数据时，需要根据数据量的大小和插入位置来具体分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/" itemprop="url">在 SQL 查询中，WHERE 和 HAVING 都可以用来过滤数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-16T13:33:41+00:00">
                2024-09-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 SQL 查询中，WHERE 和 HAVING 都可以用来过滤数据，但它们的工作机制不同：</p>
<p>WHERE：在分组（GROUP BY）之前过滤数据，属于预过滤。<br>HAVING：在分组（GROUP BY）之后过滤数据，属于后过滤。<br>将适合放在 WHERE 条件的过滤写在 HAVING 中，可能导致大量不必要的数据参与分组运算，从而增加查询的时间和资源消耗。</p>
<p>示例<br>原始表<br>假设有一个销售记录表 sales：</p>
<p>sql<br>复制代码<br>CREATE TABLE sales (<br>    id INT PRIMARY KEY,<br>    product_id INT,<br>    sale_date DATE,<br>    amount DECIMAL(10, 2)<br>);<br>数据样例：</p>
<p>id	product_id	sale_date	amount<br>1	101	2024-01-01	100.00<br>2	102	2024-01-02	200.00<br>3	101	2024-01-03	300.00<br>4	103	2024-01-04	400.00<br>5	101	2024-01-05	500.00<br>查询需求<br>我们需要统计每个产品的总销售金额大于 500 的记录。</p>
<p>错误示例：使用 HAVING<br>sql<br>复制代码<br>SELECT product_id, SUM(amount) AS total_amount<br>FROM sales<br>GROUP BY product_id<br>HAVING product_id &#x3D; 101 AND total_amount &gt; 500;<br>问题：</p>
<p>HAVING product_id &#x3D; 101 是一个简单的等值条件，但它放在 HAVING 中，会导致所有数据都参与 GROUP BY 和 SUM 运算。<br>这增加了计算负担，尤其是当数据量很大时。<br>优化：使用 WHERE<br>sql<br>复制代码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">101</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> total_amount <span class="operator">&gt;</span> <span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<p>改进：</p>
<p>在 WHERE 中预先过滤出 product_id &#x3D; 101 的数据，减少了参与 GROUP BY 和 SUM 运算的数据量。<br>查询效率显著提升。<br>性能对比<br>在数据量较大时，比如有 1,000,000 条记录：</p>
<p>HAVING 方式：所有记录都会参与分组计算，资源消耗高，时间长。<br>WHERE 方式：只有满足 product_id &#x3D; 101 的数据参与分组，减少了无用的计算。<br>优化后，查询时间可能降低 30%-50% 或更多，具体视数据量和索引情况而定。</p>
<p>SQL 查询执行顺序<br>SQL 的逻辑执行顺序与书写顺序不同，逻辑执行顺序如下：</p>
<p>FROM：从数据源（表、视图等）加载数据。<br>ON：应用 JOIN 条件（仅适用于多表查询）。<br>JOIN：将符合 ON 条件的表进行连接。<br>WHERE：过滤不符合条件的行（行级过滤）。<br>GROUP BY：将数据分组。<br>HAVING：对分组后的结果进行过滤（基于聚合条件）。<br>SELECT：选择所需的列或表达式。<br>DISTINCT：去重。<br>ORDER BY：对结果集排序。<br>LIMIT：返回指定数量的行。</p>
<p>执行顺序分析<br>优化后的 SQL 调整了条件位置：</p>
<p>WHERE 先执行：WHERE product_id &#x3D; 101 在 GROUP BY 之前过滤掉了不符合条件的行，减少了参与分组的记录数量。<br>减少分组和聚合运算的负担：GROUP BY 和 SUM 只需处理过滤后的数据。<br>HAVING 用于聚合结果过滤：HAVING total_amount &gt; 500 只对已经分组后的结果应用。<br>效果：大幅减少了分组和聚合运算的记录数，提升了性能。</p>
<p>区别：WHERE：在分组之前过滤数据，作用于行。<br>HAVING：在分组之后过滤数据，作用于聚合结果。</p>
<h2 id="mysql索引失效的场景"><a href="#mysql索引失效的场景" class="headerlink" title="mysql索引失效的场景"></a>mysql索引失效的场景</h2><ul>
<li>建立联合索引，id-name-create_time-account_date(入账时间)<br>建立了id-name索引，但是查询条件中有create_time 没有使用索引下推，需要建立一个id-name-create_time索引，会走索引下推；</li>
<li>其中order by 两个时间的排序方式不一致。索引失效</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%A7%A3%E5%86%B3hash%E7%A2%B0%E6%92%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%A7%A3%E5%86%B3hash%E7%A2%B0%E6%92%9E%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F/" itemprop="url">解决hash碰撞的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-16T13:33:41+00:00">
                2024-09-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="解决hash碰撞的方法？"><a href="#解决hash碰撞的方法？" class="headerlink" title="解决hash碰撞的方法？"></a>解决hash碰撞的方法？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="链地址法（Chaining）"><a href="#链地址法（Chaining）" class="headerlink" title="链地址法（Chaining）"></a>链地址法（Chaining）</h2><p>链地址法是最常见的解决哈希碰撞的方法之一。在这种方法中，每个桶（bucket）包含一个链表（或树结构，Java 8 及以上版本）。当发生哈希碰撞时，新的键值对被添加到相应桶的链表中。</p>
<p><strong>优点：</strong></p>
<p>简单易实现。</p>
<p>动态调整链表长度，不需要提前知道元素数量。</p>
<p><strong>缺点：</strong></p>
<p>当链表长度增加时，查找效率下降。</p>
<p>需要额外的存储空间来存储指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class HashMapNode&lt;K, V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    HashMapNode&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashMapNode(K key, V value) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开放地址法（Open-Addressing）"><a href="#开放地址法（Open-Addressing）" class="headerlink" title="开放地址法（Open Addressing）"></a>开放地址法（Open Addressing）</h2><p>开放地址法不使用链表，而是在哈希表本身寻找空闲位置来存储碰撞的元素。常见的开放地址法有以下几种：</p>
<h3 id="线性探测（Linear-Probing）"><a href="#线性探测（Linear-Probing）" class="headerlink" title="线性探测（Linear Probing）"></a>线性探测（Linear Probing）</h3><p>当发生哈希碰撞时，线性探测法在哈希表中向后依次查找下一个空闲位置。</p>
<p>优点：实现简单，不需要额外的存储空间。</p>
<p>缺点：当哈希表接近满时，查找效率急剧下降（称为“主群集”问题）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int hash = key.hashCode() % table.length;</span><br><span class="line">while (table[hash] != null) &#123;</span><br><span class="line">    hash = (hash + 1) % table.length;</span><br><span class="line">&#125;</span><br><span class="line">table[hash] = new Entry(key, value);</span><br></pre></td></tr></table></figure>

<h3 id="二次探测（Quadratic-Probing）"><a href="#二次探测（Quadratic-Probing）" class="headerlink" title="二次探测（Quadratic Probing）"></a>二次探测（Quadratic Probing）</h3><p>二次探测法在发生哈希碰撞时，按照平方序列查找空闲位置（如 1, 4, 9, 16, …）。</p>
<p>优点：减少主群集问题。</p>
<p>缺点：实现较复杂，可能会导致二次群集问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int hash = key.hashCode() % table.length;</span><br><span class="line">int i = 1;</span><br><span class="line">while (table[hash] != null) &#123;</span><br><span class="line">    hash = (hash + i * i) % table.length;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">table[hash] = new Entry(key, value);</span><br></pre></td></tr></table></figure>

<h3 id="双重散列（Double-Hashing）"><a href="#双重散列（Double-Hashing）" class="headerlink" title="双重散列（Double Hashing）"></a>双重散列（Double Hashing）</h3><p>双重散列法使用两个不同的哈希函数。当第一个哈希函数发生碰撞时，使用第二个哈希函数计算新的索引。</p>
<p>优点：减少群集问题。较好的查找性能。</p>
<p>缺点：实现复杂。需要设计两个有效的哈希函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int hash1 = key.hashCode() % table.length;</span><br><span class="line">int hash2 = 1 + (key.hashCode() % (table.length - 1));</span><br><span class="line">while (table[hash1] != null) &#123;</span><br><span class="line">    hash1 = (hash1 + hash2) % table.length;</span><br><span class="line">&#125;</span><br><span class="line">table[hash1] = new Entry(key, value);</span><br></pre></td></tr></table></figure>

<h3 id="再哈希法（Rehashing）"><a href="#再哈希法（Rehashing）" class="headerlink" title="再哈希法（Rehashing）"></a>再哈希法（Rehashing）</h3><p>再哈希法在发生碰撞时，使用不同的哈希函数重新计算哈希值，直到找到空闲位置。</p>
<p>优点：减少群集问题。</p>
<p>缺点：实现复杂。需要设计多个有效的哈希函数。</p>
<h3 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h3><p>在 Java 8 及以上版本中，当链表长度超过一定阈值（默认是 8）时，链表会转换为红黑树，以提高查找效率。</p>
<p>优点：在高冲突情况下性能较好，动态调整链表和树的长度。</p>
<p>缺点：实现复杂，需要额外的存储空间。</p>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><strong>Cuckoo Hashing</strong>：使用两个哈希表和两个哈希函数，如果插入时发生冲突，将原来的元素“踢出”并重新插入到另一个哈希表中。</p>
<p><strong>Hopscotch Hashing</strong>：类似于线性探测，但在插入时会调整元素的位置，使得查找路径更短。</p>
<p>链地址法是最常见的解决哈希碰撞的方法，适用于大多数情况。开放地址法在空间利用率上有优势，但在高负载情况下性能可能下降。再哈希法和其他高级方法适用于特定的高性能需求场景。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/10/%E5%9F%BA%E7%A1%80/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/10/%E5%9F%BA%E7%A1%80/synchronized/" itemprop="url">synchronized</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-10T17:33:00+00:00">
                2024-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="1-synchronized-的使用方法"><a href="#1-synchronized-的使用方法" class="headerlink" title="1. synchronized 的使用方法"></a>1. synchronized 的使用方法</h3><ul>
<li><strong>同步方法</strong>：在方法声明时加上 <code>synchronized</code> 关键字，这样当某个线程调用这个方法时，会先获取到该方法的锁（通常是该方法所属对象的锁），其他线程必须等待锁被释放后才能调用这个方法。</li>
<li><strong>同步代码块</strong>：使用 <code>synchronized(对象)</code> 来定义一个同步代码块，这里的对象就是锁对象。当线程进入这个代码块时，会先尝试获取这个对象的锁，获取到锁后才能执行代码块中的代码。</li>
</ul>
<h3 id="2-synchronized-的实现机制"><a href="#2-synchronized-的实现机制" class="headerlink" title="2. synchronized 的实现机制"></a>2. synchronized 的实现机制</h3><ul>
<li><strong>方法级同步</strong>：对于同步方法，JVM 在方法的常量池中添加一个 <code>ACC_SYNCHRONIZED</code> 标志。当线程调用这个方法时，会检查这个标志，如果设置了该标志，则需要先获取到方法的锁（通常是该方法所属对象的监视器锁），然后开始执行方法，方法执行完毕后再释放锁。</li>
<li><strong>代码块级同步</strong>：对于同步代码块，JVM 使用 <code>monitorenter</code> 和 <code>monitorexit</code> 两条字节码指令来实现同步。<code>monitorenter</code> 指令用于获取锁，<code>monitorexit</code> 指令用于释放锁。每个对象都有一个监视器锁（monitor），当线程执行到 <code>monitorenter</code> 指令时，会尝试获取对象的监视器锁，如果获取成功，则计数器加一；当线程执行到 <code>monitorexit</code> 指令时，计数器减一。当计数器为 0 时，表示锁已经被释放，其他线程可以获取锁。</li>
</ul>
<h3 id="3-Monitor（监视器）"><a href="#3-Monitor（监视器）" class="headerlink" title="3. Monitor（监视器）"></a>3. Monitor（监视器）</h3><ul>
<li>Monitor 是 Java 中用于实现同步的一种机制，它可以看作是一个特殊的对象，这个对象包含了一个特殊的房间（Entry Set）和一个等待房间（Wait Set）。</li>
<li>当线程尝试获取对象的锁时，它会在 Entry Set 中等待，直到锁被释放。</li>
<li>如果线程在持有锁的过程中因为某些原因被挂起（比如调用了 <code>wait()</code> 方法），那么它会被移到 Wait Set 中，等待其他线程唤醒它（比如调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法）。</li>
<li>Monitor 保证了同一时间只有一个线程可以访问被保护的数据和代码。</li>
</ul>
<h3 id="4-synchronized-的特性"><a href="#4-synchronized-的特性" class="headerlink" title="4. synchronized 的特性"></a>4. synchronized 的特性</h3><ul>
<li><strong>互斥性</strong>：同一时间点，只有一个线程可以获得锁，获得锁的线程才能处理被 <code>synchronized</code> 修饰的代码片段。</li>
<li><strong>阻塞性</strong>：只有获得锁的线程才能执行被 <code>synchronized</code> 修饰的代码片段，未获得锁的线程只能阻塞，等待锁释放。</li>
<li><strong>可重入性</strong>：如果一个线程已经获得锁，在锁未释放之前，再次请求锁的时候，是必然可以获得锁的。这是因为 JVM 会维护一个锁计数器，当同一个线程多次获取锁时，计数器会递增；当释放锁时，计数器会递减，直到计数器为 0 时，锁才会被真正释放。</li>
</ul>
<p>综上所述，<code>synchronized</code> 通过在方法或代码块级别添加同步机制，利用对象的监视器锁来保证线程安全。它是 Java 中实现线程同步的一种简单而有效的手段。</p>
<p><code>synchronized</code> 是 Java 中用于保证线程安全的关键字，它通过一系列的机制来保证原子性、可见性和有序性。下面是对这三个方面的详细解释：</p>
<h2 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>原子性是指一个操作是不可中断的，即该操作要么全部执行，要么全部不执行。在并发编程中，原子性用于保证某个操作在执行过程中不会被其他线程打断。</p>
<p>在 Java 中，<code>synchronized</code> 通过 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令来保证原子性。当一个线程进入 <code>synchronized</code> 修饰的方法或代码块时，它会先尝试获取锁（通过 <code>monitorenter</code> 指令）。如果获取成功，则继续执行后续的代码；如果获取失败（因为锁已被其他线程持有），则该线程会被阻塞，直到锁被释放（通过 <code>monitorexit</code> 指令）为止。</p>
<p>由于 <code>synchronized</code> 保证了同一时间只有一个线程能够持有锁并执行相应的代码，因此它也就保证了这段代码在执行过程中的原子性。即使由于时间片耗尽或其他原因导致线程被中断，只要锁还没有被释放，该线程在下一次获得时间片时仍然会继续执行剩余的代码，直到完成。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。</p>
<p>Java 内存模型（JMM）规定了所有的变量都存储在主内存中，而每个线程都有自己的工作内存（也称为线程本地存储）。线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接读写主内存。这可能导致线程1修改了某个变量的值，但线程2由于还没有从主内存中刷新该变量的副本，因此看不到修改后的值。</p>
<p><code>synchronized</code> 关键字通过确保在进入同步块或同步方法时获取锁，并在退出时释放锁，来实现对变量的可见性保证。具体来说，当一个线程持有锁并执行同步代码块时，它会将自己工作内存中的变量副本更新到主内存中（在写操作时）。当其他线程尝试进入该同步代码块时，它们会先获取锁，并在获取锁后从主内存中读取最新的变量值到自己的工作内存中（在读操作时）。这样，就保证了线程之间对共享变量的可见性。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>有序性是指程序执行的顺序按照代码的先后顺序执行。然而，由于硬件和编译器的优化，指令可能会被重排序以提高性能。这种重排序在单线程环境下通常不会改变程序的执行结果，但在多线程环境下可能会导致问题。</p>
<p>Java 提供了 <code>as-if-serial</code> 语义来确保单线程程序的有序性。该语义要求编译器和处理器在优化时不能改变单线程程序的执行结果。然而，在多线程环境下，<code>as-if-serial</code> 语义并不能完全保证有序性。</p>
<p>为了解决这个问题，<code>synchronized</code> 关键字通过确保同一时间只有一个线程能够执行同步代码块来提供有序性保证。由于同步代码块在同一时间只能被一个线程执行，因此可以认为该代码块内的指令是按照它们在代码中出现的顺序执行的。这避免了由于指令重排序而导致的多线程问题。</p>
<p>总结来说，<code>synchronized</code> 通过确保同一时间只有一个线程能够执行同步代码块来提供原子性、可见性和有序性保证。这些特性使得 <code>synchronized</code> 成为 Java 中实现线程安全的一种重要手段。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>这篇文章的核心内容是介绍了Java中synchronized关键字的锁升级过程，主要包括无锁、偏向锁、轻量级锁和重量级锁四种状态。以下是对这些核心内容的简要概述：</p>
<h3 id="1-无锁状态："><a href="#1-无锁状态：" class="headerlink" title="1.无锁状态："></a>1.无锁状态：</h3><ul>
<li>当一个线程第一次访问一个对象的同步块时，JVM会在对象头中设置该线程的Thread ID，并将对象头的状态位设置为“偏向锁”。</li>
</ul>
<h3 id="2-偏向锁："><a href="#2-偏向锁：" class="headerlink" title="2.偏向锁："></a>2.偏向锁：</h3><ul>
<li>当一个synchronized块被线程首次进入时，锁对象会进入偏向模式。</li>
<li>偏向锁模式下，锁会偏向于第一个获取它的线程，JVM会在对象头中记录该线程的ID作为偏向锁的持有者。</li>
<li>如果其他线程访问该对象，会先检查该对象的偏向锁标识，如果和自己的线程ID相同，则直接获取锁。如果不同，则该对象的锁状态就会升级到轻量级锁状态。</li>
<li>触发条件：首次进入synchronized块时自动开启，假设JVM启动参数没有禁用偏向锁。</li>
<li>注意：在JDK 15中，偏向锁已被废除。</li>
</ul>
<h3 id="3-轻量级锁："><a href="#3-轻量级锁：" class="headerlink" title="3.轻量级锁："></a>3.轻量级锁：</h3><ul>
<li>当有另一个线程尝试获取已被偏向的锁时，偏向锁会被撤销，锁会升级为轻量级锁。</li>
<li>在轻量级锁状态中，JVM为对象头中的Mark Word预留了一部分空间，用于存储指向线程栈中锁记录的指针。</li>
<li>当一个线程尝试获取轻量级锁时，JVM会：<ol>
<li>将对象头中的Mark Word复制到线程栈中的锁记录（Lock Record）。</li>
<li>尝试通过CAS操作更新对象头的Mark Word。</li>
</ol>
</li>
<li>如果替换成功，则该线程获取锁成功；如果失败，则表示已经有其他线程获取了锁，则该锁状态就会升级到重量级锁状态。</li>
<li>触发条件：当有另一个线程尝试获取已被偏向的锁时，偏向锁会升级为轻量级锁。</li>
</ul>
<h3 id="4-重量级锁："><a href="#4-重量级锁：" class="headerlink" title="4.重量级锁："></a>4.重量级锁：</h3><ul>
<li>当轻量级锁的CAS操作失败，即出现了实际的竞争，锁会进一步升级为重量级锁。</li>
<li>当锁状态升级到重量级锁状态时，JVM会将该对象的锁变成一个重量级锁，并在对象头中记录指向等待队列的指针。</li>
<li>如果一个线程想要获取该对象的锁（当前对象已被其他线程锁定时），则需要先进入等待队列，等待该锁被释放。当锁被释放时，JVM会从等待队列中选择一个线程唤醒，并将该线程的状态设置为“就绪”状态，然后等待该线程重新获取该对象的锁。</li>
<li>触发条件：当轻量级锁的CAS操作失败，轻量级锁升级为重量级锁。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/10/%E7%AC%94%E8%AE%B0/Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/10/%E7%AC%94%E8%AE%B0/Stream/" itemprop="url">Stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-10T17:33:00+00:00">
                2024-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h3 id="Stream-API的深入理解"><a href="#Stream-API的深入理解" class="headerlink" title="Stream API的深入理解"></a>Stream API的深入理解</h3><p>Stream API是Java 8中引入的一个关键抽象概念，它允许你以声明性方式处理数据集合（包括数组等）。Stream通过一系列的操作（如筛选、转换、聚合等）来构建复杂的数据处理流水线。</p>
<h4 id="特性及优点详解"><a href="#特性及优点详解" class="headerlink" title="特性及优点详解"></a>特性及优点详解</h4><ol>
<li><p><strong>无存储</strong>：Stream本身不存储数据，它只是数据源的一个视图。这意味着你可以对原始数据集合进行多次Stream操作，而不会改变原始数据。</p>
</li>
<li><p><strong>为函数式编程而生</strong>：Stream API的设计符合函数式编程的范式，它鼓励使用不可变的数据和纯函数（即没有副作用的函数）。这使得代码更加简洁、易于理解和维护。</p>
</li>
<li><p><strong>惰式执行</strong>：Stream上的操作是惰式执行的，这意味着只有在需要结果时才会执行操作。这有助于优化性能，因为它允许Stream API在可能的情况下延迟计算，直到真正需要结果为止。</p>
</li>
<li><p><strong>可消费性</strong>：Stream只能被消费一次，一旦遍历过就会失效。这是为了保持流的不可变性，并防止在多个线程中同时修改流。</p>
</li>
</ol>
<h4 id="关键性操作"><a href="#关键性操作" class="headerlink" title="关键性操作"></a>关键性操作</h4><ul>
<li><p><strong>流的创建</strong>：可以通过集合的<code>stream()</code>或<code>parallelStream()</code>方法、<code>Stream.of()</code>方法或<code>Stream.Builder</code>来创建流。</p>
</li>
<li><p><strong>中间操作</strong>：这些操作会返回一个新的流，并允许你进行链式调用。常见的中间操作包括<code>filter()</code>（筛选）、<code>map()</code>（转换）、<code>flatMap()</code>（扁平化映射）、<code>sorted()</code>（排序）、<code>distinct()</code>（去重）等。</p>
</li>
<li><p><strong>最终操作</strong>：这些操作会触发流的计算，并返回一个结果或副作用。常见的最终操作包括<code>forEach()</code>（遍历）、<code>collect()</code>（收集到集合）、<code>reduce()</code>（归约）、<code>count()</code>（计数）等。</p>
</li>
</ul>
<h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p>你给出的示例很好地展示了Stream API的使用场景。在这个示例中，你首先通过<code>filter()</code>筛选出非红色的球，然后通过<code>map()</code>将它们融化成随机的三角形，再通过另一个<code>filter()</code>筛选出非小的三角形，最后通过某种方式计算出剩余图形的周长。</p>
<p>这个示例展示了如何使用Stream API来构建一个复杂的数据处理流水线，并通过链式调用中间操作和最终操作来得到最终结果。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>Stream API在实际应用中非常有用，特别是在处理大型数据集时。它允许你以声明性方式编写代码，而不需要关心底层实现细节。此外，Stream API还支持并行处理，这使得它能够在多核处理器上更有效地利用计算资源。</p>
<p>总之，Stream API是Java 8中一个非常重要的特性，它极大地提高了Java程序员的生产力，并使得编写高效、简洁和易于维护的代码变得更加容易。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/10/%E7%AC%94%E8%AE%B0/Stream%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/10/%E7%AC%94%E8%AE%B0/Stream%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" itemprop="url">Stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-10T17:33:00+00:00">
                2024-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Stream的并行流是如何实现的"><a href="#Stream的并行流是如何实现的" class="headerlink" title="Stream的并行流是如何实现的"></a>Stream的并行流是如何实现的</h1><h3 id="Stream的并行流是如何实现的？"><a href="#Stream的并行流是如何实现的？" class="headerlink" title="Stream的并行流是如何实现的？"></a>Stream的并行流是如何实现的？</h3><p>在Java中，Stream API提供了一种高效且声明式的方式来处理数据集合。并行流（parallel stream）是Stream API中的一个重要特性，它允许开发者利用多核处理器的并行处理能力来提高数据处理的效率。</p>
<ol>
<li><p><strong>获取并行流</strong>：</p>
<ul>
<li>使用<code>Collection</code>接口的<code>parallelStream</code>方法，或者通过<code>Stream</code>接口的<code>parallel</code>方法将顺序流转换为并行流。</li>
</ul>
</li>
<li><p><strong>底层实现</strong>：</p>
<ul>
<li>并行流底层使用了Java 7中引入的Fork&#x2F;Join框架。</li>
<li>Fork&#x2F;Join框架旨在将一个大任务分割（fork）成多个小任务，这些小任务可以并行执行，然后再将这些小任务的结果合并（join）成最终结果。</li>
<li>这种分治策略非常适合处理可以递归分解的大规模计算任务。</li>
</ul>
</li>
<li><p><strong>执行方式</strong>：</p>
<ul>
<li>并行流通过并发运行的方式执行流的迭代及操作，从而充分利用多核处理器的性能。</li>
</ul>
</li>
</ol>
<h3 id="ForkJoinPool和ThreadPoolExecutor的区别"><a href="#ForkJoinPool和ThreadPoolExecutor的区别" class="headerlink" title="ForkJoinPool和ThreadPoolExecutor的区别"></a>ForkJoinPool和ThreadPoolExecutor的区别</h3><p>ForkJoinPool和ThreadPoolExecutor都是Java中用于管理线程和并行任务的工具，但它们在实现方式和适用场景上有所不同。</p>
<ol>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li><strong>ForkJoinPool</strong>：基于工作窃取（Work-Stealing）算法实现的线程池。它适用于处理可以递归分解的大规模计算任务。每个线程都有自己的双端队列（deque）来存储任务，当某个线程的任务队列为空时，它会从其他线程的队列中窃取任务来执行。</li>
<li><strong>ThreadPoolExecutor</strong>：基于任务队列和线程池的实现。它适用于处理不同类型的任务，包括计算密集型、IO密集型和混合型任务。ThreadPoolExecutor允许更灵活的任务调度和线程管理。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>ForkJoinPool</strong>：更适合处理可以递归分解的大规模计算任务，如排序、归并、搜索等。</li>
<li><strong>ThreadPoolExecutor</strong>：适用于更广泛的场景，包括异步执行、定时执行和周期性执行等。</li>
</ul>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li>ForkJoinPool通过工作窃取算法来减少线程之间的空闲时间，提高CPU利用率，但在任务划分不均衡时可能导致线程饥饿。</li>
<li>ThreadPoolExecutor的性能取决于任务类型、线程数量和任务队列的配置。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Stream的并行流是Java中处理大规模数据集合的高效工具，它底层使用了Fork&#x2F;Join框架来实现并行处理。而ForkJoinPool和ThreadPoolExecutor则是Java中用于管理线程和并行任务的两种不同实现方式，它们在实现方式、适用场景和性能上有所不同。开发者应根据具体的应用场景和需求选择合适的工具来优化程序的性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/01/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/01/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url">微服务教程笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-01T13:33:41+00:00">
                2024-09-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CouponType-枚举类"><a href="#CouponType-枚举类" class="headerlink" title="CouponType 枚举类"></a>CouponType 枚举类</h1><pre><code>public static CouponType convert(String code) &#123;
    return Stream.of(values())
    .filter(bean -&gt; bean.code.equalsIgnoreCase(code))
    .findFirst()
    .orElse(UNKNOWN);
&#125;
</code></pre>
<ul>
<li><p>使用Long表示金额，金额通常以分为单位，比如100代表100分，比使用Double转 BigDecimal 有效</p>
</li>
<li><p>JPA支持一对多、多对多的级联关系，但是过深的级联层级带来的DB层压力可能在洪峰流量下太大，所以尽量减少级联配置，用单表查询取代；如果一个查询需要join多张表，最好的做法是通过重构业务逻辑来简化DB查询的复杂度；</p>
</li>
</ul>
<p>思考：java动态更新枚举类；</p>
<ul>
<li>stream 根据门店分组计算每个门店下商品价格（key&#x3D;shopId，value&#x3D;门店商品总价）<br>  public Map&lt;String,Long&gt; getTotal(List<Product> products){<br>  Map&lt;String, Long&gt; collect &#x3D; products.stream()<br>          .collect(Collectors.groupingBy(x -&gt; x.getProductId(),<br>                  Collectors.summingLong(x -&gt; x.getPrice() * x.getCount()))<br>          );<br>  return collect;<br>  }</Product></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/02/22/%E9%9D%A2%E8%AF%95%E9%A2%98/InnoDB%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/02/22/%E9%9D%A2%E8%AF%95%E9%A2%98/InnoDB%E5%BC%95%E6%93%8E%E7%9A%844%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F/" itemprop="url">InnoDB引擎的4大特性？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-02-22T13:33:41+00:00">
                2024-02-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌InnoDB引擎的4大特性？"><a href="#👌InnoDB引擎的4大特性？" class="headerlink" title="👌InnoDB引擎的4大特性？"></a>👌InnoDB引擎的4大特性？</h1><p><strong>插入缓冲（insert buffer)</strong></p>
<p>插入缓冲（Insert Buffer&#x2F;Change Buffer）：提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效</p>
<p>只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。</p>
<p><strong>二次写(double write)</strong></p>
<p>Doublewrite缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从innodb buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入</p>
<p>在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write。</p>
<p><strong>自适应哈希索引(Adaptive Hash index)</strong></p>
<p>Adaptive Hash index属性使得InnoDB更像是内存数据库。该属性通过innodb_adapitve_hash_index开启，也可以通过—skip-innodb_adaptive_hash_index参数关闭；</p>
<p>Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升</p>
<p>经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。哈希（hash）是一种非常快的等值查找方法，在一般情况下这种查找的时间复杂度为O(1)，即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般3-4层，故需要3-4次的查询。</p>
<p>innodb会监控对表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI有一个要求，就是对这个页的连续访问模式必须是一样的。</p>
<p><strong>预读(read ahead)</strong></p>
<p>InnoDB使用两种预读算法来提高I&#x2F;O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）为了区分这两种预读的方式，我们可以把线性预读放到以extent为单位，而随机预读放到以extent中的page为单位。线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。</p>
<p>（1）线性预读（linear read-ahead）</p>
<p>方式有一个很重要的变量控制是否将下一个extent预读到buffer pool中，通过使用配置参数innodb_read_ahead_threshold，可以控制Innodb执行预读操作的时间。如果一个extent中的被顺序读取的page超过或者等于该参数变量时，Innodb将会异步的将下一个extent读取到buffer pool中，innodb_read_ahead_threshold可以设置为0-64的任何值，默认值为56，值越高，访问模式检查越严格例如，如果将值设置为48，则InnoDB只有在顺序访问当前extent中的48个pages时才触发线性预读请求，将下一个extent读到内存中。如果值为8，InnoDB触发异步预读，即使程序段中只有8页被顺序访问。你可以在MySQL配置文件中设置此参数的值，或者使用SET GLOBAL需要该SUPER权限的命令动态更改该参数。在没有该变量之前，当访问到extent的最后一个page的时候，Innodb会决定是否将下一个extent放入到buffer pool中。</p>
<p>（2）随机预读（randomread-ahead）</p>
<p>随机预读方式则是表示当同一个extent中的一些page在buffer pool中发现时，Innodb会将该extent中的剩余page一并读到buffer pool中，由于随机预读方式给Innodb code带来了一些不必要的复杂性，同时在性能也存在不稳定性，在5.5中已经将这种预读方式废弃。要启用此功能，请将配置变量设置innodb_random_read_ahead为ON。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/02/22/%E9%9D%A2%E8%AF%95%E9%A2%98/MVCC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/02/22/%E9%9D%A2%E8%AF%95%E9%A2%98/MVCC%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/" itemprop="url">MVCC解决的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-02-22T13:33:41+00:00">
                2024-02-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:18+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌MVCC解决了什么问题？"><a href="#👌MVCC解决了什么问题？" class="headerlink" title="👌MVCC解决了什么问题？"></a>👌MVCC解决了什么问题？</h1><h3 id="1-提高并发性"><a href="#1-提高并发性" class="headerlink" title="1.提高并发性"></a>1.<strong>提高并发性</strong></h3><p>MVCC 允许多个事务同时执行读写操作，而无需互相阻塞或等待。这极大地提高了数据库的并发处理能力，特别是在高并发环境中。</p>
<h3 id="2-减少锁争用"><a href="#2-减少锁争用" class="headerlink" title="2.减少锁争用"></a>2.<strong>减少锁争用</strong></h3><p>在传统的锁机制中，读写操作需要加锁，容易导致锁争用和死锁问题。MVCC 通过版本控制，使得读取操作不需要加锁，从而减少了锁争用的频率。</p>
<h3 id="3-提供一致性视图"><a href="#3-提供一致性视图" class="headerlink" title="3.提供一致性视图"></a>3.<strong>提供一致性视图</strong></h3><p>MVCC 为每个事务提供一个一致性的快照视图，使得事务在执行过程中看到的数据是固定的，不会受到其他并发事务的影响。这简化了应用程序的开发，因为开发者无需担心数据在事务执行过程中发生变化。</p>
<h3 id="4-避免读写冲突"><a href="#4-避免读写冲突" class="headerlink" title="4.避免读写冲突"></a>4.<strong>避免读写冲突</strong></h3><p>在 MVCC 中，读操作不会阻塞写操作，写操作也不会阻塞读操作。这避免了读写冲突，提高了系统的整体性能和响应速度。</p>
<h3 id="5-减少死锁"><a href="#5-减少死锁" class="headerlink" title="5.减少死锁"></a>5.<strong>减少死锁</strong></h3><p>由于读操作不需要加锁，MVCC 减少了死锁的可能性。死锁通常发生在多个事务互相等待资源释放的情况下，而 MVCC 的无锁读操作减少了这种情况发生的机会。</p>
<h3 id="6-提高读性能"><a href="#6-提高读性能" class="headerlink" title="6.提高读性能"></a>6.<strong>提高读性能</strong></h3><p>MVCC 提供了无锁的读操作，读操作直接读取数据的快照版本，不需要等待其他事务完成。这极大地提高了读操作的性能，尤其是在读操作频繁的场景下。</p>
<h3 id="7-实现更高的隔离级别"><a href="#7-实现更高的隔离级别" class="headerlink" title="7.实现更高的隔离级别"></a>7.<strong>实现更高的隔离级别</strong></h3><p>MVCC 支持实现更高的隔离级别，如快照隔离（Snapshot Isolation），在这种隔离级别下，事务可以看到一个一致的快照视图，同时避免了脏读和不可重复读等问题。</p>
<p>假设有一个银行账户表accounts：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| id | balance|</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 1000   |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<h4 id="场景-1：高并发读写"><a href="#场景-1：高并发读写" class="headerlink" title="场景 1：高并发读写"></a>场景 1：高并发读写</h4><ul>
<li>事务 A：读取账户余额</li>
<li>事务 B：更新账户余额</li>
</ul>
<p>在传统的锁机制下，事务 A 和事务 B 可能会互相阻塞。然而在 MVCC 中：</p>
<ol>
<li>事务 A 开始，读取balance &#x3D; 1000。</li>
<li>事务 B 开始，更新balance为 1200。</li>
<li>事务 A 继续读取，仍然看到balance &#x3D; 1000。</li>
<li>事务 B 提交后，新的事务可以看到balance &#x3D; 1200。</li>
</ol>
<p>这种情况下，事务 A 和事务 B 可以并发执行，互不影响。</p>
<h4 id="场景-2：避免读写冲突"><a href="#场景-2：避免读写冲突" class="headerlink" title="场景 2：避免读写冲突"></a>场景 2：避免读写冲突</h4><ul>
<li>事务 C：读取账户余额</li>
<li>事务 D：更新账户余额</li>
</ul>
<p>在 MVCC 中：</p>
<ol>
<li>事务 C 开始，读取balance &#x3D; 1000。</li>
<li>事务 D 开始，更新balance为 1500。</li>
<li>事务 D 提交后，新的事务可以看到balance &#x3D; 1500。</li>
<li>事务 C 继续读取，仍然看到balance &#x3D; 1000。</li>
</ol>
<h2 id="MVCC，读写并发，读写不冲突（读不加锁，读写不冲突）"><a href="#MVCC，读写并发，读写不冲突（读不加锁，读写不冲突）" class="headerlink" title="MVCC，读写并发，读写不冲突（读不加锁，读写不冲突）"></a>MVCC，读写并发，读写不冲突（读不加锁，读写不冲突）</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2022/07/31/maven/dependencyManagement%E4%B8%8Edependencies%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/31/maven/dependencyManagement%E4%B8%8Edependencies%E7%9A%84%E5%8C%BA%E5%88%AB/" itemprop="url">dependencyManagement与dependencies的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-31T13:33:41+00:00">
                2022-07-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>dependencyManagement<ul>
<li>用于父类的管理，一般写在顶层父类的pom.xml中</li>
<li>只是做声明依赖，不做具体引入，只有在子项目中使用到是才会实现依赖</li>
<li>子类声明了version，就用子类自己的，否则都继承父类的version和scope</li>
</ul>
</li>
<li>dependencies<ul>
<li>默认被子类全部继承</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2022/07/31/%E5%9F%BA%E7%A1%80/%E6%97%A5%E6%9C%9F%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/31/%E5%9F%BA%E7%A1%80/%E6%97%A5%E6%9C%9F%E7%B1%BB/" itemprop="url">日期类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-31T13:33:41+00:00">
                2022-07-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-17T09:14:17+00:00">
                2025-03-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new Date());</span><br><span class="line">System.out.println(new Date().getTime());</span><br><span class="line">System.out.println(new DateTime());</span><br><span class="line">System.out.println(new LocalDate());</span><br><span class="line">Mon May 30 11:18:29 CST 2022</span><br><span class="line">1653880709973</span><br><span class="line">2022-05-30 11:18:29</span><br><span class="line">2022-05-30</span><br><span class="line">Mysql数据库存储日期dateTime（年月日时分秒）</span><br><span class="line">Mysql数据库存储日期date（年月日）</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">132</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
