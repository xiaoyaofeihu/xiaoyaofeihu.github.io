<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/page/3/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/page/3/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/04/JVM/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/04/JVM/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌jvm垃圾回收算法有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-04T13:33:41+00:00">
                2025-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm垃圾回收算法有哪些？"><a href="#👌jvm垃圾回收算法有哪些？" class="headerlink" title="👌jvm垃圾回收算法有哪些？"></a>👌jvm垃圾回收算法有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>垃圾回收算法的核心在于解决两个问题：一是确定哪些对象能够被回收（引用计数法、可达性分析法），二是如何回收这些对象。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法（Reference Counting）是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。</p>
<p>当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>可达性分析算法是JVM垃圾回收中的一种算法，它通过分析对象的引用关系，判断对象是否可达，从而决定对象是否可以被回收。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>垃圾收集器首先遍历对象图，标记所有可达的对象，然后清除未标记的对象。简单直接，不需要移动对象。但是会产生内存碎片，可能导致大对象分配失败。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>在标记阶段标记所有可达的对象后，压缩阶段将存活的对象移动到内存的一端，整理出连续的可用内存空间。这种方式消除了内存碎片问题。但是对象移动需要额外的时间和资源。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>将内存分为两个相等的区域，每次只使用其中一个。当这个区域使用完时，将存活的对象复制到另一个区域，然后清空当前区域。这种方式简单高效，没有内存碎片问题。缺点就是需要双倍的内存空间。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象的生命周期将堆内存划分为几代（通常是新生代和老年代），新生代使用复制算法，老年代使用标记-整理或标记-清除算法。优化了垃圾收集性能，因为大部分对象在新生代被收集，减少了老年代的垃圾收集频率。不过需要额外的内存管理和调优。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>将堆内存划分为多个小的独立区域（Region），每个区域可以独立进行垃圾收集。这种方式提高了内存管理的灵活性和效率，适用于大堆内存的应用。缺点是实现较复杂，需要精细的内存管理。</p>
<h3 id="具体垃圾收集器使用的算法"><a href="#具体垃圾收集器使用的算法" class="headerlink" title="具体垃圾收集器使用的算法"></a>具体垃圾收集器使用的算法</h3><p><strong>Serial GC</strong>：使用标记-整理算法。</p>
<p><strong>Parallel GC</strong>：新生代使用复制算法，老年代使用标记-整理算法。</p>
<p><strong>CMS GC</strong>：新生代使用复制算法，老年代使用标记-清除算法，并发标记和清除。</p>
<p><strong>G1 GC</strong>：分区算法，结合标记-整理和复制算法。</p>
<p><strong>ZGC</strong>：分区算法，使用染色指针和读屏障技术，实现并发标记和压缩。</p>
<p><strong>Shenandoah GC</strong>：分区算法，使用并发标记和并发压缩技术。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/Java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/Java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA_/" itemprop="url">👌Java类初始化时机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java类初始化时机"><a href="#👌Java类初始化时机" class="headerlink" title="👌Java类初始化时机?"></a>👌Java类初始化时机?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>当使用new关键字创建类的实例时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>

<h3 id="访问类的静态变量或静态方法"><a href="#访问类的静态变量或静态方法" class="headerlink" title="访问类的静态变量或静态方法"></a>访问类的静态变量或静态方法</h3><p>当访问类的静态变量或调用静态方法时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MyClass.staticVar);</span><br><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过反射 API 对类进行反射调用时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="初始化子类"><a href="#初始化子类" class="headerlink" title="初始化子类"></a>初始化子类</h3><p>当初始化一个类的子类时，父类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child = new Child(); // 输出：Parent initialized, Child initialized</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-虚拟机启动时"><a href="#Java-虚拟机启动时" class="headerlink" title="Java 虚拟机启动时"></a>Java 虚拟机启动时</h3><p>包含main方法的类在虚拟机启动时会被初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Main class initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><h3 id="通过子类引用父类的静态字段"><a href="#通过子类引用父类的静态字段" class="headerlink" title="通过子类引用父类的静态字段"></a>通过子类引用父类的静态字段</h3><p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static int value = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Child.value); // 输出：42，不会触发 Child 的初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义对象数组"><a href="#定义对象数组" class="headerlink" title="定义对象数组"></a>定义对象数组</h3><p>定义类的对象数组不会触发类的初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass[] array = newMyClass[10]; // 不会触发 MyClass 的初始化</span><br></pre></td></tr></table></figure>

<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>引用常量不会触发类的初始化，因为常量在编译阶段会存入调用类的常量池中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    static final int CONSTANT = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyClass.CONSTANT); // 不会触发 MyClass 的初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/" itemprop="url">👌Java类加载器的机制是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java类加载器的机制是什么"><a href="#👌Java类加载器的机制是什么" class="headerlink" title="👌Java类加载器的机制是什么?"></a>👌Java类加载器的机制是什么?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 的类加载机制是 JVM 负责将类文件加载到内存中，并将其转换为Class对象的过程。它包括三个主要步骤：加载（Loading）、链接（Linking）和初始化（Initialization）。以下是详细的描述：</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载阶段是将类文件读入内存，并创建一个Class对象的过程。具体步骤如下：</p>
<p><strong>查找和导入类的二进制数据</strong>：从不同的来源（如文件系统、网络等）获取类的字节码。</p>
<p><strong>创建Class对象</strong>：将字节码转换为 JVM 能够识别的Class对象。</p>
<p>加载阶段可以通过系统类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）等完成。</p>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><p>链接阶段将类的二进制数据合并到 JVM 运行时环境中。链接阶段包括三个步骤：</p>
<p><strong>验证（Verification）</strong>：确保类的字节码符合 JVM 规范，保证不会破坏 JVM 的安全性。</p>
<p><strong>准备（Preparation）</strong>：为类的静态变量分配内存，并将其初始化为默认值。</p>
<p><strong>解析（Resolution）</strong>：将常量池中的符号引用转换为直接引用。</p>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><p>初始化阶段是执行类构造器<clinit>方法的过程。该方法是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块（static {}）中的语句合并产生的。初始化阶段是类加载过程的最后一步。</clinit></p>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>Java 的类加载器负责加载类文件。Java 中的类加载器遵循双亲委派模型（Parent Delegation Model），即类加载器在加载类时会先委托给父类加载器加载，如果父类加载器无法加载，再尝试自己加载。</p>
<h3 id="双亲委派模型（Parent-Delegation-Model）"><a href="#双亲委派模型（Parent-Delegation-Model）" class="headerlink" title="双亲委派模型（Parent Delegation Model）"></a>双亲委派模型（Parent Delegation Model）</h3><p>双亲委派模型的工作流程如下：</p>
<ol>
<li><strong>检查缓存</strong>：类加载器首先检查缓存中是否已经加载过该类，如果已经加载，则直接返回Class对象。</li>
<li><strong>委托父类加载</strong>：如果缓存中没有，则委托父类加载器加载。</li>
<li><strong>父类加载失败</strong>：如果父类加载器加载失败（抛出ClassNotFoundException），则由当前类加载器尝试加载。</li>
</ol>
<p>这种模型的好处是避免类的重复加载，确保核心类库不会被自定义类加载器加载和覆盖。</p>
<h3 id="常见的类加载器"><a href="#常见的类加载器" class="headerlink" title="常见的类加载器"></a>常见的类加载器</h3><p><strong>Bootstrap ClassLoader</strong>：引导类加载器，负责加载核心类库，如rt.jar中的类。它是用原生代码实现的，不是java.lang.ClassLoader的子类。</p>
<p><strong>Extension ClassLoader</strong>：扩展类加载器，负责加载JAVA_HOME&#x2F;lib&#x2F;ext目录中的类。</p>
<p><strong>Application ClassLoader</strong>：应用程序类加载器，负责加载应用程序的类路径（classpath）中的类。</p>
<h2 id="类加载器的示例"><a href="#类加载器的示例" class="headerlink" title="类加载器的示例"></a>类加载器的示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在路径</span><br><span class="line">            MyClassLoader classLoader = new MyClassLoader(&quot;/path/to/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/jvm%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/jvm%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F/" itemprop="url">👌新生代空间大小的比例及如何调整？？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-新生代空间大小的比例及如何调整？"><a href="#👌jvm-新生代空间大小的比例及如何调整？" class="headerlink" title="👌jvm 新生代空间大小的比例及如何调整？"></a>👌jvm 新生代空间大小的比例及如何调整？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，堆内存通常被划分为新生代（Young Generation）和老年代（Old Generation）。新生代又进一步划分为 Eden 区和两个 Survivor 区（S0 和 S1）。调整新生代空间大小的主要目的是优化垃圾收集性能，减少应用程序的停顿时间。</p>
<h2 id="新生代空间的默认比例"><a href="#新生代空间的默认比例" class="headerlink" title="新生代空间的默认比例"></a>新生代空间的默认比例</h2><p>默认情况下，HotSpot JVM 使用的比例大致如下：</p>
<p><strong>新生代（Young Generation）</strong>：占整个堆内存的 1&#x2F;3 到 1&#x2F;4 左右。</p>
<p><strong>老年代（Old Generation）</strong>：占整个堆内存的 2&#x2F;3 到 3&#x2F;4 左右。</p>
<p>在新生代内部，默认的比例是：</p>
<p><strong>Eden 区</strong>：占新生代的 8&#x2F;10（即 80%）。</p>
<p><strong>每个 Survivor 区（S0 和 S1）</strong>：各占新生代的 1&#x2F;10（即 10%）。</p>
<h2 id="新生代空间大小的调整"><a href="#新生代空间大小的调整" class="headerlink" title="新生代空间大小的调整"></a>新生代空间大小的调整</h2><h3 id="调整新生代和老年代的比例"><a href="#调整新生代和老年代的比例" class="headerlink" title="调整新生代和老年代的比例"></a>调整新生代和老年代的比例</h3><p><strong>-Xms和-Xmx</strong>：设置堆内存的初始大小和最大大小。</p>
<p><strong>-XX:NewSize和-XX:MaxNewSize</strong>：设置新生代的初始大小和最大大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=512m</span><br><span class="line">-XX:MaxNewSize=512m</span><br></pre></td></tr></table></figure>

<p><strong>-XX:NewRatio</strong>：设置新生代和老年代的比例。例如，-XX:NewRatio&#x3D;3 表示新生代占整个堆的 1&#x2F;4，老年代占 3&#x2F;4。</p>
<h3 id="调整-Eden-区和-Survivor-区的比例"><a href="#调整-Eden-区和-Survivor-区的比例" class="headerlink" title="调整 Eden 区和 Survivor 区的比例"></a>调整 Eden 区和 Survivor 区的比例</h3><p><strong>-XX:SurvivorRatio</strong>：设置 Eden 区和 Survivor 区的比例。例如，-XX:SurvivorRatio&#x3D;8表示 Eden 区占新生代的 8&#x2F;10，每个 Survivor 区占 1&#x2F;10。</p>
<h3 id="调整-Survivor-区的数量"><a href="#调整-Survivor-区的数量" class="headerlink" title="调整 Survivor 区的数量"></a>调整 Survivor 区的数量</h3><p><strong>-XX:SurvivorRatio</strong>：默认情况下，JVM 使用两个 Survivor 区（S0 和 S1）。你可以通过调整 Survivor 区的比例来优化内存使用和垃圾收集性能。</p>
<h3 id="动态调整新生代大小"><a href="#动态调整新生代大小" class="headerlink" title="动态调整新生代大小"></a>动态调整新生代大小</h3><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小策略，JVM 会根据应用程序的运行情况动态调整新生代和老年代的大小。</p>
<h2 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h2><p>在调整新生代空间大小时，需要考虑以下因素：</p>
<p><strong>应用程序的对象生命周期</strong>：</p>
<p>如果应用程序创建了大量短生命周期对象（例如 Web 应用中的请求对象），则需要较大的新生代空间，以减少 Minor GC 的频率。</p>
<p>如果应用程序有较多长生命周期对象，则需要较大的老年代空间，以减少 Major GC 的频率。</p>
<p><strong>GC 日志分析</strong>：</p>
<p>启用 GC 日志（例如-Xlog:gc*或-XX:+PrintGCDetails），分析垃圾收集的频率和停顿时间，调整新生代和老年代的大小以优化性能。</p>
<p><strong>性能测试</strong>：</p>
<p>在调整 JVM 参数后，进行性能测试，观察 GC 行为和应用程序的响应时间，进一步调整参数以达到最佳性能。</p>
<h2 id="配置-demo"><a href="#配置-demo" class="headerlink" title="配置 demo"></a>配置 demo</h2><p>假设你有一个堆内存大小为 4GB 的 JVM 实例，你希望新生代占 1GB，老年代占 3GB，并且 Eden 区占新生代的 80%，每个 Survivor 区占 10%。可以使用如下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms4g -Xmx4g</span><br><span class="line">-XX:NewSize=1g </span><br><span class="line">-XX:MaxNewSize=1g</span><br><span class="line">-XX:NewRatio=3</span><br><span class="line">-XX:SurvivorRatio=8</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/qd6qd8z80xv9420a">https://www.yuque.com/jingdianjichi/xyxdsi/qd6qd8z80xv9420a</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8_/" itemprop="url">👌Java双亲委派机制的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java双亲委派机制的作用"><a href="#👌Java双亲委派机制的作用" class="headerlink" title="👌Java双亲委派机制的作用?"></a>👌Java双亲委派机制的作用?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="保证-Java-核心库的安全性"><a href="#保证-Java-核心库的安全性" class="headerlink" title="保证 Java 核心库的安全性"></a>保证 Java 核心库的安全性</h2><p>通过双亲委派机制，Java 核心库（如java.lang.Object等）由启动类加载器（Bootstrap ClassLoader）加载。由于启动类加载器是在 JVM 启动时由本地代码实现的，并且它加载的类路径是固定的系统核心库路径，因此可以确保这些核心类不会被篡改或替换。这样系统的安全性和稳定性得到了保障。</p>
<h2 id="避免类的重复加载"><a href="#避免类的重复加载" class="headerlink" title="避免类的重复加载"></a>避免类的重复加载</h2><p>双亲委派机制确保了每个类只会被加载一次。如果一个类已经被父类加载器加载过，那么子类加载器就不会再重复加载这个类。这样可以避免类的重复加载，提高类加载的效率，并减少内存消耗。</p>
<h2 id="保证类加载的一致性"><a href="#保证类加载的一致性" class="headerlink" title="保证类加载的一致性"></a>保证类加载的一致性</h2><p>通过双亲委派机制，可以确保同一个类在整个 JVM 中只有一个定义。这样可以避免类的冲突和不一致问题。例如，如果应用程序和第三方库中都定义了一个相同的类名，通过双亲委派机制可以确保最终加载的是位于更高层次的类加载器中的类，从而避免冲突。</p>
<h2 id="提高类加载的效率"><a href="#提高类加载的效率" class="headerlink" title="提高类加载的效率"></a>提高类加载的效率</h2><p>双亲委派机制通过将类加载请求逐级向上委派，可以利用已经加载的类，提高类加载的效率。父类加载器在加载类时，如果该类已经被加载过，那么直接返回该类的引用，从而减少了重复加载的开销。</p>
<h2 id="支持动态扩展"><a href="#支持动态扩展" class="headerlink" title="支持动态扩展"></a>支持动态扩展</h2><p>双亲委派机制允许在不同的类加载器中加载不同的类，从而支持动态扩展。例如，应用程序类加载器（Application ClassLoader）可以加载应用程序特定的类，而扩展类加载器（Extension ClassLoader）可以加载扩展库中的类，这样可以方便地进行动态扩展和模块化开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%BB%93%E6%9D%9F_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%BB%93%E6%9D%9F_/" itemprop="url">👌Java虚拟机进程何时结束</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java虚拟机进程何时结束"><a href="#👌Java虚拟机进程何时结束" class="headerlink" title="👌Java虚拟机进程何时结束?"></a>👌Java虚拟机进程何时结束?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="所有非守护线程（Non-Daemon-Threads）结束"><a href="#所有非守护线程（Non-Daemon-Threads）结束" class="headerlink" title="所有非守护线程（Non-Daemon Threads）结束"></a>所有非守护线程（Non-Daemon Threads）结束</h2><p>JVM 进程会在所有非守护线程结束后自动退出。非守护线程是默认的线程类型，通常用于执行主要任务。守护线程（Daemon Thread）则是辅助线程，通常用于执行后台任务，例如垃圾回收。</p>
<p><strong>非守护线程</strong>：主要任务线程，JVM 会等待其执行完毕。</p>
<p><strong>守护线程</strong>：辅助任务线程，JVM 不会等待其执行完毕。</p>
<p>当所有非守护线程都结束时，JVM 会自动退出，即使还有守护线程在运行。</p>
<h2 id="调用System-exit-int-status"><a href="#调用System-exit-int-status" class="headerlink" title="调用System.exit(int status)"></a>调用System.exit(int status)</h2><p>可以通过调用System.exit(int status)方法来显式终止 JVM 进程。status参数是一个整数，通常用于表示退出状态码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExitExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Program is exiting&quot;);</span><br><span class="line">        System.exit(0); // 正常退出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.exit(0)：表示正常退出。非零状态码：表示异常退出。</p>
<h2 id="JVM-遇到未捕获的异常或错误"><a href="#JVM-遇到未捕获的异常或错误" class="headerlink" title="JVM 遇到未捕获的异常或错误"></a>JVM 遇到未捕获的异常或错误</h2><p>如果主线程或其他非守护线程中出现未捕获的异常或错误，且没有相应的异常处理机制，JVM 进程会终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UncaughtExceptionExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Uncaught exception&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过外部命令强制终止"><a href="#通过外部命令强制终止" class="headerlink" title="通过外部命令强制终止"></a>通过外部命令强制终止</h2><p>可以使用操作系统的命令或工具强制终止 JVM 进程，例如使用kill命令（在 Unix&#x2F;Linux 系统上）或任务管理器（在 Windows 系统上）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找 JVM 进程 ID</span><br><span class="line">ps -ef | grep java</span><br><span class="line"></span><br><span class="line"># 强制终止 JVM 进程</span><br><span class="line">kill -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="主线程结束且没有其他非守护线程"><a href="#主线程结束且没有其他非守护线程" class="headerlink" title="主线程结束且没有其他非守护线程"></a>主线程结束且没有其他非守护线程</h2><p>如果主线程结束且没有其他非守护线程在运行，JVM 进程也会结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MainThreadExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Main thread is ending&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用Runtime-halt-int-status"><a href="#调用Runtime-halt-int-status" class="headerlink" title="调用Runtime.halt(int status)"></a>调用Runtime.halt(int status)</h2><p>Runtime.halt(int status)方法会立即终止 JVM 进程，不执行任何关闭钩子（Shutdown Hook）或finalize方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HaltExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime.getRuntime().halt(0); // 立即终止 JVM</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭钩子（Shutdown-Hook）"><a href="#关闭钩子（Shutdown-Hook）" class="headerlink" title="关闭钩子（Shutdown Hook）"></a>关闭钩子（Shutdown Hook）</h2><p>在 JVM 进程结束前，可以注册关闭钩子来执行一些清理操作。关闭钩子是在 JVM 关闭前执行的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ShutdownHookExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;Shutdown hook is running&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Main thread is ending&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/" itemprop="url">👌java双亲委派机制是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌java双亲委派机制是什么"><a href="#👌java双亲委派机制是什么" class="headerlink" title="👌java双亲委派机制是什么?"></a>👌java双亲委派机制是什么?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的双亲委派机制是一种类加载机制，用于确保 Java 类加载过程的安全性和一致性。它的主要思想是：每个类加载器在加载类时，首先将请求委派给父类加载器，只有当父类加载器无法完成加载时，才由当前类加载器尝试加载类。</p>
<p><img src="/2025/05/02/JVM/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/NoYLGZ3O7K1yv5z_/1725898211982-d09b6999-76ec-4ab2-9720-b89c0a8fc87f-847285.png" alt="1725898211982-d09b6999-76ec-4ab2-9720-b89c0a8fc87f.png"></p>
<h2 id="双亲委派机制的工作流程"><a href="#双亲委派机制的工作流程" class="headerlink" title="双亲委派机制的工作流程"></a>双亲委派机制的工作流程</h2><p><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载 Java 核心库（位于JAVA_HOME&#x2F;lib目录下的类库，如rt.jar）。</p>
<p><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载 Java 扩展库（位于JAVA_HOME&#x2F;lib&#x2F;ext目录下的类库）。</p>
<p><strong>应用程序类加载器（Application ClassLoader）</strong>：负责加载应用程序类路径（classpath）上的类。</p>
<p>加载类的具体步骤如下：</p>
<ol>
<li><strong>当前类加载器收到类加载请求</strong>：当一个类加载器收到加载类的请求时，它不会立即尝试加载该类。</li>
<li><strong>将请求委派给父类加载器</strong>：当前类加载器首先将加载请求委派给父类加载器。</li>
<li><strong>父类加载器处理请求</strong>：</li>
</ol>
<p>如果父类加载器存在，则父类加载器会继续将请求向上委派，直到到达启动类加载器。启动类加载器尝试加载类，如果成功，则返回类的引用。</p>
<ol start="4">
<li><strong>父类加载器无法加载类</strong>：如果启动类加载器无法加载该类，加载失败返回到子类加载器。</li>
<li><strong>当前类加载器尝试加载类</strong>：如果父类加载器无法加载该类，则由当前类加载器尝试加载。</li>
</ol>
<p>通过这种机制，可以确保核心类库不会被篡改，避免了类的重复加载和类的冲突问题。</p>
<h2 id="双亲委派机制的优点"><a href="#双亲委派机制的优点" class="headerlink" title="双亲委派机制的优点"></a>双亲委派机制的优点</h2><p><strong>安全性</strong>：通过将类加载请求逐级向上委派，可以避免核心类库被篡改或替换，确保系统安全。</p>
<p><strong>避免类的重复加载</strong>：确保每个类只被加载一次，避免类的重复加载和类的冲突问题。</p>
<p><strong>提高加载效率</strong>：通过委派机制，可以利用已经加载的类，提高类加载的效率。</p>
<h2 id="双亲委派机制的例外"><a href="#双亲委派机制的例外" class="headerlink" title="双亲委派机制的例外"></a>双亲委派机制的例外</h2><p>尽管双亲委派机制是 Java 类加载的标准机制，但在某些情况下，这一机制会被打破。例如：</p>
<p><strong>自定义类加载器</strong>：某些自定义类加载器可能会覆盖默认的双亲委派机制，直接加载类。</p>
<p><strong>OSGi 框架</strong>：OSGi 框架中，类加载机制更加复杂，可能会打破双亲委派机制。</p>
<p><strong>SPI（Service Provider Interface）</strong>：在某些服务提供者接口的实现中，可能需要打破双亲委派机制来加载服务实现类。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_/" itemprop="url">👌jvm 运行时的数据区域如何理解?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-运行时的数据区域如何理解"><a href="#👌jvm-运行时的数据区域如何理解" class="headerlink" title="👌jvm 运行时的数据区域如何理解?"></a>👌jvm 运行时的数据区域如何理解?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 虚拟机（JVM）在运行时将内存划分为若干不同的数据区域，每个区域都有特定的用途。</p>
<p><img src="/2025/05/02/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_/2SSdo9L3kmTfJk6j/1725852039025-ee339bb3-3b55-4c11-a3a7-23d21fd77305-189789.png" alt="1725852039025-ee339bb3-3b55-4c11-a3a7-23d21fd77305.png"></p>
<h2 id="JVM-运行时数据区域"><a href="#JVM-运行时数据区域" class="headerlink" title="JVM 运行时数据区域"></a>JVM 运行时数据区域</h2><p>JVM 运行时数据区域主要包括以下几个部分：</p>
<p><strong>方法区 (Method Area)</strong></p>
<p><strong>堆 (Heap)</strong></p>
<p><strong>Java 栈 (Java Stacks)</strong></p>
<p><strong>本地方法栈 (Native Method Stacks)</strong></p>
<p><strong>程序计数器 (Program Counter Register)</strong></p>
<h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区 (Method Area)"></a>方法区 (Method Area)</h3><p>方法区是所有线程共享的内存区域，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><strong>功能</strong>：</p>
<p>存储类的结构信息（如类的名称、访问修饰符、字段描述、方法描述等）。</p>
<p>存储运行时常量池，包括字面量和符号引用。</p>
<p>存储静态变量。</p>
<p>存储编译后的代码。</p>
<p>在 HotSpot JVM 中，方法区的一部分实现为永久代（PermGen），在 Java 8 及以后版本中被称为元空间（Metaspace）。</p>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 (Heap)"></a>堆 (Heap)</h3><p>堆是所有线程共享的内存区域，用于存储所有对象实例和数组。</p>
<p><strong>功能</strong>：</p>
<p>动态分配对象内存。</p>
<p>垃圾收集器主要在堆上工作，回收不再使用的对象内存。</p>
<p>堆通常分为年轻代（Young Generation）和老年代（Old Generation），年轻代又进一步划分为 Eden 区和两个 Survivor 区（S0 和 S1）。</p>
<h3 id="Java-栈-Java-Stacks"><a href="#Java-栈-Java-Stacks" class="headerlink" title="Java 栈 (Java Stacks)"></a>Java 栈 (Java Stacks)</h3><p>每个线程都有自己的 Java 栈，栈帧（Stack Frame）在栈中按顺序存储。</p>
<p><strong>功能</strong>：</p>
<p>存储局部变量表、操作数栈、动态链接、方法返回地址等信息。</p>
<p>每调用一个方法，就会创建一个新的栈帧，方法执行完毕后栈帧被销毁。</p>
<p>栈帧包括：</p>
<p>局部变量表：存储方法的局部变量，包括参数和方法内部的局部变量。</p>
<p>操作数栈：用于操作数的临时存储。</p>
<p>动态链接：指向常量池的方法引用。</p>
<p>方法返回地址：方法调用后的返回地址。</p>
<h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈 (Native Method Stacks)"></a>本地方法栈 (Native Method Stacks)</h3><p>本地方法栈与 Java 栈类似，但它为本地（Native）方法服务。</p>
<p><strong>功能</strong>：</p>
<p>存储本地方法调用的状态。</p>
<p>一些 JVM 使用 C 栈来支持本地方法调用。</p>
<h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器 (Program Counter Register)"></a>程序计数器 (Program Counter Register)</h3><p>每个线程都有自己的程序计数器，是一个很小的内存区域。</p>
<p><strong>功能</strong>：</p>
<p>当前线程所执行的字节码的行号指示器。</p>
<p>如果当前执行的是本地方法，这个计数器值为空（Undefined）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/redis/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/redis/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB_/" itemprop="url">👌本地缓存与分布式缓存的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌本地缓存与分布式缓存的区别"><a href="#👌本地缓存与分布式缓存的区别" class="headerlink" title="👌本地缓存与分布式缓存的区别?"></a>👌本地缓存与分布式缓存的区别?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>本地缓存：是指将数据缓存在应用程序所在的服务器或客户端的内存中。本地缓存的数据存储在应用程序的单个节点上。比如大家启动的应用里面用 hashmap 存储的数据，或者一些三方缓存，caffine，guava cache 这些都是本地缓存，特性在于缓存只存在这台机器。其他机器不知道。本地缓存重起之后，缓存就会失效。</p>
<p>分布式缓存：像 redis 这种就是分布式缓存，一个 redis 存储后，多个应用都可以来进行访问。同时自身支持集群模式，缓存数据可以分散存储在多个节点上。</p>
<h2 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h2><table>
<thead>
<tr>
<th></th>
<th>本地缓存 cacffine&#x2F;guava cache</th>
<th>redis</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>位于应用程序所在的内存中，因此访问速度非常快</td>
<td>在网络上进行数据传输，可能会增加额外的网络开销，导致访问速度略低于本地缓存。</td>
</tr>
<tr>
<td>存储</td>
<td>存储在一个节点中，多个应用实例之间无法共享缓存数据。数据随应用进程的重启而丢失。</td>
<td>通过将数据分片存储在多个节点上，提高了缓存的容量和可扩展性。部分数据会被复制到多个节点上，以提高数据的可靠性和可用性</td>
</tr>
<tr>
<td>容量</td>
<td>容量受到内存大小的限制，一旦超过容量限制，可能会导致性能下降或者数据丢失。无法动态扩展。</td>
<td>根据需求动态添加和删除节点，以适应数据量的变化和访问负载的增加。redis 水平扩展。</td>
</tr>
</tbody></table>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>当并发巨大的时候，如果 redis 的网络和 cpu 成为了瓶颈，一般可以增加一层本地缓存来进行缓冲。也就是我们说的多级缓存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/01/JVM/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/01/JVM/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8_/" itemprop="url">👌Java如何实现自己的类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-01T13:33:41+00:00">
                2025-05-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java如何实现自己的类加载器"><a href="#👌Java如何实现自己的类加载器" class="headerlink" title="👌Java如何实现自己的类加载器?"></a>👌Java如何实现自己的类加载器?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，类加载器（ClassLoader）是负责将类文件加载到 JVM 中的组件。实现自定义类加载器可以让你控制类加载的过程，例如从非标准位置加载类文件、解密类文件等。</p>
<h2 id="实现自定义类加载器的步骤"><a href="#实现自定义类加载器的步骤" class="headerlink" title="实现自定义类加载器的步骤"></a>实现自定义类加载器的步骤</h2><p><strong>继承ClassLoader类</strong>：自定义类加载器需要继承java.lang.ClassLoader类。</p>
<p><strong>重写findClass方法</strong>：重写findClass(String name)方法，这是自定义类加载器的核心方法，用于定义类的加载逻辑。</p>
<p><strong>调用defineClass方法</strong>：在findClass方法中，通过defineClass方法将字节数组转换为Class对象。</p>
<h2 id="从文件系统加载类-Demo"><a href="#从文件系统加载类-Demo" class="headerlink" title="从文件系统加载类 Demo"></a>从文件系统加载类 Demo</h2><h4 id="创建自定义类加载器"><a href="#创建自定义类加载器" class="headerlink" title="创建自定义类加载器"></a>创建自定义类加载器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用自定义类加载器加载类"><a href="#使用自定义类加载器加载类" class="headerlink" title="使用自定义类加载器加载类"></a>使用自定义类加载器加载类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在路径</span><br><span class="line">            MyClassLoader classLoader = new MyClassLoader(&quot;/path/to/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从网络加载类-Demo"><a href="#从网络加载类-Demo" class="headerlink" title="从网络加载类 Demo"></a>从网络加载类 Demo</h2><h4 id="创建自定义类加载器-1"><a href="#创建自定义类加载器-1" class="headerlink" title="创建自定义类加载器"></a>创建自定义类加载器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String baseUrl;</span><br><span class="line"></span><br><span class="line">    public NetworkClassLoader(String baseUrl) &#123;</span><br><span class="line">        this.baseUrl = baseUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为 URL</span><br><span class="line">            String url = baseUrl + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 从网络读取类文件的字节码</span><br><span class="line">            InputStream inputStream = new URL(url).openStream();</span><br><span class="line">            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();</span><br><span class="line">            int nextValue = 0;</span><br><span class="line">            while ((nextValue = inputStream.read()) != -1) &#123;</span><br><span class="line">                byteStream.write(nextValue);</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] classBytes = byteStream.toByteArray();</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用自定义类加载器加载类-1"><a href="#使用自定义类加载器加载类-1" class="headerlink" title="使用自定义类加载器加载类"></a>使用自定义类加载器加载类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在的基 URL</span><br><span class="line">            NetworkClassLoader classLoader = new NetworkClassLoader(&quot;http://example.com/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/JVM/JVM%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/JVM/JVM%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/" itemprop="url">👌JVM堆的内部结构是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T13:33:41+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM堆的内部结构是什么"><a href="#👌JVM堆的内部结构是什么" class="headerlink" title="👌JVM堆的内部结构是什么"></a>👌JVM堆的内部结构是什么</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 堆是 Java 虚拟机用于存储对象实例和数组的内存区域。堆内存是 JVM 管理的主要内存区域之一，堆内存的管理和优化对 Java 应用程序的性能至关重要。堆内存的内部结构通常分为几个不同的区域，以便更高效地进行内存分配和垃圾回收。</p>
<h2 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h2><p>新生代用于存储新创建的对象。大多数对象在新生代中创建，并且很快就会被垃圾回收。新生代进一步分为三个区域：</p>
<p><strong>Eden 区（Eden Space）</strong>：大多数新对象首先分配在 Eden 区。当 Eden 区填满时，会触发一次轻量级的垃圾回收（Minor GC）。</p>
<p><strong>幸存者区（Survivor Spaces）</strong>：新生代中有两个幸存者区，称为 S0（Survivor 0）和 S1（Survivor 1）。在一次 Minor GC 之后，仍然存活的对象会从 Eden 区和当前的幸存者区复制到另一个幸存者区。两个幸存者区会在每次 GC 后交替使用。</p>
<h2 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h2><p>老年代用于存储生命周期较长的对象。那些在新生代经历了多次垃圾回收仍然存活的对象会被移动到老年代。老年代的垃圾回收相对较少，但每次回收的时间较长，称为 Major GC 或 Full GC。</p>
<h2 id="永久代（Permanent-Generation）和元空间（Metaspace）"><a href="#永久代（Permanent-Generation）和元空间（Metaspace）" class="headerlink" title="永久代（Permanent Generation）和元空间（Metaspace）"></a>永久代（Permanent Generation）和元空间（Metaspace）</h2><p><strong>永久代（Permanent Generation）</strong>：在 JDK 8 之前，永久代用于存储类的元数据、常量池、方法信息等。永久代的大小是固定的，容易导致OutOfMemoryError错误。</p>
<p><strong>元空间（Metaspace）</strong>：从 JDK 8 开始，永久代被元空间取代。元空间不在 JVM 堆中，而是使用本地内存。元空间的大小可以动态调整，减少了OutOfMemoryError的风险。</p>
<h2 id="堆内存的垃圾回收"><a href="#堆内存的垃圾回收" class="headerlink" title="堆内存的垃圾回收"></a>堆内存的垃圾回收</h2><p>JVM 使用不同的垃圾回收算法来管理堆内存。</p>
<p><strong>标记-清除（Mark-Sweep）</strong>：标记活动对象，然后清除未标记的对象。</p>
<p><strong>标记-整理（Mark-Compact）</strong>：标记活动对象，然后将它们整理到堆的一端，清理掉不活动的对象。</p>
<p><strong>复制算法（Copying）</strong>：将活动对象从一个区域复制到另一个区域，清理掉旧区域的所有对象。新生代垃圾回收通常使用这种算法。</p>
<p><strong>分代收集（Generational Collection）</strong>：基于对象的生命周期，将堆分为新生代和老年代，分别进行垃圾回收。</p>
<h2 id="堆内存的配置"><a href="#堆内存的配置" class="headerlink" title="堆内存的配置"></a>堆内存的配置</h2><p>JVM 提供了多个参数来配置堆内存的大小和行为：</p>
<p>-Xms：设置堆内存的初始大小。</p>
<p>-Xmx：设置堆内存的最大大小。</p>
<p>-XX:NewSize：设置新生代的初始大小。</p>
<p>-XX:MaxNewSize：设置新生代的最大大小。</p>
<p>-XX:SurvivorRatio：设置 Eden 区与幸存者区的比例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Xms512m </span><br><span class="line">-Xmx1024m </span><br><span class="line">-XX:NewSize=256m </span><br><span class="line">-XX:MaxNewSize=512m </span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line">-XX:MetaspaceSize=128m </span><br><span class="line">-XX:MaxMetaspaceSize=256m</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/JVM/JVM%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/JVM/JVM%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌JVM对象的访问模式有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T13:33:41+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM对象的访问模式有哪些？"><a href="#👌JVM对象的访问模式有哪些？" class="headerlink" title="👌JVM对象的访问模式有哪些？"></a>👌JVM对象的访问模式有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，对象的访问模式主要指的是 JVM 如何通过引用来访问对象的具体字段和方法。不同的 JVM 实现可能会采用不同的访问模式，但主要有以下两种常见的模式：</p>
<h2 id="句柄访问模式（Handle-Access-Mode）"><a href="#句柄访问模式（Handle-Access-Mode）" class="headerlink" title="句柄访问模式（Handle Access Mode）"></a>句柄访问模式（Handle Access Mode）</h2><p>在句柄访问模式下，每个对象引用指向一个句柄池中的句柄。句柄本身包含两个指针，一个指向对象实例数据（实际对象），另一个指向对象的类型数据（如类元数据）。</p>
<h3 id="句柄结构"><a href="#句柄结构" class="headerlink" title="句柄结构"></a>句柄结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用 -&gt; 句柄 -&gt; [对象实例数据指针 | 类型数据指针]</span><br></pre></td></tr></table></figure>

<h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><ol>
<li><strong>引用指向句柄</strong>：对象引用首先指向句柄池中的一个句柄。</li>
<li><strong>句柄指向对象</strong>：句柄包含指向实际对象实例数据的指针和类型数据的指针。</li>
<li><strong>访问对象</strong>：通过句柄中的指针访问对象实例数据和类型数据。</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>对象移动</strong>：在垃圾回收过程中，如果对象被移动，只需更新句柄中的指针，而不需要更新所有引用。</p>
<p><strong>访问灵活</strong>：通过句柄可以灵活地管理对象的访问和元数据。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>间接访问</strong>：每次访问对象都需要通过句柄进行间接访问，增加了访问开销。</p>
<h2 id="直接指针访问模式（Direct-Pointer-Access-Mode）"><a href="#直接指针访问模式（Direct-Pointer-Access-Mode）" class="headerlink" title="直接指针访问模式（Direct Pointer Access Mode）"></a>直接指针访问模式（Direct Pointer Access Mode）</h2><p>在直接指针访问模式下，每个对象引用直接指向对象实例数据。对象实例数据中包含指向类型数据的指针（通常在对象头中）。</p>
<h3 id="直接指针结构"><a href="#直接指针结构" class="headerlink" title="直接指针结构"></a>直接指针结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用 -&gt; 对象实例数据 -&gt; [对象头 | 实例字段]</span><br></pre></td></tr></table></figure>

<h3 id="访问过程-1"><a href="#访问过程-1" class="headerlink" title="访问过程"></a>访问过程</h3><ol>
<li><strong>引用指向对象</strong>：对象引用直接指向对象实例数据。</li>
<li><strong>对象头包含类型数据指针</strong>：对象实例数据的头部包含指向类型数据的指针。</li>
<li><strong>访问对象</strong>：直接通过引用访问对象实例数据和类型数据。</li>
</ol>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p><strong>高效访问</strong>：直接指向对象实例数据，访问速度更快。</p>
<p><strong>简单结构</strong>：对象引用和对象实例数据之间的关系更简单。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p><strong>对象移动</strong>：在垃圾回收过程中，如果对象被移动，所有引用都需要更新，增加了垃圾回收的复杂性。</p>
<h2 id="选择与权衡"><a href="#选择与权衡" class="headerlink" title="选择与权衡"></a>选择与权衡</h2><p>不同的 JVM 实现会根据具体的需求和优化目标选择合适的对象访问模式。现代 JVM（如 HotSpot）通常采用直接指针访问模式，因为它在访问速度和实现复杂性之间取得了较好的平衡。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectAccessExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject obj = new MyObject();  // 创建对象</span><br><span class="line">        obj.setValue(42);               // 设置对象字段</span><br><span class="line">        int value = obj.getValue();     // 访问对象字段</span><br><span class="line">        System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyObject &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyObject类的实例通过直接指针访问模式进行访问。JVM 会直接通过引用访问对象的实例字段value。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/JVM%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/JVM%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌JVM的直接内存是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM的直接内存是什么？"><a href="#👌JVM的直接内存是什么？" class="headerlink" title="👌JVM的直接内存是什么？"></a>👌JVM的直接内存是什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的直接内存是指通过java.nio包中的ByteBuffer类直接分配的内存。这种内存分配方式绕过了 JVM 的堆内存管理，直接使用底层操作系统的内存分配机制。直接内存的使用可以提高 I&#x2F;O 操作的性能，因为它减少了数据在 JVM 堆内存和本地操作系统内存之间的复制开销。</p>
<h2 id="直接内存的特点"><a href="#直接内存的特点" class="headerlink" title="直接内存的特点"></a>直接内存的特点</h2><p><strong>非堆内存</strong>：</p>
<p>直接内存不属于 JVM 的堆内存区域，因此不会受到堆内存的垃圾回收机制的影响。</p>
<p>直接内存的分配和释放由操作系统管理，而不是由 JVM 的垃圾回收器管理。</p>
<p><strong>高效的 I&#x2F;O 操作</strong>：</p>
<p>直接内存特别适合用于频繁的 I&#x2F;O 操作（如文件读写、网络通信等），因为它可以减少数据在 JVM 堆内存和操作系统内存之间的复制次数。</p>
<p>例如，在使用java.nio中的FileChannel进行文件读写时，通过直接缓冲区（Direct Buffer）可以显著提高性能。</p>
<p><strong>手动管理</strong>：</p>
<p>由于直接内存不受 JVM 垃圾回收机制的管理，因此需要手动释放内存。如果不及时释放，可能会导致内存泄漏和系统性能问题。</p>
<h2 id="直接内存的分配"><a href="#直接内存的分配" class="headerlink" title="直接内存的分配"></a>直接内存的分配</h2><p>直接内存的分配通过ByteBuffer类的allocateDirect方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public class DirectMemoryExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 分配 1 MB 的直接内存</span><br><span class="line">        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);</span><br><span class="line"></span><br><span class="line">        // 使用直接缓冲区进行读写操作</span><br><span class="line">        directBuffer.put((byte) 1);</span><br><span class="line">        directBuffer.flip();</span><br><span class="line">        byte value = directBuffer.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接内存的释放"><a href="#直接内存的释放" class="headerlink" title="直接内存的释放"></a>直接内存的释放</h2><p>直接内存的释放并不像堆内存那样由垃圾回收器自动管理。为了更好地控制直接内存的使用，可以使用以下方法：</p>
<ol>
<li><strong>显式释放</strong>：</li>
</ol>
<p>使用第三方库（如 Netty）提供的工具类进行显式释放。例如，Netty 提供了PlatformDependent.freeDirectBuffer方法来释放直接缓冲区。</p>
<ol start="2">
<li><strong>依赖垃圾回收</strong>：</li>
</ol>
<p>虽然直接内存不受 JVM 垃圾回收器的直接管理，但ByteBuffer对象本身仍然受垃圾回收器管理。当ByteBuffer对象被垃圾回收时，其底层的直接内存也会被释放。但是，这种方式不够及时和可靠，可能会导致内存泄漏。</p>
<h2 id="直接内存的配置"><a href="#直接内存的配置" class="headerlink" title="直接内存的配置"></a>直接内存的配置</h2><p>JVM 允许通过启动参数来配置直接内存的最大使用量：</p>
<p>-XX:MaxDirectMemorySize：用于设置直接内存的最大值。如果不设置，默认值为堆内存大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxDirectMemorySize=256m DirectMemoryExample</span><br></pre></td></tr></table></figure>





<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/foc8d6a9to7on1og">https://www.yuque.com/jingdianjichi/xyxdsi/foc8d6a9to7on1og</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/Jvm%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/Jvm%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌Jvm的垃圾回收是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Jvm的垃圾回收是什么？"><a href="#👌Jvm的垃圾回收是什么？" class="headerlink" title="👌Jvm的垃圾回收是什么？"></a>👌Jvm的垃圾回收是什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="什么是垃圾回收？"><a href="#什么是垃圾回收？" class="headerlink" title="什么是垃圾回收？"></a>什么是垃圾回收？</h2><p>所谓垃圾回收机制（Garbage Collection， 简称GC），指自动管理动态分配的内存空间的机制，自动回收不再使用的内存，不定时去堆内存中清理不可达对象，以避免内存泄漏和内存溢出的问题。最早是在1960年代提出的。</p>
<p>垃圾回收是 java相较于c、c++语言的优势之一。其他编程语言，如C#、Python和Ruby等，也都提供了垃圾回收机制。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，程序员唯一能做的就是通过调用System.gc 方法来建议执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。</p>
<p>这也是垃圾收集器的最主要的缺点。</p>
<h2 id="为什么需要垃圾回收？"><a href="#为什么需要垃圾回收？" class="headerlink" title="为什么需要垃圾回收？"></a>为什么需要垃圾回收？</h2><p>如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配而不回收，但是事实并非如此。所以，垃圾回收是必须的。</p>
<p>优点：</p>
<p>减少了程序员的工作量，不需要手动管理内存</p>
<p>动态地管理内存，根据应用程序的需要进行分配和回收，提高了内存利用率</p>
<p>避免内存泄漏和野指针等问题，增加程序的稳定性和可靠</p>
<p>缺点：</p>
<p>垃圾回收会占用一定的系统资源，可能会影响程序的性能</p>
<p>垃圾回收过程中会停止程序的执行，可能会导致程序出现卡顿等问题</p>
<p>不一定能够完全解决内存泄漏等问题，需要在编写代码时注意内存管理和编码规范</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/jvm%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/jvm%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F/" itemprop="url">三色标记法的优点和缺点？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-三色标记法的优点和缺点？"><a href="#👌jvm-三色标记法的优点和缺点？" class="headerlink" title="👌jvm 三色标记法的优点和缺点？"></a>👌jvm 三色标记法的优点和缺点？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>三色标记法是一种用于垃圾回收的标记算法，通过将对象分为三种颜色（白色、灰色和黑色）来管理垃圾收集过程。它在并发垃圾收集器中尤其有用，因为它能够有效处理对象引用的变化。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>并发性</strong>：</p>
<p><strong>减少停顿时间</strong>：三色标记法允许垃圾收集器在应用线程运行的同时进行标记，这大大减少了应用程序的停顿时间，提高了应用的响应性。</p>
<p><strong>并发标记</strong>：通过颜色标记和写屏障技术，三色标记法能够在并发环境下准确标记存活对象，避免遗漏或错误标记。</p>
<p><strong>精确性</strong>：</p>
<p><strong>准确标记存活对象</strong>：三色标记法通过颜色状态和处理队列，确保所有存活对象都能被正确标记，从而避免存活对象被错误回收。</p>
<p><strong>处理对象引用变化</strong>：在并发标记阶段，三色标记法能够处理对象引用的变化，确保引用变化不会导致存活对象被错误回收。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>复杂性</strong>：</p>
<p><strong>实现复杂</strong>：三色标记法的实现相对复杂，尤其是在维护颜色不变性和处理并发标记时，需要额外的机制（如写屏障）来确保正确性。</p>
<p><strong>写屏障开销</strong>：维护颜色不变性需要使用写屏障技术，这会增加一定的运行时开销，可能对性能产生影响。</p>
<p><strong>内存开销</strong>：</p>
<p><strong>颜色状态维护</strong>：三色标记法需要为每个对象维护颜色状态，这会增加一定的内存开销。</p>
<p><strong>处理队列</strong>：需要额外的内存来维护灰色对象的处理队列。</p>
<p><strong>复杂的边界条件</strong>：</p>
<p><strong>颜色不变性维护</strong>：在并发环境下，维护颜色不变性（如强三色不变性或弱三色不变性）可能会遇到复杂的边界条件，需要仔细处理以确保算法的正确性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/jvm%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/jvm%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9F/" itemprop="url">jvm 的四种引用区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-的四种引用区别？"><a href="#👌jvm-的四种引用区别？" class="headerlink" title="👌jvm 的四种引用区别？"></a>👌jvm 的四种引用区别？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，引用类型的不同决定了垃圾收集器如何处理对象的生命周期。Java 提供了四种引用类型：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这些引用类型在java.lang.ref包中定义，它们的区别如下：</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是 Java 中最常见的引用类型。通过new关键字创建的对象引用就是强引用。只要强引用存在，垃圾收集器永远不会回收被引用的对象。强引用是默认的引用类型，通常使用最广泛。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=new String(&quot;Hello, World!&quot;);</span><br></pre></td></tr></table></figure>

<p>str是一个强引用，只要str不被置为null或超出作用域，对象”Hello, World!”就不会被垃圾收集器回收。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是一种相对较强但仍允许垃圾收集器回收的引用类型，适用于实现内存敏感的缓存。只有在内存不足的情况下，垃圾收集器才会回收被软引用关联的对象。软引用通常用于实现缓存，当内存充足时对象不会被回收，当内存不足时对象会被回收以释放内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line">String str = new String(&quot;Hello, World!&quot;);</span><br><span class="line">SoftReference&lt;String&gt; softRef = new SoftReference&lt;&gt;(str);</span><br><span class="line">str = null; // 允许 str 对象被垃圾收集器回收</span><br></pre></td></tr></table></figure>

<p>softRef是一个软引用，当内存不足时，对象”Hello, World!”可能会被回收。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用是一种比软引用更弱的引用类型，适用于实现非强制性缓存。只要垃圾收集器运行，不管内存是否充足，都会回收被弱引用关联的对象。弱引用通常用于实现规范化映射（canonical mappings），例如WeakHashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line">String str = new String(&quot;Hello, World!&quot;);</span><br><span class="line">WeakReference&lt;String&gt; weakRef = new WeakReference&lt;&gt;(str);</span><br><span class="line">str = null; // 允许 str 对象被垃圾收集器回收</span><br></pre></td></tr></table></figure>

<p>weakRef是一个弱引用，垃圾收集器在下一次运行时可能会回收对象”Hello, World!”。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用是一种最弱的引用类型，它仅用于跟踪对象被垃圾收集器回收的时间。虚引用本身不会决定对象的生命周期，垃圾收集器回收对象时会将虚引用放入引用队列中。虚引用通常用于实现一些特殊的清理机制，例如管理直接内存（Direct Memory）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.PhantomReference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line">String str = new String(&quot;Hello, World!&quot;);</span><br><span class="line">ReferenceQueue&lt;String&gt; refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = new PhantomReference&lt;&gt;(str, refQueue);</span><br><span class="line">str = null; // 允许 str 对象被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">// 当垃圾收集器回收 str 对象时，phantomRef 会被放入 refQueue</span><br></pre></td></tr></table></figure>

<p>phantomRef是一个虚引用，当垃圾收集器回收对象”Hello, World!”时，phantomRef会被放入refQueue中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8CG1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB_/" itemprop="url">👌CMS收集器和G1收集器的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌CMS收集器和G1收集器的区别"><a href="#👌CMS收集器和G1收集器的区别" class="headerlink" title="👌CMS收集器和G1收集器的区别?"></a>👌CMS收集器和G1收集器的区别?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>CMS（Concurrent Mark-Sweep）和 G1（Garbage-First）是两种不同的垃圾收集器。</p>
<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p>CMS 是一种低停顿的垃圾收集器，设计目标是减少应用程序的停顿时间。它适用于对响应时间要求高的应用程序，例如 Web 服务器。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>CMS 收集器的工作过程主要分为以下几个阶段：</p>
<ol>
<li><strong>初始标记（Initial Mark）</strong>：标记直接可达的对象，这个阶段需要暂停所有应用线程（Stop-the-world，STW）。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：在应用线程运行的同时，标记从初始标记阶段开始的所有可达对象。</li>
<li><strong>重新标记（Remark）</strong>：再次暂停所有应用线程，标记在并发标记阶段发生变化的对象。</li>
<li><strong>并发清除（Concurrent Sweep）</strong>：在应用线程运行的同时，清除不可达的对象。</li>
</ol>
<h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p>G1 是一种面向服务端应用的垃圾收集器，设计目标是提供可预测的停顿时间，同时具备较高的吞吐量。G1 收集器适用于大内存、多处理器的环境。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>G1 收集器将堆划分为多个大小相等的区域（Region），每个区域可以作为 Eden、Survivor 或 Old 区。G1 的工作过程包括：</p>
<ol>
<li><strong>初始标记（Initial Mark）</strong>：标记从根对象直接可达的对象，需要暂停应用线程（STW）。</li>
<li><strong>并发标记（Concurrent Mark）</strong>：在应用线程运行的同时，标记从初始标记阶段开始的所有可达对象。</li>
<li><strong>最终标记（Final Mark）</strong>：再次暂停应用线程，标记在并发标记阶段发生变化的对象。</li>
<li><strong>筛选回收（Live Data Counting and Cleanup）</strong>：计算每个区域的存活对象数量，并根据回收收益选择要回收的区域。回收过程包括复制存活对象和清理区域。</li>
</ol>
<h2 id="比较总结"><a href="#比较总结" class="headerlink" title="比较总结"></a>比较总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th>CMS 收集器</th>
<th>G1 收集器</th>
</tr>
</thead>
<tbody><tr>
<td>设计目标</td>
<td>低停顿时间</td>
<td>可预测的停顿时间，较高吞吐量</td>
</tr>
<tr>
<td>内存管理</td>
<td>标记-清除，可能产生碎片</td>
<td>标记-复制，减少内存碎片</td>
</tr>
<tr>
<td>并发性</td>
<td>并发标记和清除</td>
<td>并发标记，区域化回收</td>
</tr>
<tr>
<td>停顿时间</td>
<td>较短，但不确定</td>
<td>可配置的停顿时间目标</td>
</tr>
<tr>
<td>适用场景</td>
<td>对响应时间敏感的应用</td>
<td>大内存、多处理器、需要可预测停顿时间的应用</td>
</tr>
</tbody></table>
<h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><p><strong>CMS 收集器</strong>：适用于对响应时间要求高、内存较小、应用负载相对稳定的场景。</p>
<p><strong>G1 收集器</strong>：适用于大内存、多处理器环境，需要可预测停顿时间的应用，特别是那些需要处理大量数据和高并发请求的服务端应用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%9F/" itemprop="url">👌JVM创建对象的时候，如何进行并发处理？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM创建对象的时候，如何进行并发处理？"><a href="#👌JVM创建对象的时候，如何进行并发处理？" class="headerlink" title="👌JVM创建对象的时候，如何进行并发处理？"></a>👌JVM创建对象的时候，如何进行并发处理？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，为了支持高效的并发处理，特别是在创建对象时，JVM 采用了多种技术和优化策略。这些技术和策略旨在确保在多线程环境下对象创建的安全性和效率。</p>
<h2 id="TLAB（Thread-Local-Allocation-Buffers）"><a href="#TLAB（Thread-Local-Allocation-Buffers）" class="headerlink" title="TLAB（Thread-Local Allocation Buffers）"></a>TLAB（Thread-Local Allocation Buffers）</h2><p>TLAB 是 JVM 中的一种优化技术，用于减少线程间的内存分配冲突。每个线程都会被分配一个小的、私有的堆内存空间，称为 TLAB。对象首先尝试在 TLAB 中分配内存。如果 TLAB 中有足够的空间，内存分配可以在没有锁竞争的情况下完成，从而提高性能。</p>
<h3 id="TLAB-工作流程"><a href="#TLAB-工作流程" class="headerlink" title="TLAB 工作流程"></a>TLAB 工作流程</h3><ol>
<li><strong>分配 TLAB</strong>：每个线程在创建时都会被分配一个 TLAB。</li>
<li><strong>对象分配</strong>：当线程需要分配对象时，首先尝试在其 TLAB 中分配内存。</li>
<li><strong>TLAB 用尽</strong>：如果 TLAB 中没有足够的空间，线程会请求分配新的 TLAB。如果堆内存不足以分配新的 TLAB，线程将直接在全局堆中分配内存，这时可能需要进行同步操作。</li>
</ol>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>在某些情况下，特别是当 TLAB 用尽或者需要直接在全局堆中分配内存时，JVM 需要使用锁机制来确保线程安全。常见的锁机制包括：</p>
<p><strong>轻量级锁（Lightweight Locking）</strong>：通过使用 CAS（Compare-And-Swap）操作来实现快速锁定和解锁，适用于竞争不激烈的场景。</p>
<p><strong>偏向锁（Biased Locking）</strong>：当锁倾向于被同一个线程持有时，JVM 会减少锁的开销，适用于单线程访问的情况。</p>
<p><strong>重量级锁（Heavyweight Locking）</strong>：当锁竞争激烈时，JVM 会使用操作系统的互斥锁（如synchronized关键字），这会导致较高的开销。</p>
<h2 id="并发垃圾回收器"><a href="#并发垃圾回收器" class="headerlink" title="并发垃圾回收器"></a>并发垃圾回收器</h2><p>并发垃圾回收器（如 G1、ZGC 和 Shenandoah）在进行垃圾回收时，尽量减少对应用线程的暂停时间。它们通过并发标记、并发清理和增量压缩等技术，确保在多线程环境下高效地管理堆内存。</p>
<h2 id="内存屏障（Memory-Barriers）"><a href="#内存屏障（Memory-Barriers）" class="headerlink" title="内存屏障（Memory Barriers）"></a>内存屏障（Memory Barriers）</h2><p>JVM 使用内存屏障来确保内存操作的顺序性和可见性。内存屏障是一种低级同步原语，用于防止编译器和 CPU 重新排序内存操作，从而确保在多线程环境下的内存一致性。</p>
<h2 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare-And-Swap）"></a>CAS（Compare-And-Swap）</h2><p>CAS 是一种无锁的同步机制，广泛用于 JVM 的并发处理。它允许线程在不使用锁的情况下进行原子操作，从而提高并发性能。CAS 操作包括以下步骤：</p>
<ol>
<li><strong>读取内存位置的当前值</strong>。</li>
<li><strong>比较当前值和预期值</strong>。</li>
<li><strong>如果当前值等于预期值，则写入新值</strong>。</li>
</ol>
<p>如果在写入过程中发现当前值已被其他线程修改，CAS 操作会失败，线程可以选择重试或采取其他措施。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" itemprop="url">👌JVM堆和栈的区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM堆和栈的区别？"><a href="#👌JVM堆和栈的区别？" class="headerlink" title="👌JVM堆和栈的区别？"></a>👌JVM堆和栈的区别？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM（Java Virtual Machine）中，堆（Heap）和栈（Stack）是两种不同的内存区域，它们在内存管理和程序执行中扮演着不同的角色。</p>
<table>
<thead>
<tr>
<th></th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>用于存储所有的对象实例和数组，都在堆中分配内存。</td>
<td>用于存储方法的局部变量、方法调用的参数和方法的调用信息（如返回地址）。每个线程都有自己的栈，栈中的数据与线程一一对应。</td>
</tr>
<tr>
<td>内存管理方式</td>
<td>由垃圾收集器进行自动管理，负责分配和回收对象内存。堆内存是全局共享的，所有线程都可以访问堆中的对象。</td>
<td>由编译器自动管理，内存分配和释放按照方法调用的顺序进行。栈内存是线程私有的，每个线程都有自己的栈，互不干扰。</td>
</tr>
<tr>
<td>生命周期</td>
<td>对象在堆中的生命周期由垃圾收集器决定，只要有引用指向对象，对象就会存在。</td>
<td></td>
</tr>
<tr>
<td>对象的生命周期可以跨越多个方法调用，直到没有引用指向它时才会被垃圾收集器回收。</td>
<td>局部变量的生命周期与方法调用的生命周期一致，方法调用结束时，栈帧被销毁，局部变量也随之销毁。</td>
<td></td>
</tr>
<tr>
<td>栈中的数据在方法调用结束后立即释放。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>内存大小</td>
<td>通常较大，可以通过 JVM 参数（如-Xms和-Xmx）进行配置。适合存储需要较长生命周期的大量对象。</td>
<td>通常较小，每个线程的栈大小可以通过 JVM 参数（如-Xss）进行配置。适合存储短生命周期的小数据。</td>
</tr>
<tr>
<td>线程安全</td>
<td>由于是全局共享的，堆中的对象在多线程环境下需要进行同步控制，以避免线程安全问题。</td>
<td>线程私有的，栈中的数据天然是线程安全的，不需要额外的同步控制。</td>
</tr>
<tr>
<td>访问速度</td>
<td>访问速度相对较慢，因为需要通过引用进行访问，并且涉及到垃圾收集器的管理。</td>
<td>访问速度相对较快，因为栈中数据直接通过栈帧进行访问，且栈的内存分配和释放效率高。</td>
</tr>
<tr>
<td>内存溢出</td>
<td>如果堆内存不足，会抛出OutOfMemoryError（如java.lang.OutOfMemoryError: Java heap space）。</td>
<td>如果栈内存不足，会抛出StackOverflowError（如java.lang.StackOverflowError）。</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/27/JVM/JVM%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/27/JVM/JVM%E7%9A%84%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/" itemprop="url">👌JVM的三色标记算法是什么？解决了什么问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-27T13:33:41+00:00">
                2025-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-06-22T09:27:59+00:00">
                2025-06-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM的三色标记算法是什么？解决了什么问题？"><a href="#👌JVM的三色标记算法是什么？解决了什么问题？" class="headerlink" title="👌JVM的三色标记算法是什么？解决了什么问题？"></a>👌JVM的三色标记算法是什么？解决了什么问题？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>三色标记算法通过颜色标记和处理队列，解决了并发垃圾收集过程中对象引用变化导致的标记不准确问题。它确保所有存活对象都能被正确标记，从而避免了存活对象被错误回收。同时，写屏障技术的使用进一步保证了颜色不变性，确保算法在并发环境下的正确性。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>三色标记算法是一种用于垃圾回收的标记算法，通过将对象分为三种颜色（白色、灰色和黑色）来管理垃圾收集过程。它主要解决了在并发垃圾收集过程中如何正确标记存活对象的问题，避免了遗漏存活对象或错误标记对象的情况。</p>
<h2 id="三色标记算法的基本概念"><a href="#三色标记算法的基本概念" class="headerlink" title="三色标记算法的基本概念"></a>三色标记算法的基本概念</h2><p><strong>白色</strong>：表示对象尚未被垃圾收集器访问到。如果垃圾收集过程结束时对象仍然是白色，它将被视为不可达对象，随后被回收。</p>
<p><strong>灰色</strong>：表示对象已被访问到，但其引用的对象尚未全部访问。灰色对象需要进一步扫描其引用的对象。</p>
<p><strong>黑色</strong>：表示对象及其引用的对象都已被访问到。黑色对象不需要再扫描。</p>
<h2 id="三色标记算法的工作流程"><a href="#三色标记算法的工作流程" class="headerlink" title="三色标记算法的工作流程"></a>三色标记算法的工作流程</h2><ol>
<li><strong>初始化</strong>：所有对象开始时都是白色的。</li>
<li><strong>标记根对象</strong>：将根对象（GC Roots）标记为灰色，并将它们放入一个待处理队列。</li>
<li><strong>处理灰色对象</strong>：</li>
</ol>
<p>从队列中取出一个灰色对象，将其标记为黑色，将该对象引用的所有白色对象标记为灰色，并将这些灰色对象加入队列。</p>
<ol start="4">
<li><strong>重复步骤 3</strong>，直到队列为空。</li>
<li><strong>清除白色对象</strong>：所有剩余的白色对象都是不可达的，可以被回收。</li>
</ol>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>三色标记算法主要解决了以下问题：</p>
<ol>
<li><strong>并发标记的准确性</strong>：在并发垃圾收集过程中，应用线程可能会修改对象引用，导致垃圾收集器标记不准确。三色标记算法通过颜色标记和处理队列，确保所有存活对象都能被正确标记。</li>
<li><strong>避免重复标记</strong>：通过将对象分为三种颜色，垃圾收集器能有效避免重复标记对象，提高标记效率。</li>
<li><strong>处理对象引用变化</strong>：在并发标记阶段，应用线程可能会增加或删除对象引用。三色标记算法通过维护颜色状态和处理队列，确保引用变化不会导致存活对象被错误回收。</li>
</ol>
<h2 id="颜色不变性"><a href="#颜色不变性" class="headerlink" title="颜色不变性"></a>颜色不变性</h2><p>为了确保三色标记算法在并发环境下的正确性，通常需要维护以下两种不变性之一：</p>
<ol>
<li><strong>强三色不变性</strong>：黑色对象不能直接引用白色对象。这意味着如果一个黑色对象引用了一个白色对象，白色对象必须先被标记为灰色。</li>
<li><strong>弱三色不变性</strong>：在标记阶段，白色对象只能通过灰色对象直接或间接引用。这意味着如果一个白色对象被引用，它一定会通过一个灰色对象。</li>
</ol>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>为了维护颜色不变性，垃圾收集器通常会使用写屏障技术。在对象引用发生变化时，写屏障会执行特定的操作，确保颜色不变性不被破坏。例如，在引用赋值操作时，写屏障可能会将目标对象标记为灰色，确保其不会被错误回收。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">232</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xiaoyaofeihu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
