<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/11/10/Mysql%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/10/Mysql%E4%BA%8B%E5%8A%A1/" itemprop="url">Mysql事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-11-10T17:33:00+00:00">
                2024-11-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p><strong>事务指的是逻辑上的一组操作，组成这组操作的各个单元要么全都成功，要么全都失败。</strong><br><strong>事务作用：保证在一个事务中多次SQL操作要么全都成功，要么全都失败。</strong></p>
<h3 id="1、特性"><a href="#1、特性" class="headerlink" title="1、特性"></a>1、特性</h3><ul>
<li>原子性：事务的操作要么都发生，要么都不发生；</li>
<li>一致性：事务前后数据的完整性必须保持一致；</li>
<li>隔离性：一个用户的事务不能被其他用户的事务干扰；多个并发事务之间的数据相互隔离；隔离性由隔离级别保障！</li>
<li>持久性：事务一旦提交，对数据的修改时永久性的；</li>
</ul>
<h3 id="2、事务并发问题"><a href="#2、事务并发问题" class="headerlink" title="2、事务并发问题"></a>2、事务并发问题</h3><ul>
<li>脏读：一个事务读到了另一个事务未提交的数据</li>
<li>不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发事务中的多次查询结果不<br>一致</li>
<li>虚读 &#x2F;幻读：一个事务读到了另一个事务已经插入(insert)的数据。导致事务中多次查询的结果不一<br>致</li>
<li>丢失更新的问题！</li>
</ul>
<h3 id="3、隔离级别"><a href="#3、隔离级别" class="headerlink" title="3、隔离级别"></a>3、隔离级别</h3><ul>
<li>read uncommitted 读未提交【RU】，一个事务读到另一个事务没有提交的数据<br>存在：3个问题（脏读、不可重复读、幻读）。</li>
<li>read committed 读已提交【RC】，一个事务读到另一个事务已经提交的数据<br>存在：2个问题（不可重复读、幻读）。<br>解决：1个问题（脏读）</li>
<li>repeatable read:可重复读【RR】，在一个事务中读到的数据始终保持一致，无论另一个事务是<br>否提交<br>解决：3个问题（脏读、不可重复读、幻读）</li>
<li>serializable 串行化，同时只能执行一个事务，相当于事务中的单线程<br>解决：3个问题（脏读、不可重复读、幻读）</li>
</ul>
<h2 id="二、事务底层"><a href="#二、事务底层" class="headerlink" title="二、事务底层"></a>二、事务底层</h2><h3 id="1、丢失更新问题"><a href="#1、丢失更新问题" class="headerlink" title="1、丢失更新问题"></a>1、丢失更新问题</h3><ul>
<li>两个事务针对同一个数据进行修改操作时会丢失更新！</li>
<li>解决方案：<ul>
<li>基于锁并发控制LBCC</li>
<li>基于版本并发控制MVCC</li>
</ul>
</li>
</ul>
<h2 id="三、MVCC"><a href="#三、MVCC" class="headerlink" title="三、MVCC"></a>三、MVCC</h2><h3 id="核心思想是读不加锁，读写不冲突"><a href="#核心思想是读不加锁，读写不冲突" class="headerlink" title="核心思想是读不加锁，读写不冲突"></a>核心思想是读不加锁，读写不冲突</h3><p><strong>MVCC 实现原理关键在于数据快照，不同的事务访问不同版本的数据快照，从而实现事务下对数据的隔离级别</strong></p>
<p>MVCC，全称Multiversion Concurrency Control，即多版本并发控制，是数据库领域中一种用于管理并发数据访问的机制。与数据库锁相似，MVCC也是一种并发控制的解决方案，但它侧重于通过维护数据的多个版本来避免读写冲突，从而提高并发性能。</p>
<h3 id="MVCC的基本原理"><a href="#MVCC的基本原理" class="headerlink" title="MVCC的基本原理"></a>MVCC的基本原理</h3><p>在数据库中，对数据的操作主要分为读和写两种。在并发场景下，会出现读-读并发、读-写并发和写-写并发三种情况。其中，读-读并发通常不会引发问题，写-写并发则常通过加锁来解决，而读-写并发则可以通过MVCC机制来高效处理。</p>
<p>MVCC的核心思想是，对于同一份数据，每个事务在读取时都会看到一个特定的、一致的数据版本，这个版本是在该事务开始时刻生成的。这样，即使有其他事务在修改数据，也不会影响到当前事务的读取结果。</p>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>MVCC的实现依赖于快照读的概念。快照读是指读取的是快照数据，即快照生成时的数据状态。在MySQL中，普通的SELECT语句（不加锁）通常就是快照读。与快照读相对应的是当前读，它读取的是最新数据，通常用于加锁的SELECT操作或数据的增删改操作。</p>
<h3 id="Undo-Log与快照"><a href="#Undo-Log与快照" class="headerlink" title="Undo Log与快照"></a>Undo Log与快照</h3><p>Undo Log是MySQL中用于回退的事务日志。在事务提交之前，MySQL会先记录更新前的数据到Undo Log中。这些“更新前的数据”实际上就是快照数据。因此，Undo Log是MVCC实现的重要手段。</p>
<p>每当一条记录发生变更时，MySQL都会先将其快照存储到Undo Log中，并更新记录中的隐式字段。这些隐式字段包括：</p>
<ul>
<li><code>db_row_id</code>：隐藏主键，用于创建聚簇索引。</li>
<li><code>db_trx_id</code>：对这条记录做了最新一次修改的事务的ID。</li>
<li><code>db_roll_ptr</code>：回滚指针，指向这条记录的上一个版本（即Undo Log中的上一个快照的地址）。</li>
</ul>
<p>这样，每个快照都通过<code>db_trx_id</code>和<code>db_roll_ptr</code>字段形成了一个快照链表。</p>
<h3 id="Read-View与可见性"><a href="#Read-View与可见性" class="headerlink" title="Read View与可见性"></a>Read View与可见性</h3><p>然而，即使有了Undo Log和快照链表，我们仍然需要确定在当前事务中应该读取哪个快照。这时，就需要用到Read View了。</p>
<p>Read View是InnoDB中一个至关重要的概念，它是实现MVCC的基础。Read View主要用来解决可见性问题，即它会告诉当前事务应该看到哪个版本的数据。具体来说，Read View会根据当前事务的ID和其他活跃事务的ID来构建一个视图，然后基于这个视图来确定哪些数据版本对当前事务是可见的。</p>
<p>通过Read View，InnoDB能够确保每个事务在读取数据时都能看到一个一致的快照，从而避免了读写冲突，提高了并发性能。</p>
<p>综上所述，MVCC通过维护数据的多个版本、利用快照读和Undo Log以及Read View等机制，实现了高效的并发控制。这使得数据库能够在高并发环境下保持数据的一致性和完整性，同时提高了系统的性能和吞吐量。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>MVCC指在使用RC、RR隔离级别下，使不同事务的 读-写 、 写-读 操作并发执行，提升系统性能</li>
<li>MVCC核心思想是读不加锁，读写不冲突。</li>
<li>RC、RR这两个隔离级别的一个很大不同就是生成 ReadView 的时机不同</li>
<li>RC在每一次进行普通 SELECT 操作前都会生成一个 ReadView</li>
<li>RR在第一次进行普通 SELECT 操作前生成一个 ReadView ，之后的查询操作都重复这个ReadView</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/11/10/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/10/volatile/" itemprop="url">volatile笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-11-10T17:33:00+00:00">
                2024-11-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="volatile能保证原子性吗？"><a href="#volatile能保证原子性吗？" class="headerlink" title="volatile能保证原子性吗？"></a>volatile能保证原子性吗？</h2><p><strong>volatile本身不是锁</strong></p>
<h2 id="一、原子性"><a href="#一、原子性" class="headerlink" title="一、原子性"></a>一、原子性</h2><p>原子性是指一个操作或者多个操作要么全部执行，要么全部不执行，中间不会被其他线程的操作打断。在Java中，原子性通常通过同步机制（如<code>synchronized</code>）或者原子类（如<code>AtomicInteger</code>、<code>AtomicLong</code>等）来保证。</p>
<h3 id="为什么需要原子性"><a href="#为什么需要原子性" class="headerlink" title="为什么需要原子性"></a>为什么需要原子性</h3><p>在并发编程中，多个线程可能会同时访问和修改同一个共享资源。如果没有适当的同步机制，就可能会出现数据不一致、数据丢失等问题。原子性操作可以确保这些共享资源在并发访问时的正确性和一致性。</p>
<h3 id="如何实现原子性操作"><a href="#如何实现原子性操作" class="headerlink" title="如何实现原子性操作"></a>如何实现原子性操作</h3><ol>
<li><p><strong>使用<code>synchronized</code>关键字</strong>：<br><code>synchronized</code>关键字可以用来修饰方法或代码块，以确保同一时间只有一个线程可以执行被修饰的代码。这是保证原子性的一种常见方式。</p>
</li>
<li><p><strong>使用原子类</strong>：<br>Java提供了一些原子类（如<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等），这些类内部使用了高效的机制来确保操作的原子性。这些类通常用于实现计数器、状态标志等需要原子性操作的场景。</p>
</li>
<li><p><strong>使用锁（Lock）</strong>：<br>Java的<code>java.util.concurrent.locks</code>包提供了一些高级的锁机制（如<code>ReentrantLock</code>、<code>ReadWriteLock</code>等），这些锁提供了比<code>synchronized</code>更灵活的同步控制。</p>
</li>
<li><p><strong>使用低级别的原子操作</strong>：<br>在某些情况下，开发者可能需要直接使用Java的<code>Unsafe</code>类或者JNI（Java Native Interface）来调用操作系统的原子操作指令。这种方式通常用于实现高性能的并发数据结构或算法。</p>
</li>
</ol>
<h3 id="示例：使用AtomicInteger实现原子性自增"><a href="#示例：使用AtomicInteger实现原子性自增" class="headerlink" title="示例：使用AtomicInteger实现原子性自增"></a>示例：使用<code>AtomicInteger</code>实现原子性自增</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        number.incrementAndGet(); <span class="comment">// 原子性自增操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">atomicDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    atomicDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(j)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; final number result = &quot;</span> + atomicDemo.number.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了<code>AtomicInteger</code>的<code>incrementAndGet</code>方法来实现原子性自增操作。由于<code>AtomicInteger</code>内部使用了高效的原子操作机制，因此可以保证在多线程环境下的正确性。运行这个程序，你会发现每次的结果都是10000，这与使用<code>volatile</code>修饰的变量时的结果不同。</p>
<h2 id="二、volatile是如何保证可见性和有序性的？"><a href="#二、volatile是如何保证可见性和有序性的？" class="headerlink" title="二、volatile是如何保证可见性和有序性的？"></a>二、volatile是如何保证可见性和有序性的？</h2><h3 id="volatile和可见性"><a href="#volatile和可见性" class="headerlink" title="volatile和可见性"></a>volatile和可见性</h3><p><strong>对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。 所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</strong></p>
<h2 id="三、synchronized和volatile-区别"><a href="#三、synchronized和volatile-区别" class="headerlink" title="三、synchronized和volatile 区别"></a>三、<code>synchronized</code>和<code>volatile</code> 区别</h2><h3 id="synchronized的特点和缺点"><a href="#synchronized的特点和缺点" class="headerlink" title="synchronized的特点和缺点"></a>synchronized的特点和缺点</h3><p><code>synchronized</code>是一种加锁机制，用于确保在同一时刻只有一个线程可以执行某个方法或代码块。它的主要优点在于能够确保线程安全，防止多个线程同时修改共享资源导致的数据不一致问题。然而，<code>synchronized</code>也存在一些缺点：</p>
<ol>
<li><p><strong>性能损耗</strong>：虽然JDK 1.6及以后的版本对<code>synchronized</code>进行了多种优化（如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等），但加锁和解锁的过程仍然会带来一定的性能损耗。</p>
</li>
<li><p><strong>产生阻塞</strong>：<code>synchronized</code>实现的锁本质上是一种阻塞锁。当多个线程同时访问同一段同步代码时，只有一个线程能够获取锁并进入临界区，其他线程则需要在Entry Set中等待。这可能导致线程阻塞和上下文切换，从而影响系统的并发性能。</p>
</li>
</ol>
<h3 id="volatile的特点和优势"><a href="#volatile的特点和优势" class="headerlink" title="volatile的特点和优势"></a>volatile的特点和优势</h3><p><code>volatile</code>是Java虚拟机提供的一种轻量级同步机制，它主要用于确保变量的可见性，并禁止指令重排。与<code>synchronized</code>相比，<code>volatile</code>具有以下特点和优势：</p>
<ol>
<li><p><strong>性能更高</strong>：<code>volatile</code>变量的读操作与普通变量几乎无差别，写操作虽然由于需要插入内存屏障而稍慢一些，但在大多数场景下，其开销仍然比锁要低。</p>
</li>
<li><p><strong>禁止指令重排</strong>：<code>volatile</code>通过内存屏障来确保变量的可见性和有序性。这意味着，当一个线程修改了<code>volatile</code>变量的值后，其他线程能够立即看到这个修改。同时，<code>volatile</code>还能够防止编译器和处理器对指令进行重排序，从而避免某些潜在的并发问题。</p>
</li>
<li><p><strong>非阻塞</strong>：与<code>synchronized</code>不同，<code>volatile</code>不会造成线程的阻塞。它只是确保变量的可见性和有序性，而不会限制线程对共享资源的访问。</p>
</li>
</ol>
<h3 id="为什么需要volatile"><a href="#为什么需要volatile" class="headerlink" title="为什么需要volatile"></a>为什么需要volatile</h3><p>尽管<code>synchronized</code>提供了强大的线程同步功能，但在某些场景下，我们仍然需要<code>volatile</code>。这主要是因为：</p>
<ol>
<li><p><strong>可见性问题</strong>：在某些情况下，我们可能只需要确保变量的可见性，而不需要对共享资源进行加锁。这时，使用<code>volatile</code>就足够了。</p>
</li>
<li><p><strong>指令重排问题</strong>：在某些并发场景中，指令重排可能会导致潜在的问题。而<code>volatile</code>能够禁止指令重排，从而避免这些问题。</p>
</li>
<li><p><strong>性能考虑</strong>：在某些对性能要求较高的场景中，使用<code>volatile</code>可能比使用<code>synchronized</code>更加合适。因为<code>volatile</code>的开销更低，不会造成线程的阻塞和上下文切换。</p>
</li>
</ol>
<p>综上所述，<code>synchronized</code>和<code>volatile</code>各有其特点和适用场景。在Java并发编程中，我们需要根据具体的需求和场景来选择合适的同步机制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/HashMap/" itemprop="url">HashMap底层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HashMap是Java中一种非常重要的数据结构，它基于哈希表的原理，实现了对键值对（key-value-pair）的快速存储和访问。下面详细解释HashMap的数据结构以及其在JDK-1-8中的变化。"><a href="#HashMap是Java中一种非常重要的数据结构，它基于哈希表的原理，实现了对键值对（key-value-pair）的快速存储和访问。下面详细解释HashMap的数据结构以及其在JDK-1-8中的变化。" class="headerlink" title="HashMap是Java中一种非常重要的数据结构，它基于哈希表的原理，实现了对键值对（key-value pair）的快速存储和访问。下面详细解释HashMap的数据结构以及其在JDK 1.8中的变化。"></a>HashMap是Java中一种非常重要的数据结构，它基于哈希表的原理，实现了对键值对（key-value pair）的快速存储和访问。下面详细解释HashMap的数据结构以及其在JDK 1.8中的变化。</h2><h3 id="HashMap的基本数据结构"><a href="#HashMap的基本数据结构" class="headerlink" title="HashMap的基本数据结构"></a>HashMap的基本数据结构</h3><p>在HashMap中，数据是通过“数组+链表”的方式存储的，这种结构也被称为“链表的数组”。具体来说：</p>
<ol>
<li><p><strong>数组</strong>：HashMap内部维护了一个Entry数组（在JDK 1.8及以后版本中，Entry被Node类替代，但功能相同），数组的每个元素都是一个桶（Bucket），桶中存放的是指向链表节点的引用。</p>
</li>
<li><p><strong>链表</strong>：当发生哈希冲突（即不同的key通过哈希函数计算得到的下标相同）时，这些key-value对会被存储在同一桶中的链表中。链表中的每个节点都包含key、value、next等字段，用于存储数据和指向下一个节点的引用。</p>
</li>
</ol>
<h3 id="哈希函数与冲突解决"><a href="#哈希函数与冲突解决" class="headerlink" title="哈希函数与冲突解决"></a>哈希函数与冲突解决</h3><ol>
<li><p><strong>哈希函数</strong>：HashMap通过哈希函数（hash()方法）将key转换为数组的下标。这个哈希函数的目标是尽量均匀地分布元素，以减少哈希冲突的发生。</p>
</li>
<li><p><strong>冲突解决</strong>：当发生哈希冲突时，HashMap采用链地址法（也称为拉链法）来解决。即在同一桶中维护一个链表，将冲突的元素依次添加到链表中。</p>
</li>
</ol>
<h3 id="JDK-1-8中的优化"><a href="#JDK-1-8中的优化" class="headerlink" title="JDK 1.8中的优化"></a>JDK 1.8中的优化</h3><p>在JDK 1.8中，HashMap进行了重要的优化，引入了红黑树来进一步减少哈希冲突对性能的影响。具体来说：</p>
<ol>
<li><p><strong>链表转红黑树</strong>：当桶中的链表长度超过一定阈值（默认为8）时，HashMap会将这个链表转换为红黑树。红黑树是一种平衡二叉搜索树，具有更高的查找效率（O(log n)），从而提高了HashMap的性能。</p>
</li>
<li><p><strong>阈值调整</strong>：在JDK 1.8中，HashMap还引入了一个新的参数<code>treeifyThreshold</code>来控制链表转换为红黑树的阈值，以及<code>untreeifyThreshold</code>来控制红黑树转换为链表的阈值（当链表长度小于等于6时）。此外，还有一个<code>minTreeifyCapacity</code>参数，用于确保在链表转换为红黑树之前，HashMap的容量至少达到一定的阈值（默认为64），以避免频繁的树化操作。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HashMap的数据结构是基于“数组+链表”的，通过哈希函数将key映射到数组的下标，并通过链表解决哈希冲突。在JDK 1.8中，HashMap引入了红黑树来优化性能，当链表长度超过一定阈值时，会将链表转换为红黑树以提高查找效率。这些优化使得HashMap在处理大量数据时具有更高的性能和更好的稳定性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/HashMap%E5%92%8CHashTable%E7%9A%84%E6%AF%94%E8%BE%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/HashMap%E5%92%8CHashTable%E7%9A%84%E6%AF%94%E8%BE%83/" itemprop="url">HashMap、Hashtable和ConcurrentHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Java中，<code>HashMap</code>、<code>Hashtable</code>和<code>ConcurrentHashMap</code>都是用于存储键值对的数据结构，但它们在使用场景和内部实现上有显著的区别。下面是对这些区别的详细解释：</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ol>
<li><p><strong>HashMap</strong>：</p>
<ul>
<li><strong>非线程安全</strong>：<code>HashMap</code>没有考虑线程安全问题，如果在多线程环境下不加同步地使用<code>HashMap</code>，可能会导致数据不一致的问题，如死锁、数据丢失或覆盖。</li>
</ul>
</li>
<li><p><strong>Hashtable</strong>：</p>
<ul>
<li><strong>线程安全</strong>：<code>Hashtable</code>是线程安全的，它的所有方法都是同步的。这意味着在多线程环境中，同时访问和修改<code>Hashtable</code>不会导致数据不一致。但是，由于每个方法都使用同步，这可能导致在高并发环境下性能较低。</li>
</ul>
</li>
<li><p><strong>ConcurrentHashMap</strong>：</p>
<ul>
<li><strong>线程安全且高效</strong>：<code>ConcurrentHashMap</code>是为了解决在高并发环境下<code>HashMap</code>的性能问题和<code>Hashtable</code>的同步性能瓶颈而设计的。</li>
<li><strong>JDK 1.7及之前</strong>：使用分段锁（Segment Lock）机制，将整个哈希表分为多个段（Segment），每个段本质上是一个小的哈希表，并且有自己的锁。这样，在高并发情况下，只要多个线程访问的是不同的段，就可以并行处理，提高了并发性能。</li>
<li><strong>JDK 1.8及之后</strong>：取消了分段锁，而是采用了CAS（Compare-And-Swap）操作和<code>synchronized</code>关键字来实现更细粒度的锁。每个桶（Node）的锁控制更加精确，只有在必要时才锁定相关的桶，进一步提高了并发性能。</li>
</ul>
</li>
</ol>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><ol>
<li><p><strong>Hashtable</strong>：</p>
<ul>
<li>继承自<code>java.util.Dictionary</code>类，这是一个抽象类，提供了基本的键值对存储功能。<code>Hashtable</code>是最早的键值对存储实现之一，因此在Java早期版本中广泛使用。</li>
</ul>
</li>
<li><p><strong>HashMap</strong>和<strong>ConcurrentHashMap</strong>：</p>
<ul>
<li>都继承自<code>java.util.AbstractMap</code>抽象类，并实现了<code>java.util.Map</code>接口。<code>AbstractMap</code>提供了Map接口的部分实现，以减少子类实现的工作量。</li>
<li><code>HashMap</code>和<code>ConcurrentHashMap</code>都提供了Map接口的所有功能，但在实现上有所不同，以适应不同的使用场景。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>HashMap</strong>：适用于单线程环境或不需要考虑线程安全的情况，因为它提供了最好的性能。</li>
<li><strong>Hashtable</strong>：适用于多线程环境，但需要同步（即线程安全）的键值对存储。然而，由于性能原因，现在通常推荐使用<code>ConcurrentHashMap</code>。</li>
<li><strong>ConcurrentHashMap</strong>：适用于高并发环境，提供了线程安全的键值对存储，并且性能优于<code>Hashtable</code>。</li>
</ul>
<p>总之，选择哪种Map实现取决于应用程序的具体需求，包括是否需要线程安全以及并发性能的要求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/List%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/List%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/" itemprop="url">List中的遍历方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在Java中，遍历并修改一个List集合是一个常见的操作，但如果不小心处理，可能会遇到<code>ConcurrentModificationException</code>异常，这通常是因为在遍历过程中直接修改了集合的结构（如添加、删除元素）。下面是你提到的几种处理方案及其详细解释：</li>
</ul>
<ol>
<li><p><strong>通过普通的for循环（不建议，可能会漏删）</strong>：<br>使用普通的for循环遍历List，并通过索引直接修改或删除元素。这种方法的问题是，如果删除元素后没有相应地调整索引（例如，连续删除元素时），可能会导致跳过某些元素的检查或索引越界异常。</p>
</li>
<li><p><strong>通过普通的for循环进行倒序遍历</strong>：<br>倒序遍历可以避免因删除元素而导致的索引调整问题，因为即使删除了元素，后面的元素索引也不会改变（相对于当前遍历方向）。这种方法可以有效避免漏删的问题。</p>
</li>
<li><p><strong>使用迭代器循环</strong>：<br>迭代器提供了一种安全的方式来遍历并修改集合。使用迭代器的<code>remove</code>方法可以安全地删除当前元素，而不会触发<code>ConcurrentModificationException</code>。注意，不能使用集合的<code>remove</code>方法，而应该使用迭代器的<code>remove</code>方法。</p>
</li>
<li><p><strong>复制列表</strong>：<br>创建一个原始列表的副本，遍历原始列表，同时在副本上进行删除操作。这种方法是fail-safe的，因为遍历和修改发生在不同的列表上。但这种方法相对复杂，且需要额外的内存来存储副本。此外，如果列表中的元素是复杂对象，可能需要正确地实现<code>equals</code>和<code>hashCode</code>方法以确保正确的删除。</p>
</li>
<li><p><strong>使用并发安全的集合类</strong>：<br>使用如<code>CopyOnWriteArrayList</code>这样的线程安全的集合类。这种集合类在修改时创建集合的副本，因此遍历和修改可以安全地进行，但这也可能导致在大量修改时性能下降，因为每次修改都需要复制整个集合。</p>
</li>
<li><p><strong>使用Stream的过滤方法</strong>：<br>Java 8引入的Stream API提供了一种声明性的方式来处理集合。通过<code>filter</code>方法，可以创建一个新的Stream，只包含满足特定条件的元素。然后，可以使用<code>collect</code>方法将结果收集到一个新的列表中。这种方法简单高效，因为它避免了在遍历过程中直接修改原始集合。</p>
</li>
<li><p><strong>通过<code>removeIf</code>方法</strong>：<br>Java 8的<code>List</code>接口引入了<code>removeIf</code>方法，它接受一个谓词（Predicate），并删除所有满足该谓词的元素。这是一个非常简洁和高效的方法，用于根据条件删除元素。</p>
</li>
</ol>
<p>综上所述，每种方法都有其适用的场景和优缺点。在选择方法时，应考虑集合的大小、修改的频率、内存使用以及对性能的要求。对于大多数情况，使用<code>removeIf</code>或Stream的<code>filter</code>方法是推荐的做法，因为它们既简单又高效。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/ThreadLocal/" itemprop="url">ThreadLocal的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。"><a href="#ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。" class="headerlink" title="ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。"></a>ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。</h2><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现主要依赖于一个内部类ThreadLocalMap。这个Map以ThreadLocal对象为键，以线程独有的变量为值。每个线程都维护着一个ThreadLocalMap的引用，这样线程就可以通过ThreadLocal对象作为键，在其自己的ThreadLocalMap中查找或设置值。</p>
<ol>
<li><p><strong>ThreadLocalMap的结构</strong>：</p>
<ul>
<li>ThreadLocalMap是一个哈希表，它的键（Key）是ThreadLocal对象本身的一个弱引用（WeakReference），而值（Value）则是线程独有的变量。</li>
<li>使用弱引用作为键的好处是，当ThreadLocal对象被垃圾回收时，不会因为ThreadLocalMap中的引用而阻止其被回收。但这也带来了一个问题，即如果ThreadLocal对象被回收了，而ThreadLocalMap中的Entry还存在（且Value还未被回收），那么就会出现键为null的情况，这需要在ThreadLocalMap的操作中特别处理。</li>
</ul>
</li>
<li><p><strong>ThreadLocal的方法</strong>：</p>
<ul>
<li><code>initialValue()</code>：返回此线程局部变量的初始值。</li>
<li><code>get()</code>：返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则通过调用<code>initialValue()</code>方法创建并初始化此副本。</li>
<li><code>set(T value)</code>：将此线程局部变量的当前线程副本中的值设置为指定值。</li>
<li><code>remove()</code>：移除此线程局部变量的值。这是一个清理操作，有助于避免内存泄漏，特别是在使用线程池时。</li>
</ul>
</li>
<li><p><strong>ThreadLocalMap的扩容和清理</strong>：</p>
<ul>
<li>ThreadLocalMap的扩容机制与HashMap类似，当元素数量超过阈值时，会进行扩容。</li>
<li>由于ThreadLocalMap的键是弱引用，当没有强引用指向ThreadLocal对象时，ThreadLocal对象可以被垃圾回收。但是，如果ThreadLocal对象被回收了，而对应的Value对象还有强引用存在（即还没有被线程显式地调用<code>remove()</code>方法移除），那么这些Value对象就变成了“孤儿对象”，可能会导致内存泄漏。因此，在使用ThreadLocal时，建议显式地调用<code>remove()</code>方法来清理不再需要的线程局部变量。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>ThreadLocal的典型使用场景包括：</p>
<ul>
<li>在多线程环境中，每个线程需要维护一个独立的、不与其他线程共享的状态或数据。</li>
<li>在处理用户请求时，将用户相关的信息（如用户ID、会话信息等）保存在ThreadLocal中，以便在同一个请求处理流程中方便地访问这些信息，而不需要通过参数传递。</li>
</ul>
<h3 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h3><ul>
<li><strong>内存泄漏</strong>：指的是程序中分配的内存在不再需要时没有被正确释放或回收的情况。随着时间的推移，可用内存逐渐减少，最终可能导致程序性能下降或崩溃。</li>
<li><strong>内存溢出</strong>（OOM, Out of Memory）：当程序运行时，如果请求的内存超出了可用内存的限制，就会抛出内存溢出异常。内存泄漏如果不及时解决，最终可能导致内存溢出。</li>
</ul>
<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p>ThreadLocal是一个用于创建线程本地变量的类。每个线程都拥有自己独立的、初始化为null的变量副本，这些变量对其他线程是不可见的。然而，ThreadLocal的内存泄漏问题是一个比较典型的问题。</p>
<h4 id="ThreadLocal内存泄漏的来源"><a href="#ThreadLocal内存泄漏的来源" class="headerlink" title="ThreadLocal内存泄漏的来源"></a>ThreadLocal内存泄漏的来源</h4><ol>
<li><p><strong>ThreadLocal对象在堆上存储的ThreadLocalMap</strong>：</p>
<ul>
<li>ThreadLocalMap是ThreadLocal的内部类，用于存储线程局部变量。</li>
<li>ThreadLocalMap的key是ThreadLocal对象，value是线程变量的值。</li>
</ul>
</li>
<li><p><strong>ThreadLocal的引用链</strong>：</p>
<ul>
<li>ThreadLocal对象有两个引用源：一个是栈上的ThreadLocal引用（方法内创建），一个是ThreadLocalMap中的key对它的引用。</li>
<li>如果栈上的ThreadLocal引用不再使用（方法结束），但ThreadLocal对象因为还有ThreadLocalMap中的key引用而无法被回收，就会导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>线程对象被重复使用</strong>：</p>
<ul>
<li>在线程池场景中，线程对象会被重复使用。如果线程中的ThreadLocalMap没有及时清理，就会导致内存泄漏。</li>
</ul>
</li>
</ol>
<h4 id="弱引用解决部分内存泄漏问题"><a href="#弱引用解决部分内存泄漏问题" class="headerlink" title="弱引用解决部分内存泄漏问题"></a>弱引用解决部分内存泄漏问题</h4><p>为了解决ThreadLocal对象因为ThreadLocalMap中的key引用而无法被回收的问题，ThreadLocalMap使用了弱引用。</p>
<ul>
<li><strong>弱引用</strong>：如果一个对象只具有弱引用，那么这个对象就会在下次垃圾回收时被回收。</li>
<li>在ThreadLocalMap中，key（ThreadLocal对象）是弱引用。这意味着，当栈上的ThreadLocal引用不再使用时，ThreadLocal对象可以被垃圾回收器回收，从而避免了因为ThreadLocal对象无法被回收而导致的内存泄漏。</li>
</ul>
<p>然而，即使使用了弱引用，ThreadLocal的内存泄漏问题并没有完全解决。因为value（线程变量的值）还是强引用，如果线程对象被重复使用（如在线程池中），并且ThreadLocalMap没有及时清理，那么value所占用的内存仍然无法被回收。因此，开发者还需要在使用完ThreadLocal后，显式地调用<code>remove()</code>方法来清理ThreadLocalMap中的entry，以避免内存泄漏。</p>
<p>综上所述，ThreadLocal的内存泄漏问题是一个复杂的问题，需要开发者和JDK共同解决。JDK通过使用弱引用来解决了一部分问题，但开发者还需要在使用完ThreadLocal后显式地调用<code>remove()</code>方法来避免内存泄漏。<br>总之，ThreadLocal是一个强大的工具，它可以帮助我们在多线程环境中实现数据的隔离和线程安全。但是，使用时也需要注意其潜在的内存泄漏问题，特别是在使用线程池时。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/" itemprop="url">创建线程的方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p><strong>继承<code>Thread</code>类创建线程</strong>：</p>
<ul>
<li>这种方式是通过创建一个新的类，该类继承自<code>Thread</code>类，并重写<code>run</code>方法。然后，通过创建该类的实例并调用其<code>start</code>方法来启动线程。</li>
<li>优点：代码简单，易于理解。</li>
<li>缺点：由于Java是单继承的，继承<code>Thread</code>类后就不能再继承其他类了，这在一定程度上限制了类的扩展性。</li>
</ul>
</li>
<li><p><strong>实现<code>Runnable</code>接口创建线程</strong>：</p>
<ul>
<li>这种方式是通过创建一个实现了<code>Runnable</code>接口的类，并实现其<code>run</code>方法。然后，将该类的实例作为参数传递给<code>Thread</code>类的构造器，创建<code>Thread</code>对象并调用其<code>start</code>方法来启动线程。</li>
<li>优点：由于Java支持接口的多实现，因此这种方式更具灵活性，可以继承其他类并实现<code>Runnable</code>接口。</li>
<li>缺点：相对于继承<code>Thread</code>类，代码稍显复杂。</li>
</ul>
</li>
<li><p><strong>通过<code>Callable</code>和<code>FutureTask</code>创建线程</strong>：</p>
<ul>
<li><code>Callable</code>接口类似于<code>Runnable</code>接口，但它可以返回结果并且可以抛出受检异常（checked exception）。</li>
<li><code>FutureTask</code>是<code>Future</code>接口的一个实现，它包装了一个<code>Callable</code>对象，可以提交给<code>Executor</code>（如线程池）来执行。</li>
<li>这种方式通常用于需要获取线程执行结果或处理受检异常的场景。</li>
</ul>
</li>
<li><p><strong>通过线程池创建线程</strong>：</p>
<ul>
<li>线程池是提前创建好一批线程，并保存在池中。当有任务需要执行时，从池中取出一个线程来执行任务。这种方式可以显著提高资源的利用率和性能。</li>
<li>Java中的<code>ExecutorService</code>接口提供了管理线程池的方法，如<code>newFixedThreadPool</code>、<code>newCachedThreadPool</code>等。</li>
<li>优点：提高资源利用率、性能；简化线程管理。</li>
<li>缺点：增加了代码的复杂性；需要合理配置线程池的大小以避免资源耗尽或性能下降。</li>
</ul>
</li>
</ol>
<p>关于<code>Runnable</code>和<code>Callable</code>的区别：</p>
<ul>
<li><code>Runnable</code>的<code>run</code>方法无返回值，而<code>Callable</code>的<code>call</code>方法有返回值。</li>
<li><code>Callable</code>中可以抛出受检异常，而<code>Runnable</code>不可以。</li>
<li><code>Callable</code>和<code>Runnable</code>都可以应用于<code>executors</code>（执行器），但<code>Thread</code>类只支持<code>Runnable</code>。</li>
</ul>
<p>关于<code>Future</code>和<code>FutureTask</code>：</p>
<ul>
<li><code>Future</code>是一个接口，代表了一个异步执行的结果。它提供了检查执行是否完成、等待完成和获取执行结果的方法。</li>
<li><code>FutureTask</code>是<code>Future</code>接口的一个实现，它实现了一个可以提交给<code>Executor</code>执行的任务，并且可以用来检查任务的执行状态和获取任务的执行结果。</li>
</ul>
<p>最后，线程池是池化技术的一种典型实现，用于提高资源的利用率和性能。在编程中，线程池通常用于管理大量并发任务的执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E5%B9%B6%E5%8F%91/" itemprop="url">并发笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="同一时刻只能一个线程执行代码块"><a href="#同一时刻只能一个线程执行代码块" class="headerlink" title="同一时刻只能一个线程执行代码块"></a>同一时刻只能一个线程执行代码块</h3><h3 id="可以修饰方法和代码块"><a href="#可以修饰方法和代码块" class="headerlink" title="可以修饰方法和代码块"></a>可以修饰方法和代码块</h3><h3 id="如何实现可见性问题"><a href="#如何实现可见性问题" class="headerlink" title="如何实现可见性问题"></a>如何实现可见性问题</h3><ul>
<li><p>实现可见性的过程</p>
<ul>
<li><p>获取互斥锁</p>
</li>
<li><p>清空本地代码，将主内存中的最新拷贝到本地内存</p>
</li>
<li><p>将更改后共享变量值刷新到主内存</p>
</li>
<li><p>释放互斥锁</p>
</li>
</ul>
</li>
</ul>
<h3 id="如何实现同步"><a href="#如何实现同步" class="headerlink" title="如何实现同步"></a>如何实现同步</h3><ul>
<li><p>都是使用mointorenter和monitorexit两个JVM指令实现</p>
</li>
<li><p>什么是管程</p>
<ul>
<li><p>管理共享变量以及对共享变量操作过程，使得支持并发</p>
</li>
<li><p>线程可以对monitor执行lock和unlock操作进行加锁和释放锁</p>
</li>
<li><p>解决互斥问题的思路：将共享变量及对共享变量的操作统一封装起来</p>
</li>
</ul>
</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul>
<li><p>同步锁的四种状态：无锁、偏向锁、轻量级锁、重量级锁</p>
</li>
<li><p>偏向锁：一个线程加锁</p>
</li>
<li><p>轻量级锁：两个线程交替自旋</p>
</li>
<li><p>同步锁锁定资源是对象</p>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="可见性：对变量的修改对所有线程可见"><a href="#可见性：对变量的修改对所有线程可见" class="headerlink" title="可见性：对变量的修改对所有线程可见"></a>可见性：对变量的修改对所有线程可见</h3><ul>
<li><p>可见性</p>
<ul>
<li>volatile在写操作的时候，JVM会发一条lock前缀的指令，将这个缓存的变量会写到系统主存中；其他的使用的时候会从主存读取最新的数据。所以可见</li>
</ul>
</li>
</ul>
<h3 id="内存屏障（Memory-Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。"><a href="#内存屏障（Memory-Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。" class="headerlink" title="内存屏障（Memory Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。"></a>内存屏障（Memory Barrier）是CPU的一种指令，用于控制特定条件下的重排序和内存可见性问题。</h3><p>Java编译器会根据内存屏障的规则禁止重排序</p>
<ul>
<li><p>为了保障volatile变量的可见性和禁止指令重排序，java在字节码中插入内存屏障实现</p>
<ul>
<li><p>内存屏障解决指令重排</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有序性：禁止指令重排，遵循happens-before原则"><a href="#有序性：禁止指令重排，遵循happens-before原则" class="headerlink" title="有序性：禁止指令重排，遵循happens-before原则"></a>有序性：禁止指令重排，遵循happens-before原则</h3><h3 id="双重检验锁必须加volatile，因为内存屏障"><a href="#双重检验锁必须加volatile，因为内存屏障" class="headerlink" title="双重检验锁必须加volatile，因为内存屏障"></a>双重检验锁必须加volatile，因为内存屏障</h3><ul>
<li><p>双重校验锁实现一个单例</p>
</li>
<li><p>否则会出现空指针</p>
</li>
</ul>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul>
<li><p>不满足原子性</p>
<ul>
<li><p>解决方法</p>
<ul>
<li><p>使用syn</p>
</li>
<li><p>使用可重入锁</p>
</li>
<li><p>使用原子类</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="与syn的区别"><a href="#与syn的区别" class="headerlink" title="与syn的区别"></a>与syn的区别</h3><ul>
<li><p>volatile不需要加锁，不会阻塞线程</p>
</li>
<li><p>volatile是一种简单的同步机制</p>
</li>
</ul>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h3 id="CAS：一条CPU的原子指令，可以保证共享变量修改的原子性"><a href="#CAS：一条CPU的原子指令，可以保证共享变量修改的原子性" class="headerlink" title="CAS：一条CPU的原子指令，可以保证共享变量修改的原子性"></a>CAS：一条CPU的原子指令，可以保证共享变量修改的原子性</h3><ul>
<li><p>使用unsafe类实现，其中都是native方法</p>
</li>
<li><p>根据内存偏移量找到待更新的原值的准确内存地址，使用compareAndSwaplant将待更新的值和预期值进行比较</p>
</li>
<li><p>CAS缺陷</p>
<ul>
<li><p>循环时间太长</p>
</li>
<li><p>只能保证一个共享变量原子操作</p>
</li>
<li><p>ABA问题</p>
<ul>
<li>解决方案：AtomicStampedReference（加个时间作为版本号）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="问题：Thread-的join方法"><a href="#问题：Thread-的join方法" class="headerlink" title="问题：Thread 的join方法"></a>问题：Thread 的join方法</h3><h3 id="与syn的比较"><a href="#与syn的比较" class="headerlink" title="与syn的比较"></a>与syn的比较</h3><ul>
<li><p>syn在以下情况下释放锁</p>
<ul>
<li><p>线程执行完释放</p>
</li>
<li><p>线程执行时发生异常，JVM会自动释放</p>
</li>
<li><p>锁方法执行了wait方法，进行释放锁</p>
</li>
</ul>
</li>
<li><p>syn的问题</p>
<ul>
<li><p>无法控制阻塞时长——&gt;JUC trylock()解决</p>
</li>
<li><p>阻塞不可中断——&gt;lockInterruptibly解决</p>
</li>
<li><p>syn不支持读写锁分离——&gt;JUC的ReentrantReadWriteLock锁</p>
</li>
</ul>
</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><ul>
<li><p>先进先出队列+CAS+volatile</p>
<ul>
<li>维护一个volatile的int类型的state变量，state&#x3D;1是获取到锁；state的值变化是由CAS完成的</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><p>CAS操作提供原子性避免锁</p>
</li>
<li><p>volatile确保修改的可见性和内存操作的有序性</p>
</li>
</ul>
</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="解决并发问题，在线程中传递数据"><a href="#解决并发问题，在线程中传递数据" class="headerlink" title="解决并发问题，在线程中传递数据"></a>解决并发问题，在线程中传递数据</h3><h3 id="通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响"><a href="#通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响" class="headerlink" title="通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响"></a>通过为每一个线程创建一份共享变量的副本保证各个线程之间的变量访问和修改互不影响</h3><h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><ul>
<li><p>为什么</p>
<ul>
<li><p>key ThreadLocal的引用缘</p>
<ul>
<li><p>栈上的ThreadLocal引用</p>
</li>
<li><p>ThreadLocalMap中的key对他的引用</p>
</li>
</ul>
</li>
<li><p>value</p>
<ul>
<li>引用只有一条，从Thread过来的引用</li>
</ul>
</li>
<li><p>出现的问题</p>
<ul>
<li><p>ThreadLocal栈上的引用不见了，但是Threadlocal对象因为还有一个引用，索引无法回收</p>
<ul>
<li>解决方法：ThreadLocal的key改成弱引用</li>
</ul>
</li>
<li><p>Thread对象一直被使用，无法释放</p>
<ul>
<li>解决方法：对于value，Thread一直没有释放，只有在一个ThreadLocal用完的时候，手动调用一下remove方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>解决</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E6%8E%92%E5%BA%8F/" itemprop="url">Java中几种集合的排序方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>包括实现Comparable接口、借助Comparator比较器进行排序，以及通过Stream API进行排序。同时还解释了Comparable和Comparator的区别、compareTo和equals的使用场景差异，以及Set集合的排序问题。</li>
</ul>
<ol>
<li><strong>实现Comparable接口</strong>：<ul>
<li>Java中的类可以通过实现Comparable接口来具备排序能力。</li>
<li>实现Comparable接口的类需要重写compareTo方法，该方法定义了对象的排序规则。</li>
<li>例如，学生类（Student）可以实现Comparable接口，并按照姓名和年龄进行排序。</li>
</ul>
</li>
<li><strong>借助Comparator比较器进行排序</strong>：<ul>
<li>当类本身没有实现Comparable接口，或者需要不同的排序规则时，可以使用Comparator接口。</li>
<li>Comparator是一个函数式接口，可以独立于原类之外定义排序逻辑。</li>
<li>例如，可以使用Comparator对学生对象按照姓名和年龄进行排序。</li>
</ul>
</li>
<li><strong>通过Stream API进行排序</strong>：<ul>
<li>Java 8引入了Stream API，可以方便地对集合进行排序操作。</li>
<li>Stream API的sorted方法可以接受一个Comparator作为参数来进行排序。</li>
<li>例如，使用Stream对学生列表进行排序，可以简化排序的代码。</li>
</ul>
</li>
<li><strong>Comparable与Comparator的区别</strong>：<ul>
<li>Comparable用于使类本身具备排序能力，通过实现compareTo方法实现。</li>
<li>Comparator是一个独立的比较器，可以为不具备排序能力的类提供排序逻辑，或者提供不同的排序规则。</li>
</ul>
</li>
<li><strong>compareTo与equals的使用场景</strong>：<ul>
<li>compareTo主要用于排序和数值比较，如BigDecimal的比较。</li>
<li>equals主要用于判断两个对象在业务语义上是否相同，如String的比较通常使用equals来判断字面意义是否相同。</li>
</ul>
</li>
<li><strong>Set集合的排序问题</strong>：<ul>
<li>Set集合本身是无序的，即元素的插入顺序不保证。</li>
<li>但是，SortedSet接口可以保证元素的排序，通过要求元素实现Comparable接口来实现。</li>
<li>LinkedHashSet类通过双向链表记录插入顺序，实现了插入有序的Set。</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E6%AD%BB%E9%94%81/" itemprop="url">死锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>死锁是指两个或两个以上的进程（或线程）在执行过程中，因竞争资源或彼此通信而造成的一种阻塞现象。当这些进程都在等待对方释放资源时，就会形成一个无法打破的僵局，若无外力作用，它们都将无法继续执行。此时，系统处于死锁状态。</p>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ol>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li>
<li><strong>占有且等待</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不可抢占</strong>：进程已获得的资源，在未使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h3><p>解决死锁的方法主要分为预防死锁、避免死锁、检测死锁和解除死锁四种。</p>
<ol>
<li><p><strong>预防死锁</strong>：</p>
<ul>
<li>破坏互斥条件：允许资源被多个进程同时访问（但某些资源可能无法这样做）。</li>
<li>破坏占有且等待条件：要求进程一次性申请所有所需资源，或者允许进程在持有资源的同时申请其他资源（但可能降低系统效率）。</li>
<li>破坏不可抢占条件：允许进程被抢占已分配的资源（但可能导致数据不一致等问题）。</li>
<li>破坏循环等待条件：对资源编号，要求进程按编号顺序申请资源（但可能增加资源管理的复杂性）。</li>
</ul>
</li>
<li><p><strong>避免死锁</strong>：</p>
<ul>
<li>使用银行家算法等算法来动态地检查资源分配的安全性，确保系统不会进入不安全状态。</li>
<li>在资源分配过程中，采用资源预分配策略或资源按需分配策略，并监控系统的资源使用情况。</li>
</ul>
</li>
<li><p><strong>检测死锁</strong>：</p>
<ul>
<li>定期检查系统是否存在死锁现象，如使用资源分配图等方法。</li>
<li>一旦发现死锁，立即采取措施进行解除。</li>
</ul>
</li>
<li><p><strong>解除死锁</strong>：</p>
<ul>
<li>终止一个或多个进程，以打破循环等待条件。</li>
<li>回滚到安全状态，重新分配资源。</li>
<li>在数据库系统中，可以采用自动回滚事务、重启事务等方法来解除死锁。</li>
</ul>
</li>
</ol>
<h3 id="数据库死锁的发生与解决"><a href="#数据库死锁的发生与解决" class="headerlink" title="数据库死锁的发生与解决"></a>数据库死锁的发生与解决</h3><p>在数据库中，死锁通常发生在多个事务并发执行时。当事务A持有资源A的锁并尝试获取资源B的锁时，而事务B持有资源B的锁并尝试获取资源A的锁时，就会发生死锁。</p>
<p>解决数据库死锁的方法包括：</p>
<ul>
<li>避免并发修改：尽量减少多个事务对同一资源的并发访问。</li>
<li>保证操作顺序：确保多个事务按照相同的顺序访问资源。</li>
<li>使用锁超时机制：设置锁的超时时间，当事务持有锁超过一定时间时自动释放锁。</li>
<li>使用乐观锁或悲观锁等锁策略来管理资源访问。</li>
</ul>
<p>综上所述，死锁是并发系统中常见的问题之一。通过理解死锁的产生条件、掌握解决死锁的方法以及合理设计资源访问策略，可以有效地预防和解决死锁问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E7%BA%BF%E7%A8%8B/" itemprop="url">线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程状态的详细解释"><a href="#线程状态的详细解释" class="headerlink" title="线程状态的详细解释"></a>线程状态的详细解释</h3><ol>
<li><p><strong>初始(NEW)</strong></p>
<p>线程对象被创建，但尚未调用<code>start()</code>方法。此时线程还未开始执行，只是作为一个对象存在于内存中。</p>
</li>
<li><p><strong>运行(RUNNABLE)</strong></p>
<ul>
<li><strong>就绪(READY)</strong>: 线程对象创建后，通过调用<code>start()</code>方法启动。此时线程进入就绪状态，等待操作系统的调度，以获取CPU时间片。</li>
<li><strong>运行中(RUNNING)</strong>: 当就绪状态的线程获得CPU时间片时，开始执行程序代码，进入运行状态。</li>
</ul>
<p>在Java中，由于就绪和运行状态的切换非常频繁，且难以准确区分，因此将两者统称为“运行(RUNNABLE)”状态。</p>
</li>
<li><p><strong>阻塞(BLOCKED)</strong></p>
<p>线程尝试获取某个对象的锁（如通过<code>synchronized</code>关键字），但锁已被其他线程持有。此时线程进入阻塞状态，直到锁被释放并成功获取。</p>
</li>
<li><p><strong>等待(WAITING)</strong></p>
<p>线程通过调用<code>Object</code>类的<code>wait()</code>方法或其他等待方法（如<code>Condition</code>的<code>await()</code>方法）进入等待状态。此时线程需要等待其他线程的通知（通过<code>notify()</code>或<code>notifyAll()</code>方法）或中断来唤醒。</p>
</li>
<li><p><strong>超时等待(TIMED_WAITING)</strong></p>
<p>线程通过调用带有超时参数的等待方法（如<code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>等）进入超时等待状态。此时线程在指定的时间内等待，如果超时时间到达或收到其他线程的通知，则线程会被唤醒。</p>
</li>
<li><p><strong>终止(TERMINATED)</strong></p>
<p>线程执行完毕或由于异常等原因终止执行，进入终止状态。此时线程不再占用系统资源。</p>
</li>
</ol>
<h3 id="状态流转的细化"><a href="#状态流转的细化" class="headerlink" title="状态流转的细化"></a>状态流转的细化</h3><ul>
<li>从<strong>初始(NEW)<strong>到</strong>运行(RUNNABLE)</strong>: 调用<code>start()</code>方法。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>阻塞(BLOCKED)</strong>: 尝试获取锁失败。</li>
<li>从<strong>阻塞(BLOCKED)<strong>到</strong>运行(RUNNABLE)</strong>: 成功获取锁。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>等待(WAITING)</strong>: 调用<code>wait()</code>等方法。</li>
<li>从<strong>等待(WAITING)<strong>到</strong>运行(RUNNABLE)</strong>: 收到其他线程的通知或中断。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>超时等待(TIMED_WAITING)</strong>: 调用带有超时参数的等待方法。</li>
<li>从<strong>超时等待(TIMED_WAITING)<strong>到</strong>运行(RUNNABLE)</strong>: 超时时间到达或收到其他线程的通知。</li>
<li>从<strong>运行(RUNNABLE)<strong>到</strong>终止(TERMINATED)</strong>: 线程执行完毕或异常终止。</li>
</ul>
<h3 id="关于RUNNING状态的缺失"><a href="#关于RUNNING状态的缺失" class="headerlink" title="关于RUNNING状态的缺失"></a>关于RUNNING状态的缺失</h3><p>如你所述，由于CPU时间片的分配和线程状态的频繁切换，很难准确区分线程是处于就绪状态还是运行状态。因此，Java将两者统称为“运行(RUNNABLE)”状态，以表示线程当前是可执行的，只要获得CPU时间片就能立即执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解线程的状态及其流转对于编写高效、可靠的并发程序至关重要。通过合理管理线程状态，可以确保程序的正确性和性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>线程池的解释与实现原理</strong></p>
<p><strong>一、线程池的概念</strong></p>
<p>线程池是池化技术的一种典型实现，所谓池化技术就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化技术可以大大提高资源的利用率，提升性能等。线程池，即提前创建好一批线程，并保存在线程池中。当有任务需要执行时，从线程池中选一个线程来执行任务。这样可以避免频繁地创建和销毁线程，从而提高系统的效率和响应速度。</p>
<p><strong>二、线程池的实现</strong></p>
<ol>
<li><p><strong>Java中的线程池</strong></p>
<p>Java中的线程池通过实现<code>ExecutorService</code>接口来提供线程池的功能。<code>Executors</code>类提供了几种创建线程池的方法，如<code>newFixedThreadPool(int Threads)</code>创建固定数目线程的线程池，<code>newCachedThreadPool()</code>创建一个可缓存的线程池，<code>newSingleThreadExecutor()</code>创建一个单线程化的Executor，以及<code>newScheduledThreadPool(int corePoolSize)</code>创建一个支持定时及周期性的任务执行的线程池。</p>
</li>
<li><p><strong>线程池的主要参数</strong></p>
<ul>
<li><code>corePoolSize</code>：核心线程数量，可以类比为正式员工数量，常驻线程数量。</li>
<li><code>maximumPoolSize</code>：最大的线程数量，公司最多雇佣员工数量，包括常驻和临时线程数量。</li>
<li><code>workQueue</code>：多余任务等待队列，当任务数量超过当前线程处理能力时，任务会放入此队列等待执行。</li>
<li><code>keepAliveTime</code>：非核心线程空闲时间，即外包人员等待任务的时间，如果超过这个时间还没有任务执行，则会被销毁。</li>
<li><code>threadFactory</code>：创建线程的工厂，可以在这里统一设置创建的线程的属性。</li>
<li><code>handler</code>：线程池拒绝策略，当任务数量超过线程池的处理能力（包括核心线程、最大线程和任务队列）时，会执行此策略，默认是抛出异常。</li>
</ul>
</li>
<li><p><strong>线程池的工作原理</strong></p>
<p>线程池的工作流程大致如下：</p>
<ul>
<li>当有任务提交到线程池时，首先判断当前线程数量是否小于核心线程数量。如果是，则创建新的线程来执行任务。</li>
<li>如果当前线程数量已经达到核心线程数量，但任务队列未满，则将任务放入任务队列等待执行。</li>
<li>如果任务队列已满，但当前线程数量小于最大线程数量，则创建新的非核心线程来执行任务。</li>
<li>如果当前线程数量已经达到最大线程数量，且任务队列已满，则根据拒绝策略处理新提交的任务。</li>
</ul>
</li>
<li><p><strong>线程池的<code>execute</code>方法</strong></p>
<p><code>execute</code>方法是线程池的核心方法，用于向线程池中添加一个任务。该方法的实现逻辑相对复杂，但大致可以分为以下几个步骤：</p>
<ul>
<li>首先判断线程池的状态和当前线程数量，以及任务队列的状态。</li>
<li>如果满足条件，则尝试创建新的线程来执行任务。</li>
<li>如果不满足条件，则根据拒绝策略处理新提交的任务。</li>
</ul>
</li>
<li><p><strong>添加工作线程</strong></p>
<p>添加工作线程的过程是通过<code>addWorker</code>方法实现的。该方法首先判断线程池的状态和当前线程数量，然后尝试创建新的线程。创建线程的过程可能会受到多种因素的影响，如核心线程数量、最大线程数量、任务队列状态等。</p>
</li>
</ol>
<p><strong>三、总结</strong></p>
<p>线程池是一种高效的并发处理机制，通过提前创建并保存一批线程，当有任务需要执行时，从线程池中选取一个线程来执行任务。这样可以避免频繁地创建和销毁线程，从而提高系统的效率和响应速度。Java中的线程池通过实现<code>ExecutorService</code>接口来提供线程池的功能，并提供了多种创建线程池的方法和参数配置选项。了解线程池的工作原理和实现机制对于编写高效、可扩展的并发程序具有重要意义。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/10/10/%E9%9B%86%E5%90%88/" itemprop="url">java中的集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java中的集合类有哪些？如何分类的？"><a href="#Java中的集合类有哪些？如何分类的？" class="headerlink" title="Java中的集合类有哪些？如何分类的？"></a>Java中的集合类有哪些？如何分类的？</h1><h2 id="Java的集合框架中主要包含以下几种数据结构："><a href="#Java的集合框架中主要包含以下几种数据结构：" class="headerlink" title="Java的集合框架中主要包含以下几种数据结构："></a>Java的集合框架中主要包含以下几种数据结构：</h2><ol>
<li>List（列表）：有序集合，可以包含重复元素。常见的实现类有ArrayList（基于动态数组实现）和LinkedList（基于链表实现）。</li>
<li>Set（集合）：无序集合，不包含重复元素。常见的实现类有HashSet（基于哈希表实现）和TreeSet（基于红黑树实现）。</li>
<li>Queue（队列）：一种先进先出（FIFO）的数据结构。常见的实现类有LinkedList（也可以作为队列使用）、ArrayDeque（双端队列）和PriorityQueue（优先队列）。</li>
<li>Stack（栈）：一种后进先出（LIFO）的数据结构。在Java中，Stack类继承自Vector类，但现在推荐使用Deque接口的实现类（如ArrayDeque）来代替Stack。</li>
<li>Map（映射）：存储键值对（K-V对）的数据结构。常见的实现类有HashMap（基于哈希表实现）和TreeMap（基于红黑树实现）。</li>
</ol>
<p>从继承关系上讲，List、Set和Queue都是Collection接口的子接口，而Collection接口又继承了Iterable接口。这意味着这些集合都是可以遍历的。</p>
<p>从功能上讲：</p>
<ul>
<li>List代表一个有序容器，元素可以重复。</li>
<li>Set是无序的（除了TreeSet，它是有序的），并且元素不可重复。</li>
<li>Map存储键值对，通过键来访问值。</li>
</ul>
<p>从实现上讲：</p>
<ul>
<li>List可以通过链表（如LinkedList）或数组（如ArrayList）实现。</li>
<li>Queue可以有不同的实现，如优先队列（PriorityQueue）和双端队列（ArrayDeque）。</li>
<li>Map的实现包括普通的HashMap和可以排序的TreeMap。</li>
</ul>
<p>知识扩展：</p>
<p>Collection和Collections有什么区别？</p>
<ol>
<li>Collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法。它是List、Set等的父接口。</li>
<li>Collections是一个包装类，包含各种有关集合操作的静态多态方法。它不能实例化，就像一个工具类，服务于Java的Collection框架。</li>
</ol>
<p>Java中的Collection如何遍历迭代？</p>
<ol>
<li>传统的for循环遍历，基于计数器。</li>
<li>迭代器遍历，使用Iterator接口。</li>
<li>foreach循环遍历，内部也是采用了Iterator的方式实现。</li>
<li>迭代器遍历，使用Enumeration接口，这是Iterator的“古老版本”。</li>
<li>Stream API，JDK 1.8中新增，使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。</li>
</ol>
<p>Iterable和Iterator如何使用?</p>
<ul>
<li>Iterator接口代表迭代的方式，包含next和hasNext方法。</li>
<li>Iterable接口代表的是是否可以迭代，如果可以迭代，会返回Iterator接口，即返回迭代方式。</li>
</ul>
<p>为什么不把Iterable和Iterator合成一个使用？</p>
<ol>
<li>Iterable和Iterator并不是同时出现的，Iterator先于Iterable出现，目的是为了代替Enumeration。</li>
<li>将“是否可以迭代”和“迭代方式”抽出来，更符合单一职责原则，使得迭代方式可以被多个可迭代的集合复用，更符合面向对象的特点。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/10/Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/10/Stream/" itemprop="url">Stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-10T17:33:00+00:00">
                2024-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h3 id="Stream-API的深入理解"><a href="#Stream-API的深入理解" class="headerlink" title="Stream API的深入理解"></a>Stream API的深入理解</h3><p>Stream API是Java 8中引入的一个关键抽象概念，它允许你以声明性方式处理数据集合（包括数组等）。Stream通过一系列的操作（如筛选、转换、聚合等）来构建复杂的数据处理流水线。</p>
<h4 id="特性及优点详解"><a href="#特性及优点详解" class="headerlink" title="特性及优点详解"></a>特性及优点详解</h4><ol>
<li><p><strong>无存储</strong>：Stream本身不存储数据，它只是数据源的一个视图。这意味着你可以对原始数据集合进行多次Stream操作，而不会改变原始数据。</p>
</li>
<li><p><strong>为函数式编程而生</strong>：Stream API的设计符合函数式编程的范式，它鼓励使用不可变的数据和纯函数（即没有副作用的函数）。这使得代码更加简洁、易于理解和维护。</p>
</li>
<li><p><strong>惰式执行</strong>：Stream上的操作是惰式执行的，这意味着只有在需要结果时才会执行操作。这有助于优化性能，因为它允许Stream API在可能的情况下延迟计算，直到真正需要结果为止。</p>
</li>
<li><p><strong>可消费性</strong>：Stream只能被消费一次，一旦遍历过就会失效。这是为了保持流的不可变性，并防止在多个线程中同时修改流。</p>
</li>
</ol>
<h4 id="关键性操作"><a href="#关键性操作" class="headerlink" title="关键性操作"></a>关键性操作</h4><ul>
<li><p><strong>流的创建</strong>：可以通过集合的<code>stream()</code>或<code>parallelStream()</code>方法、<code>Stream.of()</code>方法或<code>Stream.Builder</code>来创建流。</p>
</li>
<li><p><strong>中间操作</strong>：这些操作会返回一个新的流，并允许你进行链式调用。常见的中间操作包括<code>filter()</code>（筛选）、<code>map()</code>（转换）、<code>flatMap()</code>（扁平化映射）、<code>sorted()</code>（排序）、<code>distinct()</code>（去重）等。</p>
</li>
<li><p><strong>最终操作</strong>：这些操作会触发流的计算，并返回一个结果或副作用。常见的最终操作包括<code>forEach()</code>（遍历）、<code>collect()</code>（收集到集合）、<code>reduce()</code>（归约）、<code>count()</code>（计数）等。</p>
</li>
</ul>
<h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><p>你给出的示例很好地展示了Stream API的使用场景。在这个示例中，你首先通过<code>filter()</code>筛选出非红色的球，然后通过<code>map()</code>将它们融化成随机的三角形，再通过另一个<code>filter()</code>筛选出非小的三角形，最后通过某种方式计算出剩余图形的周长。</p>
<p>这个示例展示了如何使用Stream API来构建一个复杂的数据处理流水线，并通过链式调用中间操作和最终操作来得到最终结果。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>Stream API在实际应用中非常有用，特别是在处理大型数据集时。它允许你以声明性方式编写代码，而不需要关心底层实现细节。此外，Stream API还支持并行处理，这使得它能够在多核处理器上更有效地利用计算资源。</p>
<p>总之，Stream API是Java 8中一个非常重要的特性，它极大地提高了Java程序员的生产力，并使得编写高效、简洁和易于维护的代码变得更加容易。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/10/Stream%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/10/Stream%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" itemprop="url">Stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-10T17:33:00+00:00">
                2024-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Stream的并行流是如何实现的"><a href="#Stream的并行流是如何实现的" class="headerlink" title="Stream的并行流是如何实现的"></a>Stream的并行流是如何实现的</h1><h3 id="Stream的并行流是如何实现的？"><a href="#Stream的并行流是如何实现的？" class="headerlink" title="Stream的并行流是如何实现的？"></a>Stream的并行流是如何实现的？</h3><p>在Java中，Stream API提供了一种高效且声明式的方式来处理数据集合。并行流（parallel stream）是Stream API中的一个重要特性，它允许开发者利用多核处理器的并行处理能力来提高数据处理的效率。</p>
<ol>
<li><p><strong>获取并行流</strong>：</p>
<ul>
<li>使用<code>Collection</code>接口的<code>parallelStream</code>方法，或者通过<code>Stream</code>接口的<code>parallel</code>方法将顺序流转换为并行流。</li>
</ul>
</li>
<li><p><strong>底层实现</strong>：</p>
<ul>
<li>并行流底层使用了Java 7中引入的Fork&#x2F;Join框架。</li>
<li>Fork&#x2F;Join框架旨在将一个大任务分割（fork）成多个小任务，这些小任务可以并行执行，然后再将这些小任务的结果合并（join）成最终结果。</li>
<li>这种分治策略非常适合处理可以递归分解的大规模计算任务。</li>
</ul>
</li>
<li><p><strong>执行方式</strong>：</p>
<ul>
<li>并行流通过并发运行的方式执行流的迭代及操作，从而充分利用多核处理器的性能。</li>
</ul>
</li>
</ol>
<h3 id="ForkJoinPool和ThreadPoolExecutor的区别"><a href="#ForkJoinPool和ThreadPoolExecutor的区别" class="headerlink" title="ForkJoinPool和ThreadPoolExecutor的区别"></a>ForkJoinPool和ThreadPoolExecutor的区别</h3><p>ForkJoinPool和ThreadPoolExecutor都是Java中用于管理线程和并行任务的工具，但它们在实现方式和适用场景上有所不同。</p>
<ol>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li><strong>ForkJoinPool</strong>：基于工作窃取（Work-Stealing）算法实现的线程池。它适用于处理可以递归分解的大规模计算任务。每个线程都有自己的双端队列（deque）来存储任务，当某个线程的任务队列为空时，它会从其他线程的队列中窃取任务来执行。</li>
<li><strong>ThreadPoolExecutor</strong>：基于任务队列和线程池的实现。它适用于处理不同类型的任务，包括计算密集型、IO密集型和混合型任务。ThreadPoolExecutor允许更灵活的任务调度和线程管理。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>ForkJoinPool</strong>：更适合处理可以递归分解的大规模计算任务，如排序、归并、搜索等。</li>
<li><strong>ThreadPoolExecutor</strong>：适用于更广泛的场景，包括异步执行、定时执行和周期性执行等。</li>
</ul>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li>ForkJoinPool通过工作窃取算法来减少线程之间的空闲时间，提高CPU利用率，但在任务划分不均衡时可能导致线程饥饿。</li>
<li>ThreadPoolExecutor的性能取决于任务类型、线程数量和任务队列的配置。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Stream的并行流是Java中处理大规模数据集合的高效工具，它底层使用了Fork&#x2F;Join框架来实现并行处理。而ForkJoinPool和ThreadPoolExecutor则是Java中用于管理线程和并行任务的两种不同实现方式，它们在实现方式、适用场景和性能上有所不同。开发者应根据具体的应用场景和需求选择合适的工具来优化程序的性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/10/synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/10/synchronized/" itemprop="url">synchronized</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-10T17:33:00+00:00">
                2024-09-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="1-synchronized-的使用方法"><a href="#1-synchronized-的使用方法" class="headerlink" title="1. synchronized 的使用方法"></a>1. synchronized 的使用方法</h3><ul>
<li><strong>同步方法</strong>：在方法声明时加上 <code>synchronized</code> 关键字，这样当某个线程调用这个方法时，会先获取到该方法的锁（通常是该方法所属对象的锁），其他线程必须等待锁被释放后才能调用这个方法。</li>
<li><strong>同步代码块</strong>：使用 <code>synchronized(对象)</code> 来定义一个同步代码块，这里的对象就是锁对象。当线程进入这个代码块时，会先尝试获取这个对象的锁，获取到锁后才能执行代码块中的代码。</li>
</ul>
<h3 id="2-synchronized-的实现机制"><a href="#2-synchronized-的实现机制" class="headerlink" title="2. synchronized 的实现机制"></a>2. synchronized 的实现机制</h3><ul>
<li><strong>方法级同步</strong>：对于同步方法，JVM 在方法的常量池中添加一个 <code>ACC_SYNCHRONIZED</code> 标志。当线程调用这个方法时，会检查这个标志，如果设置了该标志，则需要先获取到方法的锁（通常是该方法所属对象的监视器锁），然后开始执行方法，方法执行完毕后再释放锁。</li>
<li><strong>代码块级同步</strong>：对于同步代码块，JVM 使用 <code>monitorenter</code> 和 <code>monitorexit</code> 两条字节码指令来实现同步。<code>monitorenter</code> 指令用于获取锁，<code>monitorexit</code> 指令用于释放锁。每个对象都有一个监视器锁（monitor），当线程执行到 <code>monitorenter</code> 指令时，会尝试获取对象的监视器锁，如果获取成功，则计数器加一；当线程执行到 <code>monitorexit</code> 指令时，计数器减一。当计数器为 0 时，表示锁已经被释放，其他线程可以获取锁。</li>
</ul>
<h3 id="3-Monitor（监视器）"><a href="#3-Monitor（监视器）" class="headerlink" title="3. Monitor（监视器）"></a>3. Monitor（监视器）</h3><ul>
<li>Monitor 是 Java 中用于实现同步的一种机制，它可以看作是一个特殊的对象，这个对象包含了一个特殊的房间（Entry Set）和一个等待房间（Wait Set）。</li>
<li>当线程尝试获取对象的锁时，它会在 Entry Set 中等待，直到锁被释放。</li>
<li>如果线程在持有锁的过程中因为某些原因被挂起（比如调用了 <code>wait()</code> 方法），那么它会被移到 Wait Set 中，等待其他线程唤醒它（比如调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法）。</li>
<li>Monitor 保证了同一时间只有一个线程可以访问被保护的数据和代码。</li>
</ul>
<h3 id="4-synchronized-的特性"><a href="#4-synchronized-的特性" class="headerlink" title="4. synchronized 的特性"></a>4. synchronized 的特性</h3><ul>
<li><strong>互斥性</strong>：同一时间点，只有一个线程可以获得锁，获得锁的线程才能处理被 <code>synchronized</code> 修饰的代码片段。</li>
<li><strong>阻塞性</strong>：只有获得锁的线程才能执行被 <code>synchronized</code> 修饰的代码片段，未获得锁的线程只能阻塞，等待锁释放。</li>
<li><strong>可重入性</strong>：如果一个线程已经获得锁，在锁未释放之前，再次请求锁的时候，是必然可以获得锁的。这是因为 JVM 会维护一个锁计数器，当同一个线程多次获取锁时，计数器会递增；当释放锁时，计数器会递减，直到计数器为 0 时，锁才会被真正释放。</li>
</ul>
<p>综上所述，<code>synchronized</code> 通过在方法或代码块级别添加同步机制，利用对象的监视器锁来保证线程安全。它是 Java 中实现线程同步的一种简单而有效的手段。</p>
<p><code>synchronized</code> 是 Java 中用于保证线程安全的关键字，它通过一系列的机制来保证原子性、可见性和有序性。下面是对这三个方面的详细解释：</p>
<h2 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>原子性是指一个操作是不可中断的，即该操作要么全部执行，要么全部不执行。在并发编程中，原子性用于保证某个操作在执行过程中不会被其他线程打断。</p>
<p>在 Java 中，<code>synchronized</code> 通过 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令来保证原子性。当一个线程进入 <code>synchronized</code> 修饰的方法或代码块时，它会先尝试获取锁（通过 <code>monitorenter</code> 指令）。如果获取成功，则继续执行后续的代码；如果获取失败（因为锁已被其他线程持有），则该线程会被阻塞，直到锁被释放（通过 <code>monitorexit</code> 指令）为止。</p>
<p>由于 <code>synchronized</code> 保证了同一时间只有一个线程能够持有锁并执行相应的代码，因此它也就保证了这段代码在执行过程中的原子性。即使由于时间片耗尽或其他原因导致线程被中断，只要锁还没有被释放，该线程在下一次获得时间片时仍然会继续执行剩余的代码，直到完成。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改后的值。</p>
<p>Java 内存模型（JMM）规定了所有的变量都存储在主内存中，而每个线程都有自己的工作内存（也称为线程本地存储）。线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接读写主内存。这可能导致线程1修改了某个变量的值，但线程2由于还没有从主内存中刷新该变量的副本，因此看不到修改后的值。</p>
<p><code>synchronized</code> 关键字通过确保在进入同步块或同步方法时获取锁，并在退出时释放锁，来实现对变量的可见性保证。具体来说，当一个线程持有锁并执行同步代码块时，它会将自己工作内存中的变量副本更新到主内存中（在写操作时）。当其他线程尝试进入该同步代码块时，它们会先获取锁，并在获取锁后从主内存中读取最新的变量值到自己的工作内存中（在读操作时）。这样，就保证了线程之间对共享变量的可见性。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>有序性是指程序执行的顺序按照代码的先后顺序执行。然而，由于硬件和编译器的优化，指令可能会被重排序以提高性能。这种重排序在单线程环境下通常不会改变程序的执行结果，但在多线程环境下可能会导致问题。</p>
<p>Java 提供了 <code>as-if-serial</code> 语义来确保单线程程序的有序性。该语义要求编译器和处理器在优化时不能改变单线程程序的执行结果。然而，在多线程环境下，<code>as-if-serial</code> 语义并不能完全保证有序性。</p>
<p>为了解决这个问题，<code>synchronized</code> 关键字通过确保同一时间只有一个线程能够执行同步代码块来提供有序性保证。由于同步代码块在同一时间只能被一个线程执行，因此可以认为该代码块内的指令是按照它们在代码中出现的顺序执行的。这避免了由于指令重排序而导致的多线程问题。</p>
<p>总结来说，<code>synchronized</code> 通过确保同一时间只有一个线程能够执行同步代码块来提供原子性、可见性和有序性保证。这些特性使得 <code>synchronized</code> 成为 Java 中实现线程安全的一种重要手段。</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>这篇文章的核心内容是介绍了Java中synchronized关键字的锁升级过程，主要包括无锁、偏向锁、轻量级锁和重量级锁四种状态。以下是对这些核心内容的简要概述：</p>
<h3 id="1-无锁状态："><a href="#1-无锁状态：" class="headerlink" title="1.无锁状态："></a>1.无锁状态：</h3><ul>
<li>当一个线程第一次访问一个对象的同步块时，JVM会在对象头中设置该线程的Thread ID，并将对象头的状态位设置为“偏向锁”。</li>
</ul>
<h3 id="2-偏向锁："><a href="#2-偏向锁：" class="headerlink" title="2.偏向锁："></a>2.偏向锁：</h3><ul>
<li>当一个synchronized块被线程首次进入时，锁对象会进入偏向模式。</li>
<li>偏向锁模式下，锁会偏向于第一个获取它的线程，JVM会在对象头中记录该线程的ID作为偏向锁的持有者。</li>
<li>如果其他线程访问该对象，会先检查该对象的偏向锁标识，如果和自己的线程ID相同，则直接获取锁。如果不同，则该对象的锁状态就会升级到轻量级锁状态。</li>
<li>触发条件：首次进入synchronized块时自动开启，假设JVM启动参数没有禁用偏向锁。</li>
<li>注意：在JDK 15中，偏向锁已被废除。</li>
</ul>
<h3 id="3-轻量级锁："><a href="#3-轻量级锁：" class="headerlink" title="3.轻量级锁："></a>3.轻量级锁：</h3><ul>
<li>当有另一个线程尝试获取已被偏向的锁时，偏向锁会被撤销，锁会升级为轻量级锁。</li>
<li>在轻量级锁状态中，JVM为对象头中的Mark Word预留了一部分空间，用于存储指向线程栈中锁记录的指针。</li>
<li>当一个线程尝试获取轻量级锁时，JVM会：<ol>
<li>将对象头中的Mark Word复制到线程栈中的锁记录（Lock Record）。</li>
<li>尝试通过CAS操作更新对象头的Mark Word。</li>
</ol>
</li>
<li>如果替换成功，则该线程获取锁成功；如果失败，则表示已经有其他线程获取了锁，则该锁状态就会升级到重量级锁状态。</li>
<li>触发条件：当有另一个线程尝试获取已被偏向的锁时，偏向锁会升级为轻量级锁。</li>
</ul>
<h3 id="4-重量级锁："><a href="#4-重量级锁：" class="headerlink" title="4.重量级锁："></a>4.重量级锁：</h3><ul>
<li>当轻量级锁的CAS操作失败，即出现了实际的竞争，锁会进一步升级为重量级锁。</li>
<li>当锁状态升级到重量级锁状态时，JVM会将该对象的锁变成一个重量级锁，并在对象头中记录指向等待队列的指针。</li>
<li>如果一个线程想要获取该对象的锁（当前对象已被其他线程锁定时），则需要先进入等待队列，等待该锁被释放。当锁被释放时，JVM会从等待队列中选择一个线程唤醒，并将该线程的状态设置为“就绪”状态，然后等待该线程重新获取该对象的锁。</li>
<li>触发条件：当轻量级锁的CAS操作失败，轻量级锁升级为重量级锁。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/09/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url">微服务教程笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-09-01T13:33:41+00:00">
                2024-09-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CouponType-枚举类"><a href="#CouponType-枚举类" class="headerlink" title="CouponType 枚举类"></a>CouponType 枚举类</h1><pre><code>public static CouponType convert(String code) &#123;
    return Stream.of(values())
    .filter(bean -&gt; bean.code.equalsIgnoreCase(code))
    .findFirst()
    .orElse(UNKNOWN);
&#125;
</code></pre>
<ul>
<li><p>使用Long表示金额，金额通常以分为单位，比如100代表100分，比使用Double转 BigDecimal 有效</p>
</li>
<li><p>JPA支持一对多、多对多的级联关系，但是过深的级联层级带来的DB层压力可能在洪峰流量下太大，所以尽量减少级联配置，用单表查询取代；如果一个查询需要join多张表，最好的做法是通过重构业务逻辑来简化DB查询的复杂度；</p>
</li>
</ul>
<p>思考：java动态更新枚举类；</p>
<ul>
<li>stream 根据门店分组计算每个门店下商品价格（key&#x3D;shopId，value&#x3D;门店商品总价）<br>  public Map&lt;String,Long&gt; getTotal(List<Product> products){<br>  Map&lt;String, Long&gt; collect &#x3D; products.stream()<br>          .collect(Collectors.groupingBy(x -&gt; x.getProductId(),<br>                  Collectors.summingLong(x -&gt; x.getPrice() * x.getCount()))<br>          );<br>  return collect;<br>  }</Product></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2022/07/31/Date%E8%8E%B7%E5%8F%967%E5%A4%A9%E5%90%8E%E7%9A%84%E6%97%A5%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/31/Date%E8%8E%B7%E5%8F%967%E5%A4%A9%E5%90%8E%E7%9A%84%E6%97%A5%E6%9C%9F/" itemprop="url">Date获取7天后的日期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-31T13:33:41+00:00">
                2022-07-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、 DateUtils.addDays();</span><br><span class="line">2、 private static Date getAfterDay(Date date, int diff) &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.setTime(date == null ? new Date() : date);</span><br><span class="line">        calendar.add(Calendar.DATE, diff);</span><br><span class="line">        return calendar.getTime();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2022/07/31/SpringSecurity+%20oauth2%E5%AE%9E%E7%8E%B0%E5%90%8C%E8%B4%A6%E5%8F%B7%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%97%B6%E7%99%BB%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/31/SpringSecurity+%20oauth2%E5%AE%9E%E7%8E%B0%E5%90%8C%E8%B4%A6%E5%8F%B7%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%97%B6%E7%99%BB%E5%BD%95/" itemprop="url">SpringSecurity+ oauth2实现同账号多端同时登录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-31T13:33:41+00:00">
                2022-07-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringSecurity-oauth2实现同账号多端同时登录"><a href="#SpringSecurity-oauth2实现同账号多端同时登录" class="headerlink" title="SpringSecurity+ oauth2实现同账号多端同时登录"></a>SpringSecurity+ oauth2实现同账号多端同时登录</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67391377/article/details/126509478">https://blog.csdn.net/m0_67391377/article/details/126509478</a><br>    单点登录：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DGFFPl93kZxS5G_DSFTBDA">https://mp.weixin.qq.com/s/DGFFPl93kZxS5G_DSFTBDA</a><br>    多端登录：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhourenfei17/article/details/88826911">https://blog.csdn.net/zhourenfei17/article/details/88826911</a></p>
<h1 id="shiro中的Realm如何使用"><a href="#shiro中的Realm如何使用" class="headerlink" title="shiro中的Realm如何使用"></a>shiro中的Realm如何使用</h1><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_54849873/article/details/124345270">https://blog.csdn.net/m0_54849873/article/details/124345270</a></p>
<h1 id="shiro域（安全数据源）"><a href="#shiro域（安全数据源）" class="headerlink" title="shiro域（安全数据源）"></a>shiro域（安全数据源）</h1><pre><code>shiro从Realm获取安全的数据（例如用户，角色，权限等）
SecurityManager需要进行身份验证就必须从Realm中获取到一个合法的用户身份，从而比较用户身份是否合法，同时在SecurityManager获取身份的同时Realm也需要维护一套用户身份用来判断用户是否能执行某项操作
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2022/07/31/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/31/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%EF%BC%89/" itemprop="url">cookie和session的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-31T13:33:41+00:00">
                2022-07-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2024-11-11T05:27:47+00:00">
                2024-11-11
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="headerlink" title="cookie 和 session 的区别"></a>cookie 和 session 的区别</h1><h1 id="localstorage-和cookie-的区别"><a href="#localstorage-和cookie-的区别" class="headerlink" title="localstorage 和cookie 的区别"></a>localstorage 和cookie 的区别</h1><ul>
<li>都可以用来做本地存储，实现数据的持久化,区别如下<ul>
<li>localstroage存储的内容会多一点，5M；cookie存储的只有4k；</li>
<li>有效时间不一样；cookie 的有效时间可以自行设置，local可以一直生效；</li>
<li>请求时cookie可以被携带，同源的cookie信息会自动作为请求头的一部分发给服务端；local不会，一直存储在浏览器端</li>
</ul>
</li>
</ul>
<h1 id="localstroage-和sessionstroage-的区别"><a href="#localstroage-和sessionstroage-的区别" class="headerlink" title="localstroage 和sessionstroage 的区别"></a>localstroage 和sessionstroage 的区别</h1><ul>
<li>都是前端的本地存储（保存在客户端，不与服务器进行交互通信，存储数据的大小一样，只能存储字符串类型的数据）<ul>
<li>生命周期不同，local是永久的，除非主动删除；session的生命周期仅在当前会话下有效，在同源的窗口中始终存在的数据（只要浏览器的窗口没有关闭，即使刷新页面或者进入同源的另一个页面数据依旧存在，但在关闭浏览器窗口就会被销毁）</li>
</ul>
</li>
</ul>
<h1 id="session-和sessionStroage-的区别"><a href="#session-和sessionStroage-的区别" class="headerlink" title="session 和sessionStroage 的区别"></a>session 和sessionStroage 的区别</h1><ul>
<li>session主要的作用是维持会话状态的key，sessionStroage则是存储会话期间的数据</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
