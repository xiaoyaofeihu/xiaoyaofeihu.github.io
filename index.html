<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/06/%E5%9C%BA%E6%99%AF%E9%A2%98/%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/06/%E5%9C%BA%E6%99%AF%E9%A2%98/%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、前置校验（redis的lua脚本实现）"><a href="#一、前置校验（redis的lua脚本实现）" class="headerlink" title="一、前置校验（redis的lua脚本实现）"></a>一、前置校验（redis的lua脚本实现）</h2><p>1、检查库从是否充足<br>2、用户是否下单过该优惠券（使用Redis中的set类型来缓存下单该优惠券的用户id集合，并且要保证数据及时更新同步，即 在检验资格通过后需要向set中添加用户id）<br><strong>Lua脚本需要的ARGV参数列表中有两个待定参数，分别是优惠券id 以及 用户id</strong></p>
<h2 id="二、处理业务"><a href="#二、处理业务" class="headerlink" title="二、处理业务"></a>二、处理业务</h2><p>1、资格检验通过，则需要保证该有效订单被阻塞队列拿到，后续阻塞式执行成功，所以将“凭证”（封装好用户id、券id、订单id的订单实例）传入阻塞队列，等待异步线程阻塞式读取处理下单业务；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/02/Rabbitmq%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/02/Rabbitmq%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%9F/" itemprop="url">👌Rabbitmq如何避免消息丢失？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-02T13:33:41+00:00">
                2025-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Rabbitmq如何避免消息丢失？"><a href="#👌Rabbitmq如何避免消息丢失？" class="headerlink" title="👌Rabbitmq如何避免消息丢失？"></a>👌Rabbitmq如何避免消息丢失？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，rabbitmq 主要通过持久化机制，ack 确认机制，镜像等保证消息不丢失。rabbitmq 在创建队列的时候，可以设置为持久化队列，消息也可以设置为持久化消息，这样消息会被写入磁盘。即使重启，也不会产生丢失的问题。确认机制是我们平时最常见的机制，ack，消费者正常消费成功过消息后，会发出 ack 信号。mq 收到之后，才会认为消息成功消费，否则会认为消费失败，此时不会抛弃会让其他消费者继续进行消费。镜像队列是高可用的一种形式。可以确保一个节点挂了，另一个节点可以正常的存储消息，类似 redis 主从复制。以上。</p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p><strong>1、 持久化队列</strong>：创建队列时，可以将其声明为持久化队列（durable）。持久化队列在 RabbitMQ 重启后依然存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(&quot;queue_name&quot;, true, false, false, null);</span><br></pre></td></tr></table></figure>

<p><strong>2、 持久化消息</strong>：在发送消息时，可以将消息标记为持久化（persistent）。持久化消息会被写入磁盘，即使 RabbitMQ 重启，消息也不会丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties props = new AMQP.BasicProperties.Builder()</span><br><span class="line">    .deliveryMode(2) // 2 表示持久化消息</span><br><span class="line">    .build();</span><br><span class="line">channel.basicPublish(&quot;exchange_name&quot;, &quot;routing_key&quot;, props, messageBody);</span><br></pre></td></tr></table></figure>

<h2 id="消息确认机制（Acknowledgements）"><a href="#消息确认机制（Acknowledgements）" class="headerlink" title="消息确认机制（Acknowledgements）"></a>消息确认机制（Acknowledgements）</h2><p><strong>1、 消费者确认</strong>：消费者处理完消息后，向 RabbitMQ 发送确认（ack）。如果消费者未确认消息（如消费者崩溃），RabbitMQ 会将消息重新投递给其他消费者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 自动确认关闭</span><br><span class="line">channel.basicConsume(&quot;queue_name&quot;, false, consumer);</span><br><span class="line"></span><br><span class="line">// 消费者处理完消息后手动确认</span><br><span class="line">channel.basicAck(deliveryTag, false);</span><br></pre></td></tr></table></figure>

<p><strong>2、 发布者确认</strong>：发布者可以启用发布确认模式（publisher confirms），RabbitMQ 会在消息成功写入队列后发送确认给发布者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line">channel.basicPublish(&quot;exchange_name&quot;, &quot;routing_key&quot;, null, messageBody);</span><br><span class="line">channel.waitForConfirmsOrDie(); // 等待确认</span><br></pre></td></tr></table></figure>

<h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><p>RabbitMQ 支持 AMQP 事务，可以在一个事务中发布多条消息，确保这些消息要么全部成功，要么全部失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(&quot;exchange_name&quot;, &quot;routing_key&quot;, null, messageBody);</span><br><span class="line">channel.txCommit(); // 提交事务</span><br></pre></td></tr></table></figure>

<h2 id="镜像队列（Mirrored-Queues）"><a href="#镜像队列（Mirrored-Queues）" class="headerlink" title="镜像队列（Mirrored Queues）"></a>镜像队列（Mirrored Queues）</h2><p>RabbitMQ 的集群模式支持镜像队列（也称为高可用队列），可以将队列的数据复制到多个节点上，确保在一个节点故障时，其他节点仍然可以提供服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义队列策略，将队列配置为镜像队列</span><br><span class="line">rabbitmqctl set_policy ha-all &quot;^queue_name$&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="消费者重试机制"><a href="#消费者重试机制" class="headerlink" title="消费者重试机制"></a>消费者重试机制</h2><p>消费者可以实现重试机制，当消息处理失败时，可以将消息重新投递到队列或死信队列，避免消息丢失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 处理消息</span><br><span class="line">    channel.basicAck(deliveryTag, false);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    channel.basicNack(deliveryTag, false, true); // 重试</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/02/Spring/Aop%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/02/Spring/Aop%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/" itemprop="url">AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-02T13:33:41+00:00">
                2025-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Aop中的相关术语"><a href="#👌Aop中的相关术语" class="headerlink" title="👌Aop中的相关术语"></a>👌Aop中的相关术语</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>哈哈，这个就不多说了，面试官问到什么概念，你就直接解释一下就可以了。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h2><p>切面是 AOP 的核心概念之一，它是一个模块，包含了横切关注点的逻辑。切面可以看作是对某些功能（如日志记录、事务管理）的封装，这些功能会在特定的连接点上应用。</p>
<h2 id="连接点（Join-Point）"><a href="#连接点（Join-Point）" class="headerlink" title="连接点（Join Point）"></a>连接点（Join Point）</h2><p>连接点是程序执行过程中可以插入切面的一个点。通常，连接点是方法的调用或执行。AOP 框架允许在这些连接点上插入额外的行为。</p>
<h2 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h2><p>通知是在切面的某个特定的连接点上执行的动作。通知定义了切面在连接点上的具体行为。根据执行时间的不同，通知可以分为以下几种类型：</p>
<ul>
<li><strong>前置通知（Before）</strong>：在目标方法执行之前执行。</li>
<li><strong>后置通知（After）</strong>：在目标方法执行之后执行（无论方法是否成功完成）。</li>
<li><strong>返回通知（After Returning）</strong>：在目标方法成功返回之后执行。</li>
<li><strong>异常通知（After Throwing）</strong>：在目标方法抛出异常时执行。</li>
<li><strong>环绕通知（Around）</strong>：包围目标方法的执行，可以在方法执行之前和之后自定义行为。</li>
</ul>
<h2 id="切入点（Pointcut）"><a href="#切入点（Pointcut）" class="headerlink" title="切入点（Pointcut）"></a>切入点（Pointcut）</h2><p>切入点是一个表达式，定义了哪些连接点会被切面所影响。切入点表达式用于匹配连接点，从而决定切面应该应用到哪些方法上。常见的切入点表达式语言包括 AspectJ 的表达式语言。</p>
<h2 id="目标对象（Target-Object）"><a href="#目标对象（Target-Object）" class="headerlink" title="目标对象（Target Object）"></a>目标对象（Target Object）</h2><p>目标对象是被一个或多个切面所通知的对象。目标对象是 AOP 代理的实际对象，即被代理的对象。</p>
<h2 id="AOP-代理（AOP-Proxy）"><a href="#AOP-代理（AOP-Proxy）" class="headerlink" title="AOP 代理（AOP Proxy）"></a>AOP 代理（AOP Proxy）</h2><p>AOP 代理是一个对象，用于实现切面契约（即通知方法）并将调用委托给目标对象。代理对象负责在调用目标方法之前或之后执行切面逻辑。AOP 代理可以是 JDK 动态代理（用于代理接口）或 CGLIB 代理（用于代理类）。</p>
<h2 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h2><p>织入是将切面应用到目标对象并创建 AOP 代理对象的过程。织入可以在以下几个时机进行：</p>
<ul>
<li><strong>编译时（Compile-time Weaving）</strong>：在编译阶段将切面织入到目标类中。</li>
<li><strong>类加载时（Load-time Weaving）</strong>：在类加载阶段使用类加载器将切面织入到目标类中。</li>
<li><strong>运行时（Runtime Weaving）</strong>：在运行时通过动态代理将切面织入到目标对象中。</li>
</ul>
<h2 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h2><p>引入是 AOP 提供的一种机制，允许在不修改现有类的情况下向其添加新的方法或属性。引入可以用于增强现有类的功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/02/Spring/@Component%E5%92%8C@Bean%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/02/Spring/@Component%E5%92%8C@Bean%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/" itemprop="url">👌@Component和@Bean的区别是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-02T13:33:41+00:00">
                2025-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌-Component和-Bean的区别是什么"><a href="#👌-Component和-Bean的区别是什么" class="headerlink" title="👌@Component和@Bean的区别是什么"></a>👌@Component和@Bean的区别是什么</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>好的，面试官。component 和 bean 是非常常用的将类注册到容器中的注解。component 需要配合@ComponentScan注解使用，Spring 会自动扫描指定包及其子包中的所有类，找到带有@Component注解的类，并将它们注册为 Bean。@Bean 标记在方法上，方法所在的类需要用@Configuration注解标记。不需要扫描，主动的注入到 spring 容器中。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>经典的一道问题。两种方式都在实际工作中非常常见的使用。考察平时常见的扫描方式和假设有一个 bean 比如第三方，想要加载到容器中，不是类的形式，应该如何去做。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>自动扫描，ComponentScan，方法级别，@Configuration</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p><strong>用途</strong>：用于将一个类标记为 Spring 组件类，使其被 Spring 容器自动扫描并注册为 Bean。</p>
<p><strong>使用场景</strong>：通常用于标记那些需要自动检测和注册为 Bean 的类。</p>
<p><strong>位置</strong>：直接标记在类上。</p>
<p><strong>自动扫描</strong>：需要配合@ComponentScan注解使用，Spring 会自动扫描指定包及其子包中的所有类，找到带有@Component注解的类，并将它们注册为 Bean。</p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p><strong>用途</strong>：用于定义一个方法，该方法返回一个要注册为 Spring 容器管理的 Bean。</p>
<p><strong>使用场景</strong>：通常用于显式定义 Bean，特别是当需要一些复杂的初始化逻辑或需要从第三方库创建 Bean 时。</p>
<p><strong>位置</strong>：标记在方法上，方法所在的类需要用@Configuration注解标记。</p>
<p><strong>显式配置</strong>：通过显式的 Java 配置方式定义 Bean，而不是通过类路径扫描。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyComponent myComponent() &#123;</span><br><span class="line">        return new MyComponent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="详细比较"><a href="#详细比较" class="headerlink" title="详细比较"></a>详细比较</h2><p><strong>定义方式</strong>：</p>
<p>@Component：用于类级别，通过类路径扫描自动检测和注册。</p>
<p>@Bean：用于方法级别，通过显式的 Java 配置注册。</p>
<p><strong>使用场景</strong>：</p>
<p>@Component：适用于那些可以通过类路径扫描自动检测的类，通常是应用中的主要组件，如服务类、数据访问类等。</p>
<p>@Bean：适用于需要显式定义的 Bean，尤其是那些需要复杂初始化逻辑或从第三方库创建的 Bean。</p>
<p><strong>配置方式</strong>：</p>
<p>@Component：需要配合@ComponentScan使用，Spring 会自动扫描并注册。</p>
<p>@Bean：需要在@Configuration类中定义，显式地通过 Java 配置注册。</p>
<p><strong>灵活性</strong>：</p>
<p>@Component：更适合于常规的 Spring 组件，配置较为简单。</p>
<p>@Bean：提供了更高的灵活性，可以在方法中包含复杂的创建逻辑。</p>
<h2 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h2><p><strong>使用@Component</strong>：当你的类是应用中的主要组件，并且可以通过类路径扫描自动检测和注册时。例如，服务类、数据访问类、控制器类等。</p>
<p><strong>使用@Bean</strong>：当你需要显式定义 Bean，特别是那些需要复杂初始化逻辑或从第三方库创建的 Bean 时。例如，配置第三方库的 Bean、需要自定义初始化逻辑的 Bean 等。</p>
<h2 id="代码-Demo"><a href="#代码-Demo" class="headerlink" title="代码 Demo"></a>代码 Demo</h2><h4 id="使用-Component和-ComponentScan："><a href="#使用-Component和-ComponentScan：" class="headerlink" title="使用@Component和@ComponentScan："></a>使用@Component和@ComponentScan：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComponent &#123;</span><br><span class="line">    // 组件逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.example&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // 配置类内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Bean和-Configuration："><a href="#使用-Bean和-Configuration：" class="headerlink" title="使用@Bean和@Configuration："></a>使用@Bean和@Configuration：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyComponent myComponent() &#123;</span><br><span class="line">        return new MyComponent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/02/Spring/ApplicationContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/02/Spring/ApplicationContext%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">ApplicationContext的实现类有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-02T13:33:41+00:00">
                2025-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌ApplicationContext的实现类有哪些？"><a href="#👌ApplicationContext的实现类有哪些？" class="headerlink" title="👌ApplicationContext的实现类有哪些？"></a>👌ApplicationContext的实现类有哪些？</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>好的，面试官。常用的只要用 classpathxml 的基于 xml 的方式，annotion 的基于注解的方式，不常见的还有 web 和 groovy。在目前的实际情况下，主要是 annotion，注解形式放入到容器中。像老的 tomcat 那种方式，用的是 web 形式，不过现在都是 boot 注解形式够用。groovy 适用于一些动态加载 bean 的方式，通过脚本的形式处理。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>经典题，问的还比较多，主要是想借此考察一下，你在项目中，都用过什么样的形式的。其实主要答出注解和 xml 这道题就 ok。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>xml，注解，web，groovy</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="基于XML配置的实现类"><a href="#基于XML配置的实现类" class="headerlink" title="基于XML配置的实现类"></a>基于XML配置的实现类</h2><p><strong>ClassPathXmlApplicationContext：</strong>从类路径下加载XML配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>FileSystemXmlApplicationContext：</strong>从文件系统路径加载XML配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new FileSystemXmlApplicationContext(&quot;C:/path/to/applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="基于注解配置的实现类"><a href="#基于注解配置的实现类" class="headerlink" title="基于注解配置的实现类"></a>基于注解配置的实现类</h2><p><strong>AnnotationConfigApplicationContext：</strong>从Java配置类（使用@Configuration注解的类）加载配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure>

<h2 id="基于Web应用的实现类"><a href="#基于Web应用的实现类" class="headerlink" title="基于Web应用的实现类"></a>基于Web应用的实现类</h2><p><strong>XmlWebApplicationContext：</strong>专门为Web应用设计的ApplicationContext实现类，从Web应用的上下文中加载XML配置文件。</p>
<p>通常在web.xml中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<p><strong>AnnotationConfigWebApplicationContext：</strong>专门为Web应用设计的ApplicationContext实现类，从Java配置类加载配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WebAppInitializer implements WebApplicationInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext container) &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(AppConfig.class);</span><br><span class="line">        container.addListener(new ContextLoaderListener(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于Groovy配置的实现类"><a href="#基于Groovy配置的实现类" class="headerlink" title="基于Groovy配置的实现类"></a>基于Groovy配置的实现类</h2><p><strong>GenericGroovyApplicationContext：</strong>从Groovy脚本配置文件加载配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new GenericGroovyApplicationContext(&quot;applicationContext.groovy&quot;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/02/Spring/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/02/Spring/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" itemprop="url">BeanFactory 和 ApplicationContext 的区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-02T13:33:41+00:00">
                2025-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌BeanFactory-和-ApplicationContext-的区别？"><a href="#👌BeanFactory-和-ApplicationContext-的区别？" class="headerlink" title="👌BeanFactory 和 ApplicationContext 的区别？"></a>👌BeanFactory 和 ApplicationContext 的区别？</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>好的，面试官。BeanFactory和ApplicationContext都是用于管理Bean的容器接口。BeanFactory功能相对简单。提供了Bean的创建、获取和管理功能。默认采用延迟初始化，只有在第一次访问Bean时才会创建该Bean。因为功能较为基础，BeanFactory通常用于资源受限的环境中，比如移动设备或嵌入式设备。ApplicationContext是BeanFactory的子接口，提供了更丰富的功能和更多的企业级特性。默认会在启动时创建并初始化所有单例Bean，支持自动装配Bean，可以根据配置自动注入依赖对象。有多种实现，如ClassPathXmlApplicationContext、FileSystemXmlApplicationContext、AnnotationConfigApplicationContext等。以上</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>经典题，早几年爱考，现在随着时间的发展，问的比较少，不排除古老面试官，应届生可以重点看一下。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>初始化时机，延迟，企业级应用场景</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>BeanFactory和ApplicationContext都是用于管理Bean的容器接口，它们的功能和用途有所不同。</p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>BeanFactory是Spring框架的核心接口之一，负责管理和配置应用程序中的Bean。它提供了基本的Bean容器功能，但功能相对简单。BeanFactory提供了Bean的创建、获取和管理功能。它是Spring IoC容器的最基本接口。</p>
<p>BeanFactory默认采用延迟初始化（lazy loading），即只有在第一次访问Bean时才会创建该Bean。这有助于提升启动性能。</p>
<p>因为功能较为基础，BeanFactory通常用于资源受限的环境中，比如移动设备或嵌入式设备。</p>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext是BeanFactory的子接口，提供了更丰富的功能和更多的企业级特性。</p>
<p>不仅提供了BeanFactory的所有功能，还提供了更多高级特性，如事件发布、国际化、AOP、自动Bean装配等。</p>
<p>ApplicationContext默认会在启动时创建并初始化所有单例Bean（除非显式配置为延迟初始化）。这有助于在应用启动时尽早发现配置问题。</p>
<p>ApplicationContext支持自动装配Bean，可以根据配置自动注入依赖对象。</p>
<p>ApplicationContext有多种实现，如ClassPathXmlApplicationContext、FileSystemXmlApplicationContext、AnnotationConfigApplicationContext等，适用于不同的配置方式和场景。</p>
<h2 id="具体区别总结"><a href="#具体区别总结" class="headerlink" title="具体区别总结"></a>具体区别总结</h2><table>
<thead>
<tr>
<th></th>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td><strong>初始化时机</strong></td>
<td>延迟初始化，只有在第一次访问Bean时才创建该Bean。</td>
<td>立即初始化，在容器启动时就创建并初始化所有单例Bean。</td>
</tr>
<tr>
<td><strong>特性</strong></td>
<td>功能较为基础，只提供Bean的创建、获取和管理功能。</td>
<td>提供更多企业级特性，如事件发布、国际化、AOP、自动装配等。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>适用于资源受限的环境，或者需要延迟初始化的场景。</td>
<td>适用于大多数企业级应用</td>
</tr>
</tbody></table>
<h2 id="代码-Demo"><a href="#代码-Demo" class="headerlink" title="代码 Demo"></a>代码 Demo</h2><h4 id="使用-BeanFactory"><a href="#使用-BeanFactory" class="headerlink" title="使用 BeanFactory"></a>使用 BeanFactory</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource resource = new ClassPathResource(&quot;beans.xml&quot;);</span><br><span class="line">BeanFactory beanFactory = new XmlBeanFactory(resource);</span><br><span class="line">MyBean myBean = (MyBean) beanFactory.getBean(&quot;myBean&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="使用-ApplicationContext"><a href="#使用-ApplicationContext" class="headerlink" title="使用 ApplicationContext"></a>使用 ApplicationContext</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">MyBean myBean = (MyBean) context.getBean(&quot;myBean&quot;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/03/02/Spring/Bean%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/02/Spring/Bean%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7_/" itemprop="url">Bean 标签的属性？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-03-02T13:33:41+00:00">
                2025-03-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Bean-标签的属性"><a href="#👌Bean-标签的属性" class="headerlink" title="👌Bean 标签的属性?"></a>👌Bean 标签的属性?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官。bean 是最长使用的标签，如果是使用 xml 形式。最常见的基本属性就是 id，name，class。分别标识唯一的 bean，bean 的别名和实际要注入的类。也可以通过一些属性实现，bean 开始时候的操作，比如init-method，配置的方法，可以在 bean 初始化的时候，进行执行。bean 还有常见的构造函数注入标签，注入 bean 中的属性。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>应届生常问，有工作经验的基本不问，目的其实就是为了，考察一下你到底有没有实际使用过 spring 的 bean 的配置。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>id，name，class，一些初始化属性</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><p><strong>id：</strong>Bean的唯一标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>name：</strong>Bean的别名，可以为Bean定义一个或多个别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; name=&quot;alias1,alias2&quot; class=&quot;com.example.MyBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>class：</strong>Bean的全限定类名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>scope：</strong>Bean的作用域，常见值包括singleton（默认）、prototype、request、session、globalSession、application。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>init-method：</strong>Bean初始化时调用的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>destroy-method：</strong>Bean销毁时调用的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; destroy-method=&quot;cleanup&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>factory-method：</strong>用于创建Bean实例的静态工厂方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBeanFactory&quot; factory-method=&quot;createInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>factory-bean：</strong>用于创建Bean实例的工厂Bean的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myFactory&quot; class=&quot;com.example.MyFactory&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;myBean&quot; factory-bean=&quot;myFactory&quot; factory-method=&quot;createInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="依赖注入相关属性"><a href="#依赖注入相关属性" class="headerlink" title="依赖注入相关属性"></a>依赖注入相关属性</h2><p><strong>constructor-arg：</strong>用于构造函数注入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;someValue&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;anotherBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>property：</strong>用于Setter方法注入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;propertyName&quot; value=&quot;someValue&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;anotherProperty&quot; ref=&quot;anotherBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="其他常用属性"><a href="#其他常用属性" class="headerlink" title="其他常用属性"></a>其他常用属性</h2><p><strong>autowire：</strong>自动装配模式，常见值包括no（默认）、byName、byType、constructor、autodetect。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; autowire=&quot;byName&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>depends-on：</strong>指定Bean的依赖关系，即在初始化当前Bean之前需要先初始化的Bean。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; depends-on=&quot;anotherBean&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>lazy-init：</strong>是否延迟初始化，默认值为false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; lazy-init=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>primary：</strong>当自动装配时，如果有多个候选Bean，可以将某个Bean标记为主要候选者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; primary=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="配置-demo"><a href="#配置-demo" class="headerlink" title="配置 demo"></a>配置 demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; scope=&quot;singleton&quot; init-method=&quot;init&quot; destroy-method=&quot;cleanup&quot; lazy-init=&quot;true&quot; primary=&quot;true&quot; autowire=&quot;byType&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;someValue&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;anotherBean&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;propertyName&quot; value=&quot;someValue&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;anotherProperty&quot; ref=&quot;anotherBean&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/22/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/22/MyBatis%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E8%A1%A8/" itemprop="url">MyBatis拦截器实现分表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-22T17:33:00+00:00">
                2025-02-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E8%A1%A8/" itemprop="url" rel="index">
                    <span itemprop="name">分表</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌MyBatis拦截器实现分表"><a href="#👌MyBatis拦截器实现分表" class="headerlink" title="👌MyBatis拦截器实现分表"></a>👌MyBatis拦截器实现分表</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><font style="color:rgb(47, 48, 52);">背景</font></h1><p><font style="color:rgb(47, 48, 52);">所负责的业务中有一个 xx 系统，其中的 xx 核心表增长速度非常快，每日增长 200W 的数据量，业务特性主要是查询最近一周的数据，那么随着数据量越来越多，查询性能疯狂下降。这是典型的冷热数据场景，于是要开始进行冷热分离的操作。</font></p>
<p><font style="color:rgb(47, 48, 52);">常见的两种方案，一种是删除&#x2F;归档旧数据，一种是数据分表。</font></p>
<h1 id><a href="#" class="headerlink" title></a><font style="color:rgb(47, 48, 52);"></font></h1><p><font style="color:rgb(47, 48, 52);">方案选择</font></p>
<h2 id="归档-x2F-删除旧数据"><a href="#归档-x2F-删除旧数据" class="headerlink" title="归档&#x2F;删除旧数据"></a><font style="color:rgb(47, 48, 52);">归档&#x2F;删除旧数据</font></h2><p><font style="color:rgb(47, 48, 52);">这种方式最常见的发难就是将冷数据移动到归档表或者直接进行删除，从而减少表的大小。</font></p>
<p><font style="color:rgb(47, 48, 52);">实现思路非常简单，一般写一个定时任务不断的跑就可以了。</font></p>
<p><font style="color:rgb(47, 48, 52);">缺点：</font></p>
<p><font style="color:rgb(47, 48, 52);">1、数据删除会影响数据库性能，引发慢sql，多张表并行删除，数据库压力会更大。</font></p>
<p><font style="color:rgb(47, 48, 52);">2、频繁删除数据，会产生数据库碎片，影响数据库性能，引发慢SQL。</font></p>
<p><font style="color:rgb(47, 48, 52);">有一定的风险，选择另一种分表的方案。</font></p>
<h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a><font style="color:rgb(47, 48, 52);">分表</font></h2><p><font style="color:rgb(47, 48, 52);">业务特性是查最近的一周的数据，按日期的水平拆分是合理的。每周生成一张新表，同时此表只放本周的数据，这样表内数据量得到了控制，不会很大。</font></p>
<h3 id="分表方案选型"><a href="#分表方案选型" class="headerlink" title="分表方案选型"></a><font style="color:rgb(47, 48, 52);">分表方案选型</font></h3><p><font style="color:rgb(47, 48, 52);">分别常见的主要考虑2种分表方案：Sharding-JDBC、利用Mybatis自带的拦截器特性。</font></p>
<p><font style="color:rgb(47, 48, 52);">经过对比后，决定采用Mybatis拦截器来实现分表。</font></p>
<p><font style="color:rgb(47, 48, 52);">1、JAVA生态中很常用的分表框架是Sharding-JDBC，虽然功能强大，但需要一定的接入成本，并且很多功能暂时用不上。</font></p>
<p><font style="color:rgb(47, 48, 52);">2、系统本身已经在使用Mybatis了，只需要添加一个mybaits拦截器，把SQL表名替换为新的周期表就可以了，没有接入新框架的成本，开发成本也不高。</font></p>
<h3 id="分表具体实现思路"><a href="#分表具体实现思路" class="headerlink" title="分表具体实现思路"></a><font style="color:rgb(47, 48, 52);">分表具体实现思路</font></h3><p>1、通过拦截器获取表名</p>
<p><font style="color:rgb(51, 51, 51);">String tableName &#x3D; TemplateMatchService.matchTableName(boundSql.getSql().trim());</font></p>
<p>2、根据数据日期进行计算后缀</p>
<p>3、替换原有 sql，最终执行。</p>
<p><font style="color:rgb(51, 51, 51);"> String rebuildSql &#x3D; boundSql.getSql().replace(shardingProperty.getTableName(), shardingTable);</font></p>
<p><font style="color:rgb(51, 51, 51);"> metaStatementHandler.setValue(ORIGIN_BOUND_SQL, rebuildSql);</font></p>
<font style="color:rgb(47, 48, 52);">  
</font>

<font style="color:rgb(0, 0, 0);">  
</font>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">Linux中断机制是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-20T13:33:41+00:00">
                2025-02-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Linux中断机制是什么？"><a href="#👌Linux中断机制是什么？" class="headerlink" title="👌Linux中断机制是什么？"></a>👌Linux中断机制是什么？</h1><p>Linux中断机制是操作系统处理硬件和软件事件的一种重要方式。中断可以使操作系统及时响应各种事件，如硬件设备的输入输出操作、定时器事件等。</p>
<h3 id="中断的基本概念"><a href="#中断的基本概念" class="headerlink" title="中断的基本概念"></a>中断的基本概念</h3><h4 id="1-中断类型"><a href="#1-中断类型" class="headerlink" title="1.中断类型"></a>1.<strong>中断类型</strong></h4><ul>
<li><strong>硬件中断</strong>：由硬件设备（如键盘、网卡、硬盘等）发出的信号，引起CPU中断当前执行的程序，转而执行中断处理程序。</li>
<li><strong>软件中断</strong>：由软件指令（如系统调用、异常等）引发的中断。</li>
</ul>
<h4 id="2-中断向量表"><a href="#2-中断向量表" class="headerlink" title="2.中断向量表"></a>2.<strong>中断向量表</strong></h4><p>中断向量表（Interrupt Vector Table, IVT）是一个包含中断服务程序地址的表。当中断发生时，CPU通过中断向量表找到相应的中断服务程序并执行。</p>
<h3 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h3><ol>
<li><strong>中断发生</strong>：硬件设备或软件事件发出中断信号。</li>
<li><strong>中断响应</strong>：CPU停止当前执行的程序，保存当前的上下文（如程序计数器、寄存器等），并根据中断向量表找到对应的中断服务程序。</li>
<li><strong>中断处理</strong>：执行中断服务程序，处理中断事件。</li>
<li><strong>中断返回</strong>：中断处理完成后，恢复保存的上下文，继续执行被中断的程序。</li>
</ol>
<h3 id="中断处理的关键组件"><a href="#中断处理的关键组件" class="headerlink" title="中断处理的关键组件"></a>中断处理的关键组件</h3><h4 id="1-中断控制器"><a href="#1-中断控制器" class="headerlink" title="1.中断控制器"></a>1.<strong>中断控制器</strong></h4><p>中断控制器（如PIC、APIC）负责管理和分配中断请求。它可以屏蔽不需要的中断，并确定中断的优先级。</p>
<h4 id="2-中断处理程序"><a href="#2-中断处理程序" class="headerlink" title="2.中断处理程序"></a>2.<strong>中断处理程序</strong></h4><p>中断处理程序（Interrupt Service Routine, ISR）是处理特定中断事件的函数。它通常分为顶半部（Top Half）和底半部（Bottom Half）：</p>
<ul>
<li><strong>顶半部</strong>：快速响应中断，执行紧急的处理任务。</li>
<li><strong>底半部</strong>：延迟执行较长时间的任务，以减少顶半部的执行时间，避免阻塞其他中断。</li>
</ul>
<h4 id="3-中断上下文"><a href="#3-中断上下文" class="headerlink" title="3.中断上下文"></a>3.<strong>中断上下文</strong></h4><p>中断上下文是指中断发生时CPU的状态，包括程序计数器、寄存器等。保存和恢复中断上下文是中断处理的关键步骤。</p>
<h3 id="中断处理的实现"><a href="#中断处理的实现" class="headerlink" title="中断处理的实现"></a>中断处理的实现</h3><h4 id="1-注册中断处理程序"><a href="#1-注册中断处理程序" class="headerlink" title="1.注册中断处理程序"></a>1.<strong>注册中断处理程序</strong></h4><p>在Linux内核中，可以使用<code>request_irq</code>函数注册中断处理程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/interrupt.h&gt;</span><br><span class="line"></span><br><span class="line">int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);</span><br></pre></td></tr></table></figure>

<h4 id="2-中断处理程序示例"><a href="#2-中断处理程序示例" class="headerlink" title="2.中断处理程序示例"></a>2.<strong>中断处理程序示例</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/interrupt.h&gt;</span><br><span class="line"></span><br><span class="line">static irqreturn_t my_interrupt_handler(int irq, void *dev_id) &#123;</span><br><span class="line">    printk(KERN_INFO &quot;Interrupt occurred!\n&quot;);</span><br><span class="line">    // 中断处理逻辑</span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int __init my_module_init(void) &#123;</span><br><span class="line">    int irq = 1; // 假设中断号为1</span><br><span class="line">    int result = request_irq(irq, my_interrupt_handler, IRQF_SHARED, &quot;my_interrupt&quot;, NULL);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        printk(KERN_ERR &quot;Failed to request IRQ\n&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit my_module_exit(void) &#123;</span><br><span class="line">    int irq = 1; // 假设中断号为1</span><br><span class="line">    free_irq(irq, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A simple interrupt handler module&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;Your Name&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="3-顶半部和底半部"><a href="#3-顶半部和底半部" class="headerlink" title="3.顶半部和底半部"></a>3.<strong>顶半部和底半部</strong></h4><ul>
<li><strong>顶半部</strong>：快速处理中断的关键部分。</li>
<li><strong>底半部</strong>：使用任务队列、工作队列或软中断机制延迟处理较长时间的任务。</li>
</ul>
<h3 id="中断的优先级和屏蔽"><a href="#中断的优先级和屏蔽" class="headerlink" title="中断的优先级和屏蔽"></a>中断的优先级和屏蔽</h3><p>中断控制器可以设置中断的优先级和屏蔽某些中断，以确保重要的中断优先得到处理。APIC（Advanced Programmable Interrupt Controller）提供了更高级的中断管理功能，如多级中断优先级和分布式中断处理。</p>
<h3 id="中断的嵌套和重入"><a href="#中断的嵌套和重入" class="headerlink" title="中断的嵌套和重入"></a>中断的嵌套和重入</h3><p>中断处理程序应尽量短小精悍，以减少中断嵌套的层数。中断处理程序应避免使用可能导致阻塞的操作，如长时间的I&#x2F;O操作和锁定操作。</p>
<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jsyun/vwxwc6">https://www.yuque.com/jsyun/vwxwc6</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%EF%BC%9F/" itemprop="url">Linux查看文件磁盘占用情况</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-20T13:33:41+00:00">
                2025-02-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Linux查看文件磁盘占用情况？"><a href="#👌Linux查看文件磁盘占用情况？" class="headerlink" title="👌Linux查看文件磁盘占用情况？"></a>👌Linux查看文件磁盘占用情况？</h1><h3 id="1-du命令"><a href="#1-du命令" class="headerlink" title="1.du命令"></a>1.<code>du</code>命令</h3><p><code>du</code>（disk usage）命令用于估算文件和目录的磁盘使用情况。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [文件或目录]</span><br></pre></td></tr></table></figure>

<h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul>
<li><code>-h</code>：以人类可读的格式显示（例如，K、M、G）。</li>
<li><code>-s</code>：显示总计（不显示子目录的详细信息）。</li>
<li><code>-a</code>：包括所有文件和目录。</li>
<li><code>-c</code>：显示总计。</li>
<li><code>--max-depth=N</code>：限制显示的目录层级深度。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>查看当前目录下每个文件和子目录的磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h</span><br></pre></td></tr></table></figure>

<ul>
<li>查看指定目录的总磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /path/to/directory</span><br></pre></td></tr></table></figure>

<ul>
<li>查看指定目录及其子目录的磁盘使用情况，限制深度为1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1 /path/to/directory</span><br></pre></td></tr></table></figure>

<h3 id="2-df命令"><a href="#2-df命令" class="headerlink" title="2.df命令"></a>2.<code>df</code>命令</h3><p><code>df</code>（disk free）命令用于查看文件系统的磁盘使用情况。</p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项] [文件或目录]</span><br></pre></td></tr></table></figure>

<h4 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h4><ul>
<li><code>-h</code>：以人类可读的格式显示（例如，K、M、G）。</li>
<li><code>-T</code>：显示文件系统类型。</li>
<li><code>-i</code>：显示inode使用情况。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul>
<li>查看所有挂载的文件系统的磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>

<ul>
<li>查看特定目录所在的文件系统的磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h /path/to/directory</span><br></pre></td></tr></table></figure>

<h3 id="3-ncdu工具"><a href="#3-ncdu工具" class="headerlink" title="3.ncdu工具"></a>3.<code>ncdu</code>工具</h3><p><code>ncdu</code>（NCurses Disk Usage）是一个基于ncurses的磁盘使用分析工具，提供了交互式界面。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在Debian&#x2F;Ubuntu系统上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ncdu</span><br></pre></td></tr></table></figure>

<p>在CentOS&#x2F;RHEL系统上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install ncdu</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncdu /path/to/directory</span><br></pre></td></tr></table></figure>

<h3 id="4-ls命令"><a href="#4-ls命令" class="headerlink" title="4.ls命令"></a>4.<code>ls</code>命令</h3><p><code>ls</code>命令也可以显示文件的大小，但不如<code>du</code>详细。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ul>
<li>以人类可读的格式显示文件大小：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh</span><br></pre></td></tr></table></figure>

<ul>
<li>显示目录的总大小：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lhS</span><br></pre></td></tr></table></figure>

<h3 id="5-find命令结合du"><a href="#5-find命令结合du" class="headerlink" title="5.find命令结合du"></a>5.<code>find</code>命令结合<code>du</code></h3><p>可以使用<code>find</code>命令查找特定条件的文件，然后结合<code>du</code>命令查看它们的磁盘使用情况。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><ul>
<li>查找大于100MB的文件并显示其磁盘使用情况：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/directory -type f -size +100M -execdu -h &#123;&#125; +</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/Linux%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">Linux死锁是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-20T13:33:41+00:00">
                2025-02-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Linux死锁是什么？"><a href="#👌Linux死锁是什么？" class="headerlink" title="👌Linux死锁是什么？"></a>👌Linux死锁是什么？</h1><p>在Linux操作系统中，死锁（Deadlock）是指两个或多个进程在等待彼此释放资源，从而导致它们都无法继续执行的情况。这是一种常见的并发问题，尤其在多线程或多进程环境中。</p>
<h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><p>死锁的发生需要满足以下四个条件（也称为Coffman条件）：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：至少有一个资源是非共享的，即一次只能被一个进程使用。</li>
<li><strong>占有并等待条件（Hold and Wait）</strong>：一个进程已经持有了至少一个资源，并且正在等待获取其他被其他进程持有的资源。</li>
<li><strong>不剥夺条件（No Preemption）</strong>：资源不能被强制从进程中剥夺，只有持有资源的进程可以主动释放资源。</li>
<li><strong>环路等待条件（Circular Wait）</strong>：存在一个进程链，使得每个进程都在等待链中下一个进程所持有的资源。</li>
</ol>
<h3 id="死锁的检测和预防"><a href="#死锁的检测和预防" class="headerlink" title="死锁的检测和预防"></a>死锁的检测和预防</h3><p>为了处理死锁问题，可以采取以下几种策略：</p>
<h4 id="1-预防死锁"><a href="#1-预防死锁" class="headerlink" title="1.预防死锁"></a>1.<strong>预防死锁</strong></h4><p>预防死锁的方法包括破坏上述四个条件之一：</p>
<ul>
<li><strong>破坏互斥条件</strong>：尽可能减少对非共享资源的使用。</li>
<li><strong>破坏占有并等待条件</strong>：在进程开始时一次性分配所有需要的资源，或者要求进程在请求资源前释放所有持有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：允许操作系统强制剥夺某些资源。</li>
<li><strong>破坏环路等待条件</strong>：对资源进行排序，并要求进程按顺序请求资源。</li>
</ul>
<h4 id="2-避免死锁"><a href="#2-避免死锁" class="headerlink" title="2.避免死锁"></a>2.<strong>避免死锁</strong></h4><p>避免死锁的方法主要是通过资源分配策略来确保系统永远不会进入死锁状态。常用的方法包括银行家算法（Banker’s Algorithm），它通过模拟资源分配情况来判断是否会导致死锁。</p>
<h4 id="3-检测和恢复"><a href="#3-检测和恢复" class="headerlink" title="3.检测和恢复"></a>3.<strong>检测和恢复</strong></h4><p>如果无法预防或避免死锁，可以通过检测和恢复来处理死锁：</p>
<ul>
<li><strong>死锁检测</strong>：定期检查系统中是否存在死锁。可以使用资源分配图（Resource Allocation Graph）来检测环路，从而识别死锁。</li>
<li><strong>死锁恢复</strong>：一旦检测到死锁，可以通过以下方式恢复：<ul>
<li><strong>终止进程</strong>：强制终止一个或多个进程以打破死锁。</li>
<li><strong>资源剥夺</strong>：强制从某些进程中剥夺资源并重新分配。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/linux%E5%86%85%E5%AD%98%E6%9C%89%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/linux%E5%86%85%E5%AD%98%E6%9C%89%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%EF%BC%9F/" itemprop="url">linux 内存有问题怎么查看</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-20T13:33:41+00:00">
                2025-02-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌linux-内存有问题怎么查看？"><a href="#👌linux-内存有问题怎么查看？" class="headerlink" title="👌linux 内存有问题怎么查看？"></a>👌linux 内存有问题怎么查看？</h1><p>如果怀疑内存有问题，可以通过以下步骤进行检查和诊断：</p>
<h3 id="1-使用free命令查看内存使用情况"><a href="#1-使用free命令查看内存使用情况" class="headerlink" title="1. 使用free命令查看内存使用情况"></a>1. 使用<code>free</code>命令查看内存使用情况</h3><p><code>free</code>命令可以显示系统的内存使用情况，包括总内存、已使用内存、空闲内存和缓存等信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           7.8G        3.2G        1.5G        200M        3.1G        4.1G</span><br><span class="line">Swap:          2.0G        0.0K        2.0G</span><br></pre></td></tr></table></figure>

<h3 id="2-使用top或htop命令查看内存使用情况"><a href="#2-使用top或htop命令查看内存使用情况" class="headerlink" title="2. 使用top或htop命令查看内存使用情况"></a>2. 使用<code>top</code>或<code>htop</code>命令查看内存使用情况</h3><p><code>top</code>和<code>htop</code>命令可以实时显示系统的资源使用情况，包括内存使用情况。</p>
<ul>
<li><code>top</code>命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<ul>
<li><code>htop</code>命令（需要安装）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install htop</span><br><span class="line">htop</span><br></pre></td></tr></table></figure>

<h3 id="3-使用vmstat命令查看内存和系统性能"><a href="#3-使用vmstat命令查看内存和系统性能" class="headerlink" title="3. 使用vmstat命令查看内存和系统性能"></a>3. 使用<code>vmstat</code>命令查看内存和系统性能</h3><p><code>vmstat</code>命令可以报告虚拟内存、进程、CPU 活动等信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat 1 5</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 1576828  72464 2192160    0    0     8    11   64  150  1  0 99  0  0</span><br><span class="line"> 0  0      0 1576820  72464 2192160    0    0     0     0   59  144  0  0 100  0  0</span><br></pre></td></tr></table></figure>

<h3 id="4-检查内存使用情况的日志"><a href="#4-检查内存使用情况的日志" class="headerlink" title="4. 检查内存使用情况的日志"></a>4. 检查内存使用情况的日志</h3><p>查看系统日志，如<code>/var/log/syslog</code>或<code>/var/log/messages</code>，看看是否有与内存相关的错误或警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grep -i memory /var/log/syslog</span><br><span class="line">sudo grep -i memory /var/log/messages</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/linux%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/20/%E9%9D%A2%E8%AF%95%E9%A2%98/linux%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">linux的中断机制用来干什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-20T13:33:41+00:00">
                2025-02-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌linux的中断机制用来干什么？"><a href="#👌linux的中断机制用来干什么？" class="headerlink" title="👌linux的中断机制用来干什么？"></a>👌linux的中断机制用来干什么？</h1><p>Linux的中断机制用于处理各种硬件和软件事件，使操作系统能够及时响应并处理这些事件。中断机制在操作系统中起着至关重要的作用。</p>
<h3 id="1-硬件设备的事件处理"><a href="#1-硬件设备的事件处理" class="headerlink" title="1.硬件设备的事件处理"></a>1.<strong>硬件设备的事件处理</strong></h3><p>硬件设备通过中断机制通知操作系统它们的状态变化或需要处理的事件。例如：</p>
<ul>
<li><strong>键盘输入</strong>：当键盘按键被按下时，键盘控制器会发出中断信号，通知CPU读取按键值。</li>
<li><strong>网络数据接收</strong>：网卡接收到数据包时，会触发中断，通知操作系统处理接收到的数据。</li>
<li><strong>硬盘I&#x2F;O完成</strong>：硬盘完成读写操作后，会发出中断信号，通知操作系统该操作已完成，可以继续处理数据。</li>
</ul>
<h3 id="2-定时器和时钟管理"><a href="#2-定时器和时钟管理" class="headerlink" title="2.定时器和时钟管理"></a>2.<strong>定时器和时钟管理</strong></h3><p>操作系统使用定时器中断来管理系统时钟和时间片轮转。例如：</p>
<ul>
<li><strong>系统时钟更新</strong>：定时器会定期触发中断，操作系统通过这些中断更新系统时钟。</li>
<li><strong>时间片轮转</strong>：在多任务操作系统中，定时器中断用于实现时间片轮转调度，确保各个进程能够公平地获得CPU时间。</li>
</ul>
<h3 id="3-系统调用和异常处理"><a href="#3-系统调用和异常处理" class="headerlink" title="3.系统调用和异常处理"></a>3.<strong>系统调用和异常处理</strong></h3><p>软件中断（如系统调用和异常）允许用户空间程序与内核进行交互，并处理异常情况。例如：</p>
<ul>
<li><strong>系统调用</strong>：用户程序通过触发软件中断进入内核态，执行系统调用以请求操作系统服务（如文件操作、进程管理等）。</li>
<li><strong>异常处理</strong>：当程序发生异常（如除零错误、非法内存访问等）时，CPU会触发异常中断，操作系统捕获并处理这些异常。</li>
</ul>
<h3 id="4-中断驱动的I-x2F-O操作"><a href="#4-中断驱动的I-x2F-O操作" class="headerlink" title="4.中断驱动的I&#x2F;O操作"></a>4.<strong>中断驱动的I&#x2F;O操作</strong></h3><p>中断机制使得设备驱动程序可以实现高效的I&#x2F;O操作。例如：</p>
<ul>
<li><strong>非阻塞I&#x2F;O</strong>：通过中断通知，设备驱动程序可以在设备准备好时处理I&#x2F;O操作，而无需进程持续轮询设备状态，从而提高系统效率。</li>
</ul>
<h3 id="5-电源管理"><a href="#5-电源管理" class="headerlink" title="5.电源管理"></a>5.<strong>电源管理</strong></h3><p>中断机制在电源管理中也扮演重要角色。例如：</p>
<ul>
<li><strong>电池状态变化</strong>：当电池电量低或充电完成时，电源管理芯片会触发中断，通知操作系统采取相应的措施（如节能模式或提示用户）。</li>
</ul>
<h3 id="6-多核处理器的中断分配"><a href="#6-多核处理器的中断分配" class="headerlink" title="6.多核处理器的中断分配"></a>6.<strong>多核处理器的中断分配</strong></h3><p>在多核处理器系统中，中断控制器（如APIC）可以将中断分配到不同的CPU核，以实现负载均衡和提高并行处理能力。</p>
<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jsyun/vwxwc6">https://www.yuque.com/jsyun/vwxwc6</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/16/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%AE%A9%E4%BD%A0%E7%94%A8%E7%9C%8B%E9%97%A8%E7%8B%97%EF%BC%8C%E4%BD%A0%E4%BC%9A%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88%E6%9D%A5%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E6%94%AF%E4%BB%98%E9%97%AE%E9%A2%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/16/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%AE%A9%E4%BD%A0%E7%94%A8%E7%9C%8B%E9%97%A8%E7%8B%97%EF%BC%8C%E4%BD%A0%E4%BC%9A%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88%E6%9D%A5%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E6%94%AF%E4%BB%98%E9%97%AE%E9%A2%98%EF%BC%9F/" itemprop="url">如果不让你用看门狗，你会用什么方案来解决重复支付问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-16T13:33:41+00:00">
                2025-02-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9C%BA%E6%99%AF%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">场景题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌如果不让你用看门狗，你会用什么方案来解决重复支付问题？"><a href="#👌如果不让你用看门狗，你会用什么方案来解决重复支付问题？" class="headerlink" title="👌如果不让你用看门狗，你会用什么方案来解决重复支付问题？"></a>👌如果不让你用看门狗，你会用什么方案来解决重复支付问题？</h1><h3 id="1-幂等性令牌（Idempotency-Token）"><a href="#1-幂等性令牌（Idempotency-Token）" class="headerlink" title="1. 幂等性令牌（Idempotency Token）"></a>1. 幂等性令牌（Idempotency Token）</h3><p><strong>原理</strong>：在每次支付请求中，客户端生成一个唯一的幂等性令牌，并将其发送给服务器。服务器在处理支付请求时，会检查这个令牌是否已经被使用过。如果令牌已经被使用，服务器会拒绝重复的支付请求。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>客户端生成一个唯一的幂等性令牌（如 UUID）。</li>
<li>客户端将令牌和支付请求一起发送给服务器。</li>
<li>服务器检查令牌是否已经存在于数据库中。</li>
<li>如果令牌不存在，服务器处理支付请求并将令牌存储在数据库中。</li>
<li>如果令牌已经存在，服务器拒绝支付请求或者返回之前的处理结果。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class PaymentService &#123;</span><br><span class="line"></span><br><span class="line">    private PaymentRepository paymentRepository;</span><br><span class="line"></span><br><span class="line">    public PaymentService(PaymentRepository paymentRepository) &#123;</span><br><span class="line">        this.paymentRepository = paymentRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void processPayment(PaymentRequest request) throws DuplicatePaymentException &#123;</span><br><span class="line">        String antiReplayToken = request.getAntiReplayToken();</span><br><span class="line"></span><br><span class="line">        if (paymentRepository.existsByAntiReplayToken(antiReplayToken)) &#123;</span><br><span class="line">            throw new DuplicatePaymentException(&quot;Duplicate payment detected for anti-replay token: &quot; + antiReplayToken);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 处理支付逻辑</span><br><span class="line">        Payment payment = new Payment();</span><br><span class="line">        payment.setAntiReplayToken(antiReplayToken);</span><br><span class="line">        payment.setAmount(request.getAmount());</span><br><span class="line">        payment.setStatus(&quot;processing&quot;);</span><br><span class="line"></span><br><span class="line">        paymentRepository.save(payment);</span><br><span class="line"></span><br><span class="line">        // 完成支付后更新状态</span><br><span class="line">        payment.setStatus(&quot;completed&quot;);</span><br><span class="line">        paymentRepository.save(payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库唯一约束（不推荐）"><a href="#2-数据库唯一约束（不推荐）" class="headerlink" title="2. 数据库唯一约束（不推荐）"></a>2. 数据库唯一约束（不推荐）</h3><p><strong>原理</strong>：在数据库中为每个支付请求生成一个唯一的交易 ID，并在数据库中设置唯一约束（Unique Constraint）来防止重复记录。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>在支付请求中生成一个唯一的交易 ID。</li>
<li>在数据库中保存支付记录时，使用交易 ID 作为唯一键。</li>
<li>如果尝试插入重复的交易 ID，数据库会抛出唯一约束异常，从而防止重复支付。</li>
</ol>
<p><strong>示例代码</strong>（伪代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE payments (</span><br><span class="line">    id SERIAL PRIMARY KEY,</span><br><span class="line">    transaction_id VARCHAR(255) UNIQUE NOT NULL,</span><br><span class="line">    amount DECIMAL(10, 2),</span><br><span class="line">    status VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 插入支付记录时</span><br><span class="line">INSERT INTO payments (transaction_id, amount, status) VALUES (&#x27;unique_transaction_id&#x27;, 100.00, &#x27;pending&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3. 分布式锁"></a>3. 分布式锁</h3><p><strong>原理</strong>：使用分布式锁来确保同一时间只有一个支付请求能够被处理。可以使用 Redis、ZooKeeper 等工具实现分布式锁。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>在处理支付请求前，尝试获取分布式锁。</li>
<li>如果获取锁成功，处理支付请求。</li>
<li>如果获取锁失败，拒绝支付请求或等待重试。</li>
<li>支付处理完成后，释放分布式锁。</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import org.redisson.api.RLock;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class PaymentService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PaymentRepository paymentRepository;</span><br><span class="line"></span><br><span class="line">    public void processPayment(PaymentRequest request) throws DuplicatePaymentException &#123;</span><br><span class="line">        String transactionId = request.getTransactionId();</span><br><span class="line">        RLock lock = redissonClient.getLock(&quot;payment_lock_&quot; + transactionId);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (lock.tryLock(10, 10, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                if (paymentRepository.existsByTransactionId(transactionId)) &#123;</span><br><span class="line">                    throw new DuplicatePaymentException(&quot;Duplicate payment detected for transaction ID: &quot; + transactionId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 处理支付逻辑</span><br><span class="line">                Payment payment = new Payment();</span><br><span class="line">                payment.setTransactionId(transactionId);</span><br><span class="line">                payment.setAmount(request.getAmount());</span><br><span class="line">                payment.setStatus(&quot;processing&quot;);</span><br><span class="line"></span><br><span class="line">                paymentRepository.save(payment);</span><br><span class="line"></span><br><span class="line">                // 完成支付后更新状态</span><br><span class="line">                payment.setStatus(&quot;completed&quot;);</span><br><span class="line">                paymentRepository.save(payment);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Could not acquire lock for transaction ID: &quot; + transactionId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            throw new RuntimeException(&quot;Lock acquisition interrupted&quot;, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-事务和锁机制"><a href="#4-事务和锁机制" class="headerlink" title="4. 事务和锁机制"></a>4. 事务和锁机制</h3><p><strong>原理</strong>：使用数据库事务和锁机制来确保支付操作的原子性和一致性。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>在数据库中为支付操作创建一个事务。</li>
<li>在事务中获取支付记录的锁，防止其他事务同时修改相同的记录。</li>
<li>执行支付操作并提交事务。</li>
<li>如果在支付操作中发生冲突，回滚事务并重试。</li>
</ol>
<h3 id="5-状态机"><a href="#5-状态机" class="headerlink" title="5. 状态机"></a>5. 状态机</h3><p><strong>原理</strong>：使用状态机来管理支付请求的状态，确保每个支付请求只能从一个状态转移到另一个状态，避免重复处理。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>定义支付请求的状态（如<code>pending</code>、<code>processing</code>、<code>completed</code>、<code>failed</code>）。</li>
<li>在处理支付请求时，根据当前状态进行状态转移。</li>
<li>使用数据库事务确保状态转移的原子性。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上方法都可以有效地防止重复支付，具体选择哪种方案取决于系统的架构和需求。幂等性令牌和数据库唯一约束是比较常见且易于实现的方法，而分布式锁和状态机适用于更复杂的分布式系统。无论选择哪种方案，都需要确保支付操作的幂等性和一致性。</p>
<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/cf41s0446a6gokgr">https://www.yuque.com/jingdianjichi/xyxdsi/cf41s0446a6gokgr</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/16/%E5%9C%BA%E6%99%AF%E9%A2%98/%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%94%AF%E4%BB%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/16/%E5%9C%BA%E6%99%AF%E9%A2%98/%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E6%94%AF%E4%BB%98%EF%BC%9F/" itemprop="url">看门狗机制可以防止重复支付？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-16T13:33:41+00:00">
                2025-02-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9C%BA%E6%99%AF%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">场景题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌看门狗机制可以防止重复支付？"><a href="#👌看门狗机制可以防止重复支付？" class="headerlink" title="👌看门狗机制可以防止重复支付？"></a>👌看门狗机制可以防止重复支付？</h1><p>看门狗机制（Watchdog Mechanism）并不是直接用于防止重复支付的常见技术，但它可以在一定程度上帮助监控和管理支付流程，确保支付操作的可靠性和安全性。</p>
<h3 id="看门狗机制的基本原理"><a href="#看门狗机制的基本原理" class="headerlink" title="看门狗机制的基本原理"></a>看门狗机制的基本原理</h3><p>看门狗机制通常是一个定期检查系统状态或操作完成情况的过程。如果系统在规定时间内没有响应或完成特定操作，看门狗机制会触发预定义的恢复或补救措施。它类似于一种“守护进程”，确保系统在正常运行。</p>
<h3 id="在支付系统中的应用"><a href="#在支付系统中的应用" class="headerlink" title="在支付系统中的应用"></a>在支付系统中的应用</h3><p>在支付系统中，看门狗机制可以用于监控支付请求的处理状态，确保支付请求在合理的时间内完成，并防止由于网络延迟或系统故障导致的重复支付问题。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><strong>支付请求的状态管理</strong>：<ul>
<li>每个支付请求都有一个唯一的标识符（如交易ID）。</li>
<li>支付请求在数据库中有明确的状态（如<code>pending</code>、<code>processing</code>、<code>completed</code>、<code>failed</code>）。</li>
</ul>
</li>
<li><strong>看门狗机制的监控</strong>：<ul>
<li>看门狗进程定期检查支付请求的状态，确保所有支付请求在合理的时间内从<code>pending</code>转移到<code>completed</code>或<code>failed</code>状态。</li>
<li>如果发现某个支付请求长时间停留在<code>pending</code>或<code>processing</code>状态，看门狗机制会触发相应的处理逻辑。</li>
</ul>
</li>
<li><strong>处理逻辑</strong>：<ul>
<li>如果支付请求长时间处于<code>pending</code>状态，看门狗机制可以重试支付请求或将其标记为<code>failed</code>，以防止重复支付。</li>
<li>如果支付请求长时间处于<code>processing</code>状态，看门狗机制可以检查支付处理是否卡住，并尝试重启处理流程或进行人工干预。</li>
</ul>
</li>
</ol>
<p>通过看门狗机制，可以监控支付请求的处理状态，确保支付操作在合理时间内完成，防止由于网络延迟或系统故障导致的重复支付问题。尽管看门狗机制不是直接防止重复支付的工具，但它可以作为一种辅助措施，确保支付系统的可靠性和安全性。</p>
<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/getdtvffwg1agghx">https://www.yuque.com/jingdianjichi/xyxdsi/getdtvffwg1agghx</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/16/%E5%9C%BA%E6%99%AF%E9%A2%98/%E9%94%81%E5%BA%93%E5%AD%98%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%94%A8redis%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/16/%E5%9C%BA%E6%99%AF%E9%A2%98/%E9%94%81%E5%BA%93%E5%AD%98%E5%A6%82%E6%9E%9C%E4%B8%8D%E7%94%A8redis%E8%BF%98%E8%83%BD%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F/" itemprop="url">锁库存如果不用redis 还能怎么实现？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-16T13:33:41+00:00">
                2025-02-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9C%BA%E6%99%AF%E9%A2%98/" itemprop="url" rel="index">
                    <span itemprop="name">场景题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌锁库存如果不用redis-还能怎么实现？"><a href="#👌锁库存如果不用redis-还能怎么实现？" class="headerlink" title="👌锁库存如果不用redis 还能怎么实现？"></a>👌锁库存如果不用redis 还能怎么实现？</h1><p>锁库存是电商系统中常见的需求，特别是在高并发场景下，需要确保库存的准确性和一致性。记住 Redis 是一种常见的解决方案，如果面试官非问这种，就答下面这些方案。</p>
<h3 id="1-数据库乐观锁"><a href="#1-数据库乐观锁" class="headerlink" title="1. 数据库乐观锁"></a>1. 数据库乐观锁</h3><p>乐观锁是一种不使用数据库锁机制的锁定方式。它假设冲突很少发生，因此在更新数据时进行冲突检测。</p>
<h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><ol>
<li><strong>添加版本号</strong>： 在库存表中添加一个<code>version</code>字段，用于记录数据的版本。</li>
<li><strong>更新时检查版本号</strong>： 在更新库存时，通过<code>version</code>字段来确保数据没有被其他事务修改。</li>
</ol>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE inventory</span><br><span class="line">SET stock = stock - 1, version = version + 1</span><br><span class="line">WHERE product_id = ? AND version = ?;</span><br></pre></td></tr></table></figure>

<p>如果更新成功，说明库存锁定成功；否则，说明有并发修改，需要重试。</p>
<h3 id="2-数据库悲观锁（不推荐）"><a href="#2-数据库悲观锁（不推荐）" class="headerlink" title="2. 数据库悲观锁（不推荐）"></a>2. 数据库悲观锁（不推荐）</h3><p>悲观锁是一种锁定机制，确保在事务完成之前，其他事务无法访问被锁定的数据。</p>
<h4 id="实现方法：-1"><a href="#实现方法：-1" class="headerlink" title="实现方法："></a>实现方法：</h4><ol>
<li><strong>使用</strong><code>**SELECT ... FOR UPDATE**</code>： 在事务中使用<code>SELECT ... FOR UPDATE</code>语句锁定行，直到事务提交或回滚。</li>
</ol>
<h4 id="示例-SQL："><a href="#示例-SQL：" class="headerlink" title="示例 SQL："></a>示例 SQL：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT stock</span><br><span class="line">FROM inventory</span><br><span class="line">WHERE product_id = ?</span><br><span class="line">FOR UPDATE;</span><br><span class="line"></span><br><span class="line">-- 检查库存并更新</span><br><span class="line">UPDATE inventory</span><br><span class="line">SET stock = stock - 1</span><br><span class="line">WHERE product_id = ?;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>悲观锁适用于冲突较多的场景，但可能会导致数据库锁争用，影响性能。</p>
<h3 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3. 分布式锁"></a>3. 分布式锁</h3><p>分布式锁用于在分布式系统中确保资源的独占访问。可以使用 Zookeeper、Etcd 等工具实现分布式锁。</p>
<h4 id="实现方法：-2"><a href="#实现方法：-2" class="headerlink" title="实现方法："></a>实现方法：</h4><ol>
<li><strong>使用 Zookeeper</strong>： 利用 Zookeeper 的临时节点和顺序节点特性，实现分布式锁。</li>
</ol>
<h4 id="示例使用-Curator-框架："><a href="#示例使用-Curator-框架：" class="headerlink" title="示例使用 Curator 框架："></a>示例使用 Curator 框架：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CuratorFramework client = CuratorFrameworkFactory.newClient(&quot;zkServer:2181&quot;, new ExponentialBackoffRetry(1000, 3));</span><br><span class="line">client.start();</span><br><span class="line"></span><br><span class="line">InterProcessMutex lock = new InterProcessMutex(client, &quot;/inventory_lock&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    if (lock.acquire(10, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 处理库存</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-基于消息队列的异步处理（可用）"><a href="#4-基于消息队列的异步处理（可用）" class="headerlink" title="4. 基于消息队列的异步处理（可用）"></a>4. 基于消息队列的异步处理（可用）</h3><p>通过消息队列，将库存操作异步化，避免并发冲突。</p>
<h4 id="实现方法：-3"><a href="#实现方法：-3" class="headerlink" title="实现方法："></a>实现方法：</h4><ol>
<li><strong>消息队列</strong>： 使用 Kafka、RabbitMQ 等消息队列，将库存操作请求发送到队列中。</li>
<li><strong>消费者处理</strong>： 消费者从队列中读取消息，顺序处理库存操作。</li>
</ol>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 生产者</span><br><span class="line">rabbitTemplate.convertAndSend(&quot;inventoryQueue&quot;, new InventoryMessage(productId, quantity));</span><br><span class="line"></span><br><span class="line">// 消费者</span><br><span class="line">@RabbitListener(queues = &quot;inventoryQueue&quot;)</span><br><span class="line">public void handleInventory(InventoryMessage message) &#123;</span><br><span class="line">    // 处理库存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-数据库事务（不要用不要用）"><a href="#5-数据库事务（不要用不要用）" class="headerlink" title="5. 数据库事务（不要用不要用）"></a>5. 数据库事务（不要用不要用）</h3><p>通过数据库事务，确保库存操作的原子性和一致性。</p>
<h4 id="实现方法：-4"><a href="#实现方法：-4" class="headerlink" title="实现方法："></a>实现方法：</h4><ol>
<li><strong>事务管理</strong>： 在业务逻辑中使用数据库事务，确保库存操作的原子性。</li>
</ol>
<h4 id="示例代码（使用-Spring-事务管理）："><a href="#示例代码（使用-Spring-事务管理）：" class="headerlink" title="示例代码（使用 Spring 事务管理）："></a>示例代码（使用 Spring 事务管理）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void updateInventory(Long productId, int quantity) &#123;</span><br><span class="line">    // 检查库存</span><br><span class="line">    int stock = inventoryMapper.getStock(productId);</span><br><span class="line">    if (stock &gt;= quantity) &#123;</span><br><span class="line">        // 更新库存</span><br><span class="line">        inventoryMapper.updateStock(productId, stock - quantity);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new InsufficientStockException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>锁库存的实现方式有很多种，选择合适的方案需要根据具体的业务需求和技术栈来决定。乐观锁和悲观锁适用于单体应用和简单的分布式场景；分布式锁适用于复杂的分布式系统；基于消息队列的异步处理适用于高并发、高吞吐量的场景；数据库事务适用于需要确保操作原子性的场景。每种方案都有其优缺点，需要综合考虑性能、复杂度和一致性要求。</p>
<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/og4as3nog7ss4mse">https://www.yuque.com/jingdianjichi/xyxdsi/og4as3nog7ss4mse</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/1000w%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5mysql%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/1000w%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5mysql%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/" itemprop="url">1000w条数据插入mysql如何设计？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-15T13:33:41+00:00">
                2025-02-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌1000w条数据插入mysql如何设计？"><a href="#👌1000w条数据插入mysql如何设计？" class="headerlink" title="👌1000w条数据插入mysql如何设计？"></a>👌1000w条数据插入mysql如何设计？</h1><h3 id="1-使用批量插入（Bulk-Insert）"><a href="#1-使用批量插入（Bulk-Insert）" class="headerlink" title="1. 使用批量插入（Bulk Insert）"></a>1. 使用批量插入（Bulk Insert）</h3><p>批量插入可以显著减少 SQL 语句的开销和网络传输的负担。可以使用<code>INSERT INTO ... VALUES</code>语句一次插入多条记录。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO your_table (column1, column2, column3) VALUES</span><br><span class="line">(&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;),</span><br><span class="line">(&#x27;value4&#x27;, &#x27;value5&#x27;, &#x27;value6&#x27;),</span><br><span class="line">...</span><br><span class="line">(&#x27;valueN1&#x27;, &#x27;valueN2&#x27;, &#x27;valueN3&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="2-禁用或延迟索引和约束（不到万不得已，别搞，不推荐）"><a href="#2-禁用或延迟索引和约束（不到万不得已，别搞，不推荐）" class="headerlink" title="2. 禁用或延迟索引和约束（不到万不得已，别搞，不推荐）"></a>2. 禁用或延迟索引和约束（不到万不得已，别搞，不推荐）</h3><p>在插入大量数据之前，可以暂时禁用或延迟索引和外键约束，以减少插入过程中的开销。插入完成后再重新启用索引和约束。</p>
<h4 id="禁用外键检查："><a href="#禁用外键检查：" class="headerlink" title="禁用外键检查："></a>禁用外键检查：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET foreign_key_checks =0;</span><br></pre></td></tr></table></figure>

<h4 id="禁用唯一检查："><a href="#禁用唯一检查：" class="headerlink" title="禁用唯一检查："></a>禁用唯一检查：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET unique_checks =0;</span><br></pre></td></tr></table></figure>

<h3 id="3-调整-MySQL-配置"><a href="#3-调整-MySQL-配置" class="headerlink" title="3. 调整 MySQL 配置"></a>3. 调整 MySQL 配置</h3><p>确保 MySQL 配置足够支持大批量数据插入。</p>
<h4 id="增大缓冲区大小："><a href="#增大缓冲区大小：" class="headerlink" title="增大缓冲区大小："></a>增大缓冲区大小：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_buffer_pool_size = 1G  # 根据你的内存大小调整</span><br><span class="line">innodb_log_buffer_size = 64M</span><br></pre></td></tr></table></figure>

<h4 id="调整事务日志大小："><a href="#调整事务日志大小：" class="headerlink" title="调整事务日志大小："></a>调整事务日志大小：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_log_file_size = 512M</span><br><span class="line">innodb_log_files_in_group = 2</span><br></pre></td></tr></table></figure>

<h3 id="4-使用事务"><a href="#4-使用事务" class="headerlink" title="4. 使用事务"></a>4. 使用事务</h3><p>将大量插入操作分批放入事务中，可以减少每次插入的提交开销。如果数据量非常大，可以每 1000 或 10000 条记录提交一次。换成代码使用就是 transactiontemplate来手动控制事务提交</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">INSERT INTO your_table (column1, column2, column3) VALUES</span><br><span class="line">(&#x27;value1&#x27;, &#x27;value2&#x27;, &#x27;value3&#x27;),</span><br><span class="line">(&#x27;value4&#x27;, &#x27;value5&#x27;, &#x27;value6&#x27;),</span><br><span class="line">...</span><br><span class="line">(&#x27;value1000&#x27;, &#x27;value1001&#x27;, &#x27;value1002&#x27;);</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用分区表"><a href="#5-使用分区表" class="headerlink" title="5. 使用分区表"></a>5. 使用分区表</h3><p>如果数据量非常大且有分区需求，可以考虑使用 MySQL 的分区表功能，将数据按某个字段（如日期、ID 等）进行分区，提升查询和插入性能。</p>
<h3 id="6-数据导入工具"><a href="#6-数据导入工具" class="headerlink" title="6. 数据导入工具"></a>6. 数据导入工具</h3><p>对于非常大的数据集，可以使用 MySQL 提供的工具如<code>mysqlimport</code>或者第三方工具如<code>mydumper/myloader</code>进行数据导入，这些工具通常针对大数据集做了优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F/" itemprop="url">redis滑动窗口限流怎么做的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-15T13:33:41+00:00">
                2025-02-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Redis滑动窗口限流怎么做的说一下？"><a href="#👌Redis滑动窗口限流怎么做的说一下？" class="headerlink" title="👌Redis滑动窗口限流怎么做的说一下？"></a>👌Redis滑动窗口限流怎么做的说一下？</h1><p>Redis的滑动窗口限流是一种基于时间窗口的限流策略，用于控制在特定时间范围内的请求数量。其基本思想是将时间划分为多个小的子窗口，通过记录每个子窗口内的请求数量来实现限流。与固定窗口限流相比，滑动窗口限流可以更平滑地限制请求速率，减少突发流量对系统的影响。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><strong>时间窗口</strong>：滑动窗口限流将时间划分为多个小的子窗口。例如，要限制每秒最多10个请求，可以将1秒划分为10个子窗口，每个子窗口100毫秒。</li>
<li><strong>记录请求时间戳</strong>：使用Redis的有序集合（Sorted Set）记录请求的时间戳。</li>
<li><strong>计算当前窗口内的请求数量</strong>：每次有新请求到来时，移除过期的时间戳，计算当前窗口内的请求数量。</li>
<li><strong>判断是否限流</strong>：如果当前窗口内的请求数量超过限流阈值，则拒绝请求；否则，允许请求并记录时间戳。</li>
</ol>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><strong>确定时间窗口和子窗口大小</strong>。</li>
<li><strong>使用Redis有序集合记录请求时间戳</strong>。</li>
<li><strong>计算当前窗口内的请求数量</strong>。</li>
<li><strong>判断是否限流</strong>。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class SlidingWindowRateLimiter &#123;</span><br><span class="line">    private Jedis jedis;</span><br><span class="line">    private String key;</span><br><span class="line">    private int windowSizeInMillis;</span><br><span class="line">    private int limit;</span><br><span class="line"></span><br><span class="line">    public SlidingWindowRateLimiter(Jedis jedis, String key, int windowSizeInMillis, int limit) &#123;</span><br><span class="line">        this.jedis = jedis;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.windowSizeInMillis = windowSizeInMillis;</span><br><span class="line">        this.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isAllowed() &#123;</span><br><span class="line">        long currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">        long windowStart = currentTimeMillis - windowSizeInMillis;</span><br><span class="line"></span><br><span class="line">        Transaction transaction = jedis.multi();</span><br><span class="line">        transaction.zremrangeByScore(key, 0, windowStart); // 移除过期的时间戳</span><br><span class="line">        transaction.zcard(key); // 获取当前窗口内的请求数量</span><br><span class="line">        transaction.zadd(key, currentTimeMillis, String.valueOf(currentTimeMillis)); // 添加当前请求的时间戳</span><br><span class="line">        transaction.expire(key, windowSizeInMillis / 1000 * 2); // 设置过期时间</span><br><span class="line">        List&lt;Object&gt; results = transaction.exec();</span><br><span class="line"></span><br><span class="line">        long currentCount = (Long) results.get(1); // 获取当前窗口内的请求数量</span><br><span class="line"></span><br><span class="line">        return currentCount &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);</span><br><span class="line">        SlidingWindowRateLimiter limiter = new SlidingWindowRateLimiter(jedis, &quot;rate_limiter_key&quot;, 1000, 10);</span><br><span class="line"></span><br><span class="line">        if (limiter.isAllowed()) &#123;</span><br><span class="line">            System.out.println(&quot;请求被允许&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;请求被拒绝&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol>
<li><strong>初始化</strong>：<ul>
<li><code>SlidingWindowRateLimiter</code>类的构造函数接受<code>jedis</code>（Jedis客户端实例）、<code>key</code>（Redis键）、<code>windowSizeInMillis</code>（时间窗口大小，以毫秒为单位）和<code>limit</code>（限流阈值）。</li>
</ul>
</li>
<li><strong>isAllowed 方法</strong>：<ul>
<li>获取当前时间戳（毫秒）。</li>
<li>计算窗口开始时间（当前时间减去窗口大小）。</li>
<li>使用Redis事务（<code>Transaction</code>）执行以下操作：<ul>
<li><code>zremrangeByScore</code>：移除有序集合中所有时间戳小于窗口开始时间的元素（即过期的时间戳）。</li>
<li><code>zcard</code>：获取当前窗口内的请求数量。</li>
<li><code>zadd</code>：添加当前请求的时间戳到有序集合中。</li>
<li><code>expire</code>：设置Redis键的过期时间，防止长期不活跃时占用Redis内存。</li>
</ul>
</li>
<li>执行事务并获取结果。</li>
<li>检查当前窗口内的请求数量是否超过限流阈值，决定是否允许请求。</li>
</ul>
</li>
<li><strong>main 方法</strong>：<ul>
<li>创建Jedis客户端实例并连接到Redis服务器。</li>
<li>创建<code>SlidingWindowRateLimiter</code>实例并调用<code>isAllowed</code>方法来检查请求是否被允许。</li>
<li>关闭Jedis客户端。</li>
</ul>
</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>平滑限流</strong>：滑动窗口限流相比固定窗口限流更加平滑，能够更好地应对突发流量。</li>
<li><strong>精确控制</strong>：可以精确控制特定时间窗口内的请求数量。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>复杂度较高</strong>：实现相对复杂，需要精确管理时间戳和窗口。</li>
<li><strong>性能开销</strong>：频繁的Redis操作可能会带来一定的性能开销。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/for%E5%BE%AA%E7%8E%AF%E8%B0%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/for%E5%BE%AA%E7%8E%AF%E8%B0%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9/" itemprop="url">for循环调数据库有什么风险</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-15T13:33:41+00:00">
                2025-02-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌for循环调数据库有什么风险"><a href="#👌for循环调数据库有什么风险" class="headerlink" title="👌for循环调数据库有什么风险"></a>👌for循环调数据库有什么风险</h1><h3 id="1-性能问题"><a href="#1-性能问题" class="headerlink" title="1. 性能问题"></a>1. 性能问题</h3><h4 id="风险："><a href="#风险：" class="headerlink" title="风险："></a>风险：</h4><ul>
<li><strong>高延迟</strong>：每次数据库调用都涉及网络通信和数据库处理时间，频繁调用会导致整体延迟增加。</li>
<li><strong>低效率</strong>：大量的小批量操作比单次大批量操作效率低，增加了数据库的负载。</li>
</ul>
<h4 id="应对措施："><a href="#应对措施：" class="headerlink" title="应对措施："></a>应对措施：</h4><ul>
<li><strong>批量操作</strong>：尽量将多个操作合并为一个批量操作，如使用批量插入、批量更新等。</li>
<li><strong>缓存</strong>：在内存中缓存数据，减少数据库访问次数。</li>
<li><strong>异步处理</strong>：使用异步处理或消息队列，将数据库操作分散到后台任务中执行。</li>
</ul>
<h3 id="2-资源消耗"><a href="#2-资源消耗" class="headerlink" title="2. 资源消耗"></a>2. 资源消耗</h3><h4 id="风险：-1"><a href="#风险：-1" class="headerlink" title="风险："></a>风险：</h4><ul>
<li><strong>连接耗尽</strong>：频繁的数据库连接和断开会消耗大量的数据库连接资源，可能导致连接池耗尽。</li>
<li><strong>内存和CPU负载</strong>：大量的数据库操作会增加数据库服务器的内存和CPU负载，影响其他操作的性能。</li>
</ul>
<h4 id="应对措施：-1"><a href="#应对措施：-1" class="headerlink" title="应对措施："></a>应对措施：</h4><ul>
<li><strong>连接池优化</strong>：使用连接池并适当配置连接池参数，以减少连接创建和销毁的开销。</li>
<li><strong>合并请求</strong>：将多个查询合并为一个查询，减少数据库连接次数。</li>
</ul>
<h3 id="3-事务处理复杂性"><a href="#3-事务处理复杂性" class="headerlink" title="3. 事务处理复杂性"></a>3. 事务处理复杂性</h3><h4 id="风险：-2"><a href="#风险：-2" class="headerlink" title="风险："></a>风险：</h4><ul>
<li><strong>事务管理困难</strong>：在for循环中处理事务可能导致事务管理复杂化，增加了出错的可能性。</li>
<li><strong>锁争用</strong>：长时间持有锁或频繁锁定资源可能导致锁争用，影响系统性能。</li>
</ul>
<h4 id="应对措施：-2"><a href="#应对措施：-2" class="headerlink" title="应对措施："></a>应对措施：</h4><ul>
<li><strong>事务分段</strong>：将大事务分解为多个小事务，减少单个事务的持有时间。</li>
<li><strong>乐观锁和悲观锁</strong>：根据具体情况选择合适的锁策略，避免不必要的锁争用。</li>
</ul>
<h3 id="4-数据一致性"><a href="#4-数据一致性" class="headerlink" title="4. 数据一致性"></a>4. 数据一致性</h3><h4 id="风险：-3"><a href="#风险：-3" class="headerlink" title="风险："></a>风险：</h4><ul>
<li><strong>部分失败</strong>：for循环中的某些操作可能失败，导致数据不一致。</li>
<li><strong>并发问题</strong>：多个并发操作可能导致数据竞态条件，影响数据一致性。</li>
</ul>
<h4 id="应对措施：-3"><a href="#应对措施：-3" class="headerlink" title="应对措施："></a>应对措施：</h4><ul>
<li><strong>重试机制</strong>：实现重试机制，确保操作在失败时能重新执行。</li>
<li><strong>并发控制</strong>：使用合适的并发控制策略，如乐观锁、悲观锁或分布式锁，确保数据一致性。</li>
</ul>
<h3 id="5-可维护性和可读性"><a href="#5-可维护性和可读性" class="headerlink" title="5. 可维护性和可读性"></a>5. 可维护性和可读性</h3><h4 id="风险：-4"><a href="#风险：-4" class="headerlink" title="风险："></a>风险：</h4><ul>
<li><strong>代码复杂</strong>：在for循环中嵌入大量的数据库操作代码，会使代码变得复杂且难以维护。</li>
<li><strong>错误处理困难</strong>：错误处理逻辑复杂，增加了代码的维护成本。</li>
</ul>
<h4 id="应对措施：-4"><a href="#应对措施：-4" class="headerlink" title="应对措施："></a>应对措施：</h4><ul>
<li><strong>抽象和封装</strong>：将数据库操作抽象和封装到独立的方法或类中，提高代码的可读性和可维护性。</li>
<li><strong>日志和监控</strong>：添加日志记录和监控，方便排查问题。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%EF%BC%8C%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E9%94%81%E8%A1%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/15/%E9%9D%A2%E8%AF%95%E9%A2%98/mysql%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%EF%BC%8C%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E9%94%81%E8%A1%A8%EF%BC%9F/" itemprop="url">mysql中已经存在的表，加索引，会不会产生锁表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-02-15T13:33:41+00:00">
                2025-02-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-03-06T01:24:58+00:00">
                2025-03-06
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌mysql中已经存在的表，加索引，会不会产生锁表？"><a href="#👌mysql中已经存在的表，加索引，会不会产生锁表？" class="headerlink" title="👌mysql中已经存在的表，加索引，会不会产生锁表？"></a>👌mysql中已经存在的表，加索引，会不会产生锁表？</h1><h3 id="在线DDL添加索引"><a href="#在线DDL添加索引" class="headerlink" title="在线DDL添加索引"></a>在线DDL添加索引</h3><p>在MySQL 5.5及更早版本，InnoDB不支持在线DDL操作，添加索引会锁定表，阻止任何读写操作，直到索引创建完成。</p>
<p>在MySQL 5.6及以上版本中，InnoDB存储引擎支持在线添加索引，这意味着在大多数情况下，表仍然可以被读取和写入。只有在索引创建的初始和最终阶段会短暂锁定表。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>要在线添加索引，你可以使用标准的<code>ALTER TABLE</code>语句。MySQL会自动决定是否可以在线完成操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTERTABLE table_name ADD INDEX index_name (column_name);</span><br></pre></td></tr></table></figure>

<h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><ul>
<li><strong>初始和最终阶段锁定</strong>：在索引创建的开始和结束阶段，表会被短暂锁定。</li>
<li><strong>中间阶段无锁定</strong>：在索引创建的中间阶段，表可以继续进行读写操作。</li>
</ul>
<h3 id="使用Percona-Toolkit的pt-online-schema-change（主流）"><a href="#使用Percona-Toolkit的pt-online-schema-change（主流）" class="headerlink" title="使用Percona Toolkit的pt-online-schema-change（主流）"></a>使用Percona Toolkit的pt-online-schema-change（主流）</h3><p>对于一些复杂的DDL操作或者在不支持在线DDL的环境中，可以使用Percona Toolkit的<code>pt-online-schema-change</code>工具进行在线模式变更。这是一个强大的工具，可以在不中断服务的情况下进行DDL操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change --alter &quot;ADD INDEX idx_last_name (last_name)&quot; D=database_name,t=employees --execute</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>性能影响</strong>：虽然在线DDL操作不会完全锁定表，但仍然会对性能产生一定影响，特别是在高负载的环境中。</li>
<li><strong>空间需求</strong>：在线添加索引可能需要额外的磁盘空间，因为MySQL会创建一个临时表来构建新的索引。</li>
<li><strong>版本要求</strong>：确保你的MySQL版本在5.6及以上，并且使用InnoDB存储引擎，以支持在线DDL操作。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">117</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
