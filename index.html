<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/06/JVM/JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/06/JVM/JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌JVM主要组成部分有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-06T13:33:41+00:00">
                2025-05-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM主要组成部分有哪些？"><a href="#👌JVM主要组成部分有哪些？" class="headerlink" title="👌JVM主要组成部分有哪些？"></a>👌JVM主要组成部分有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p><img src="/2025/05/06/JVM/JVM%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/bfRGipU0bnWvup3D/1725898764439-e7db4bb9-4d60-4b85-9b3d-02c5dbfd311c-379175.png" alt="1725898764439-e7db4bb9-4d60-4b85-9b3d-02c5dbfd311c.png"></p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>类加载子系统负责将 .class 文件加载到内存中，并进行验证、准备、解析和初始化。</p>
<p><strong>主要功能</strong>：</p>
<p><strong>加载</strong>：从文件系统或网络中读取 .class 文件。</p>
<p><strong>验证</strong>：确保字节码文件的正确性和安全性。</p>
<p><strong>准备</strong>：为类的静态变量分配内存并设置默认初始值。</p>
<p><strong>解析</strong>：将符号引用转换为直接引用。</p>
<p><strong>初始化</strong>：执行类的静态初始化块和静态变量的初始化。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM 在运行时将内存划分为多个不同的数据区域，每个区域都有特定的用途。</p>
<p><strong>方法区（Method Area）</strong>：存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。</p>
<p><strong>堆（Heap）</strong>：存储所有对象实例和数组，是垃圾收集的主要区域。</p>
<p><strong>Java 栈（Java Stacks）</strong>：每个线程都有自己的 Java 栈，存储局部变量表、操作数栈、动态链接、方法返回地址等信息。</p>
<p><strong>本地方法栈（Native Method Stacks）</strong>：为本地方法调用服务，存储本地方法调用的状态。</p>
<p><strong>程序计数器（Program Counter Register）</strong>：每个线程都有自己的程序计数器，指示当前线程执行的字节码行号。</p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>执行引擎负责执行字节码指令。</p>
<p><strong>主要组件</strong>：</p>
<p><strong>解释器（Interpreter）</strong>：逐条解释执行字节码指令，速度较慢。</p>
<p><strong>即时编译器（Just-In-Time Compiler, JIT）</strong>：将热点代码（频繁执行的代码）编译为本地机器码，提高执行速度。</p>
<p><strong>垃圾收集器（Garbage Collector, GC）</strong>：自动管理内存，回收不再使用的对象，防止内存泄漏。</p>
<h2 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h2><p>本地接口（通常是 Java Native Interface, JNI）允许 Java 代码与本地（非 Java）代码进行交互。</p>
<p><strong>主要功能</strong>：</p>
<p>调用本地方法（通常是用 C 或 C++ 编写的）。</p>
<p>允许 Java 代码使用操作系统特性或访问硬件。</p>
<h2 id="本地方法库"><a href="#本地方法库" class="headerlink" title="本地方法库"></a>本地方法库</h2><p>本地方法库是存储本地方法实现的动态链接库（如 .dll 文件或 .so 文件）。</p>
<p><strong>主要功能</strong>：</p>
<p>提供本地方法的具体实现。</p>
<p>由本地接口调用以执行本地代码。</p>
<h3 id="JVM-主要组成部分的图示"><a href="#JVM-主要组成部分的图示" class="headerlink" title="JVM 主要组成部分的图示"></a>JVM 主要组成部分的图示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">|     类加载子系统 (Class Loader Subsystem)    |</span><br><span class="line">+---------------------------+</span><br><span class="line">|         运行时数据区 (Runtime Data Area)         |</span><br><span class="line">|  - 方法区 (Method Area)                        |</span><br><span class="line">|  - 堆 (Heap)                                   |</span><br><span class="line">|  - Java 栈 (Java Stacks)                       |</span><br><span class="line">|  - 本地方法栈 (Native Method Stacks)           |</span><br><span class="line">|  - 程序计数器 (Program Counter)                |</span><br><span class="line">+---------------------------+</span><br><span class="line">|          执行引擎 (Execution Engine)           |</span><br><span class="line">|  - 解释器 (Interpreter)                        |</span><br><span class="line">|  - 即时编译器 (Just-In-Time Compiler, JIT)      |</span><br><span class="line">|  - 垃圾收集器 (Garbage Collector, GC)          |</span><br><span class="line">+---------------------------+</span><br><span class="line">|         本地接口 (Native Interface)            |</span><br><span class="line">+---------------------------+</span><br><span class="line">|     本地方法库 (Native Method Libraries)      |</span><br><span class="line">+---------------------------+</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/04/JVM/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/04/JVM/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌JVM内存分配的指针碰撞与空闲列表是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-04T13:33:41+00:00">
                2025-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM内存分配的指针碰撞与空闲列表是什么？"><a href="#👌JVM内存分配的指针碰撞与空闲列表是什么？" class="headerlink" title="👌JVM内存分配的指针碰撞与空闲列表是什么？"></a>👌JVM内存分配的指针碰撞与空闲列表是什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>指针碰撞（Bump-the-pointer）和空闲列表（Free-list）是两种常见的内存分配策略。</p>
<h2 id="指针碰撞（Bump-the-pointer）"><a href="#指针碰撞（Bump-the-pointer）" class="headerlink" title="指针碰撞（Bump-the-pointer）"></a>指针碰撞（Bump-the-pointer）</h2><p>指针碰撞是一种高效的内存分配策略，适用于堆内存是连续且规整的情况。这种方法的基本思想是通过移动一个指针来分配内存。具体步骤如下：</p>
<ol>
<li><strong>内存布局</strong>：堆内存被划分为已使用的内存和空闲的内存，中间有一个指针（称为分配指针）作为分界线。</li>
<li><strong>分配内存</strong>：当需要为新对象分配内存时，只需将分配指针向空闲内存方向移动一段与对象大小相等的距离。</li>
<li><strong>更新指针</strong>：分配指针更新后，新的对象内存区域就被标记为已使用。</li>
</ol>
<p>这种方法的优点是分配速度非常快，只需简单的指针移动操作。然而，它的缺点是在堆内存不规整（例如存在内存碎片）的情况下无法使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 已使用内存 | 分配指针 | 空闲内存 |</span><br><span class="line">|------------|----------|----------|</span><br></pre></td></tr></table></figure>

<p>当分配一个对象时，分配指针向右移动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 已使用内存 | 已使用内存 | 分配指针 | 空闲内存 |</span><br><span class="line">|------------|------------|----------|----------|</span><br></pre></td></tr></table></figure>

<h2 id="空闲列表（Free-list）"><a href="#空闲列表（Free-list）" class="headerlink" title="空闲列表（Free-list）"></a>空闲列表（Free-list）</h2><p>空闲列表是一种适用于堆内存不规整的情况下的内存分配策略。它通过维护一个列表来记录所有可用的空闲内存块。具体步骤如下：</p>
<ol>
<li><strong>空闲列表</strong>：JVM 维护一个空闲列表，记录所有可用的内存块及其大小。</li>
<li><strong>查找空闲块</strong>：当需要为新对象分配内存时，JVM 会在空闲列表中查找一个足够大的内存块。</li>
<li><strong>分配内存</strong>：找到合适的内存块后，将其从空闲列表中移除，并将其标记为已使用。如果内存块大于所需大小，可能会将剩余部分重新放回空闲列表中。</li>
<li><strong>回收内存</strong>：当对象被垃圾回收器回收后，JVM 会将其内存块重新添加到空闲列表中。</li>
</ol>
<p>这种方法的优点是能够更好地利用内存，适用于内存碎片较多的情况。然而，它的缺点是分配速度较慢，因为需要在空闲列表中查找合适的内存块。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><p>假设空闲列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空闲列表: [块1(大小: 32), 块2(大小: 64), 块3(大小: 128)]</span><br></pre></td></tr></table></figure>

<p>当需要分配一个大小为 50 的对象时，JVM 会在空闲列表中查找：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到块2(大小: 64)</span><br></pre></td></tr></table></figure>

<p>将块2分成两部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分配块2的前50个单位，剩余部分重新放回空闲列表</span><br><span class="line">空闲列表: [块1(大小: 32), 块2剩余部分(大小: 14), 块3(大小: 128)]</span><br></pre></td></tr></table></figure>



<p><strong>指针碰撞（Bump-the-pointer）</strong>：适用于堆内存规整的情况，分配速度快，但不适用于内存碎片较多的情况。</p>
<p><strong>空闲列表（Free-list）</strong>：适用于堆内存不规整的情况，能够更好地利用内存，但分配速度较慢。</p>
<p>这两种内存分配策略各有优缺点，JVM 会根据具体情况选择合适的策略，以优化内存分配和垃圾回收的效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/04/JVM/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/04/JVM/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌jvm垃圾回收算法有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-04T13:33:41+00:00">
                2025-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm垃圾回收算法有哪些？"><a href="#👌jvm垃圾回收算法有哪些？" class="headerlink" title="👌jvm垃圾回收算法有哪些？"></a>👌jvm垃圾回收算法有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>垃圾回收算法的核心在于解决两个问题：一是确定哪些对象能够被回收（引用计数法、可达性分析法），二是如何回收这些对象。</p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法（Reference Counting）是一种内存管理技术，用于跟踪对象的引用数量。每个对象都有一个引用计数器，记录着指向该对象的引用数量。</p>
<p>当一个对象被引用时，引用计数器加一；当一个引用被释放时，引用计数器减一。当引用计数器为零时，表示没有任何引用指向该对象，该对象可以被释放，回收其占用的内存。</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>可达性分析算法是JVM垃圾回收中的一种算法，它通过分析对象的引用关系，判断对象是否可达，从而决定对象是否可以被回收。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>垃圾收集器首先遍历对象图，标记所有可达的对象，然后清除未标记的对象。简单直接，不需要移动对象。但是会产生内存碎片，可能导致大对象分配失败。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>在标记阶段标记所有可达的对象后，压缩阶段将存活的对象移动到内存的一端，整理出连续的可用内存空间。这种方式消除了内存碎片问题。但是对象移动需要额外的时间和资源。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>将内存分为两个相等的区域，每次只使用其中一个。当这个区域使用完时，将存活的对象复制到另一个区域，然后清空当前区域。这种方式简单高效，没有内存碎片问题。缺点就是需要双倍的内存空间。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象的生命周期将堆内存划分为几代（通常是新生代和老年代），新生代使用复制算法，老年代使用标记-整理或标记-清除算法。优化了垃圾收集性能，因为大部分对象在新生代被收集，减少了老年代的垃圾收集频率。不过需要额外的内存管理和调优。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>将堆内存划分为多个小的独立区域（Region），每个区域可以独立进行垃圾收集。这种方式提高了内存管理的灵活性和效率，适用于大堆内存的应用。缺点是实现较复杂，需要精细的内存管理。</p>
<h3 id="具体垃圾收集器使用的算法"><a href="#具体垃圾收集器使用的算法" class="headerlink" title="具体垃圾收集器使用的算法"></a>具体垃圾收集器使用的算法</h3><p><strong>Serial GC</strong>：使用标记-整理算法。</p>
<p><strong>Parallel GC</strong>：新生代使用复制算法，老年代使用标记-整理算法。</p>
<p><strong>CMS GC</strong>：新生代使用复制算法，老年代使用标记-清除算法，并发标记和清除。</p>
<p><strong>G1 GC</strong>：分区算法，结合标记-整理和复制算法。</p>
<p><strong>ZGC</strong>：分区算法，使用染色指针和读屏障技术，实现并发标记和压缩。</p>
<p><strong>Shenandoah GC</strong>：分区算法，使用并发标记和并发压缩技术。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/Java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/Java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA_/" itemprop="url">👌Java类初始化时机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java类初始化时机"><a href="#👌Java类初始化时机" class="headerlink" title="👌Java类初始化时机?"></a>👌Java类初始化时机?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h2><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>当使用new关键字创建类的实例时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = new MyClass();</span><br></pre></td></tr></table></figure>

<h3 id="访问类的静态变量或静态方法"><a href="#访问类的静态变量或静态方法" class="headerlink" title="访问类的静态变量或静态方法"></a>访问类的静态变量或静态方法</h3><p>当访问类的静态变量或调用静态方法时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MyClass.staticVar);</span><br><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>通过反射 API 对类进行反射调用时，类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.example.MyClass&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="初始化子类"><a href="#初始化子类" class="headerlink" title="初始化子类"></a>初始化子类</h3><p>当初始化一个类的子类时，父类会被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child = new Child(); // 输出：Parent initialized, Child initialized</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-虚拟机启动时"><a href="#Java-虚拟机启动时" class="headerlink" title="Java 虚拟机启动时"></a>Java 虚拟机启动时</h3><p>包含main方法的类在虚拟机启动时会被初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Main class initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h2><h3 id="通过子类引用父类的静态字段"><a href="#通过子类引用父类的静态字段" class="headerlink" title="通过子类引用父类的静态字段"></a>通过子类引用父类的静态字段</h3><p>通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static int value = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Child.value); // 输出：42，不会触发 Child 的初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义对象数组"><a href="#定义对象数组" class="headerlink" title="定义对象数组"></a>定义对象数组</h3><p>定义类的对象数组不会触发类的初始化。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass[] array = newMyClass[10]; // 不会触发 MyClass 的初始化</span><br></pre></td></tr></table></figure>

<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>引用常量不会触发类的初始化，因为常量在编译阶段会存入调用类的常量池中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    static final int CONSTANT = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyClass.CONSTANT); // 不会触发 MyClass 的初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/" itemprop="url">👌Java类加载器的机制是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java类加载器的机制是什么"><a href="#👌Java类加载器的机制是什么" class="headerlink" title="👌Java类加载器的机制是什么?"></a>👌Java类加载器的机制是什么?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 的类加载机制是 JVM 负责将类文件加载到内存中，并将其转换为Class对象的过程。它包括三个主要步骤：加载（Loading）、链接（Linking）和初始化（Initialization）。以下是详细的描述：</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载阶段是将类文件读入内存，并创建一个Class对象的过程。具体步骤如下：</p>
<p><strong>查找和导入类的二进制数据</strong>：从不同的来源（如文件系统、网络等）获取类的字节码。</p>
<p><strong>创建Class对象</strong>：将字节码转换为 JVM 能够识别的Class对象。</p>
<p>加载阶段可以通过系统类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）等完成。</p>
<h3 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h3><p>链接阶段将类的二进制数据合并到 JVM 运行时环境中。链接阶段包括三个步骤：</p>
<p><strong>验证（Verification）</strong>：确保类的字节码符合 JVM 规范，保证不会破坏 JVM 的安全性。</p>
<p><strong>准备（Preparation）</strong>：为类的静态变量分配内存，并将其初始化为默认值。</p>
<p><strong>解析（Resolution）</strong>：将常量池中的符号引用转换为直接引用。</p>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><p>初始化阶段是执行类构造器<clinit>方法的过程。该方法是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块（static {}）中的语句合并产生的。初始化阶段是类加载过程的最后一步。</clinit></p>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>Java 的类加载器负责加载类文件。Java 中的类加载器遵循双亲委派模型（Parent Delegation Model），即类加载器在加载类时会先委托给父类加载器加载，如果父类加载器无法加载，再尝试自己加载。</p>
<h3 id="双亲委派模型（Parent-Delegation-Model）"><a href="#双亲委派模型（Parent-Delegation-Model）" class="headerlink" title="双亲委派模型（Parent Delegation Model）"></a>双亲委派模型（Parent Delegation Model）</h3><p>双亲委派模型的工作流程如下：</p>
<ol>
<li><strong>检查缓存</strong>：类加载器首先检查缓存中是否已经加载过该类，如果已经加载，则直接返回Class对象。</li>
<li><strong>委托父类加载</strong>：如果缓存中没有，则委托父类加载器加载。</li>
<li><strong>父类加载失败</strong>：如果父类加载器加载失败（抛出ClassNotFoundException），则由当前类加载器尝试加载。</li>
</ol>
<p>这种模型的好处是避免类的重复加载，确保核心类库不会被自定义类加载器加载和覆盖。</p>
<h3 id="常见的类加载器"><a href="#常见的类加载器" class="headerlink" title="常见的类加载器"></a>常见的类加载器</h3><p><strong>Bootstrap ClassLoader</strong>：引导类加载器，负责加载核心类库，如rt.jar中的类。它是用原生代码实现的，不是java.lang.ClassLoader的子类。</p>
<p><strong>Extension ClassLoader</strong>：扩展类加载器，负责加载JAVA_HOME&#x2F;lib&#x2F;ext目录中的类。</p>
<p><strong>Application ClassLoader</strong>：应用程序类加载器，负责加载应用程序的类路径（classpath）中的类。</p>
<h2 id="类加载器的示例"><a href="#类加载器的示例" class="headerlink" title="类加载器的示例"></a>类加载器的示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在路径</span><br><span class="line">            MyClassLoader classLoader = new MyClassLoader(&quot;/path/to/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/03/JVM/jvm%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/03/JVM/jvm%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F/" itemprop="url">👌新生代空间大小的比例及如何调整？？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-03T13:33:41+00:00">
                2025-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-新生代空间大小的比例及如何调整？"><a href="#👌jvm-新生代空间大小的比例及如何调整？" class="headerlink" title="👌jvm 新生代空间大小的比例及如何调整？"></a>👌jvm 新生代空间大小的比例及如何调整？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，堆内存通常被划分为新生代（Young Generation）和老年代（Old Generation）。新生代又进一步划分为 Eden 区和两个 Survivor 区（S0 和 S1）。调整新生代空间大小的主要目的是优化垃圾收集性能，减少应用程序的停顿时间。</p>
<h2 id="新生代空间的默认比例"><a href="#新生代空间的默认比例" class="headerlink" title="新生代空间的默认比例"></a>新生代空间的默认比例</h2><p>默认情况下，HotSpot JVM 使用的比例大致如下：</p>
<p><strong>新生代（Young Generation）</strong>：占整个堆内存的 1&#x2F;3 到 1&#x2F;4 左右。</p>
<p><strong>老年代（Old Generation）</strong>：占整个堆内存的 2&#x2F;3 到 3&#x2F;4 左右。</p>
<p>在新生代内部，默认的比例是：</p>
<p><strong>Eden 区</strong>：占新生代的 8&#x2F;10（即 80%）。</p>
<p><strong>每个 Survivor 区（S0 和 S1）</strong>：各占新生代的 1&#x2F;10（即 10%）。</p>
<h2 id="新生代空间大小的调整"><a href="#新生代空间大小的调整" class="headerlink" title="新生代空间大小的调整"></a>新生代空间大小的调整</h2><h3 id="调整新生代和老年代的比例"><a href="#调整新生代和老年代的比例" class="headerlink" title="调整新生代和老年代的比例"></a>调整新生代和老年代的比例</h3><p><strong>-Xms和-Xmx</strong>：设置堆内存的初始大小和最大大小。</p>
<p><strong>-XX:NewSize和-XX:MaxNewSize</strong>：设置新生代的初始大小和最大大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=512m</span><br><span class="line">-XX:MaxNewSize=512m</span><br></pre></td></tr></table></figure>

<p><strong>-XX:NewRatio</strong>：设置新生代和老年代的比例。例如，-XX:NewRatio&#x3D;3 表示新生代占整个堆的 1&#x2F;4，老年代占 3&#x2F;4。</p>
<h3 id="调整-Eden-区和-Survivor-区的比例"><a href="#调整-Eden-区和-Survivor-区的比例" class="headerlink" title="调整 Eden 区和 Survivor 区的比例"></a>调整 Eden 区和 Survivor 区的比例</h3><p><strong>-XX:SurvivorRatio</strong>：设置 Eden 区和 Survivor 区的比例。例如，-XX:SurvivorRatio&#x3D;8表示 Eden 区占新生代的 8&#x2F;10，每个 Survivor 区占 1&#x2F;10。</p>
<h3 id="调整-Survivor-区的数量"><a href="#调整-Survivor-区的数量" class="headerlink" title="调整 Survivor 区的数量"></a>调整 Survivor 区的数量</h3><p><strong>-XX:SurvivorRatio</strong>：默认情况下，JVM 使用两个 Survivor 区（S0 和 S1）。你可以通过调整 Survivor 区的比例来优化内存使用和垃圾收集性能。</p>
<h3 id="动态调整新生代大小"><a href="#动态调整新生代大小" class="headerlink" title="动态调整新生代大小"></a>动态调整新生代大小</h3><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小策略，JVM 会根据应用程序的运行情况动态调整新生代和老年代的大小。</p>
<h2 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h2><p>在调整新生代空间大小时，需要考虑以下因素：</p>
<p><strong>应用程序的对象生命周期</strong>：</p>
<p>如果应用程序创建了大量短生命周期对象（例如 Web 应用中的请求对象），则需要较大的新生代空间，以减少 Minor GC 的频率。</p>
<p>如果应用程序有较多长生命周期对象，则需要较大的老年代空间，以减少 Major GC 的频率。</p>
<p><strong>GC 日志分析</strong>：</p>
<p>启用 GC 日志（例如-Xlog:gc*或-XX:+PrintGCDetails），分析垃圾收集的频率和停顿时间，调整新生代和老年代的大小以优化性能。</p>
<p><strong>性能测试</strong>：</p>
<p>在调整 JVM 参数后，进行性能测试，观察 GC 行为和应用程序的响应时间，进一步调整参数以达到最佳性能。</p>
<h2 id="配置-demo"><a href="#配置-demo" class="headerlink" title="配置 demo"></a>配置 demo</h2><p>假设你有一个堆内存大小为 4GB 的 JVM 实例，你希望新生代占 1GB，老年代占 3GB，并且 Eden 区占新生代的 80%，每个 Survivor 区占 10%。可以使用如下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Xms4g -Xmx4g</span><br><span class="line">-XX:NewSize=1g </span><br><span class="line">-XX:MaxNewSize=1g</span><br><span class="line">-XX:NewRatio=3</span><br><span class="line">-XX:SurvivorRatio=8</span><br></pre></td></tr></table></figure>



<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/qd6qd8z80xv9420a">https://www.yuque.com/jingdianjichi/xyxdsi/qd6qd8z80xv9420a</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8_/" itemprop="url">👌Java双亲委派机制的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java双亲委派机制的作用"><a href="#👌Java双亲委派机制的作用" class="headerlink" title="👌Java双亲委派机制的作用?"></a>👌Java双亲委派机制的作用?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="保证-Java-核心库的安全性"><a href="#保证-Java-核心库的安全性" class="headerlink" title="保证 Java 核心库的安全性"></a>保证 Java 核心库的安全性</h2><p>通过双亲委派机制，Java 核心库（如java.lang.Object等）由启动类加载器（Bootstrap ClassLoader）加载。由于启动类加载器是在 JVM 启动时由本地代码实现的，并且它加载的类路径是固定的系统核心库路径，因此可以确保这些核心类不会被篡改或替换。这样系统的安全性和稳定性得到了保障。</p>
<h2 id="避免类的重复加载"><a href="#避免类的重复加载" class="headerlink" title="避免类的重复加载"></a>避免类的重复加载</h2><p>双亲委派机制确保了每个类只会被加载一次。如果一个类已经被父类加载器加载过，那么子类加载器就不会再重复加载这个类。这样可以避免类的重复加载，提高类加载的效率，并减少内存消耗。</p>
<h2 id="保证类加载的一致性"><a href="#保证类加载的一致性" class="headerlink" title="保证类加载的一致性"></a>保证类加载的一致性</h2><p>通过双亲委派机制，可以确保同一个类在整个 JVM 中只有一个定义。这样可以避免类的冲突和不一致问题。例如，如果应用程序和第三方库中都定义了一个相同的类名，通过双亲委派机制可以确保最终加载的是位于更高层次的类加载器中的类，从而避免冲突。</p>
<h2 id="提高类加载的效率"><a href="#提高类加载的效率" class="headerlink" title="提高类加载的效率"></a>提高类加载的效率</h2><p>双亲委派机制通过将类加载请求逐级向上委派，可以利用已经加载的类，提高类加载的效率。父类加载器在加载类时，如果该类已经被加载过，那么直接返回该类的引用，从而减少了重复加载的开销。</p>
<h2 id="支持动态扩展"><a href="#支持动态扩展" class="headerlink" title="支持动态扩展"></a>支持动态扩展</h2><p>双亲委派机制允许在不同的类加载器中加载不同的类，从而支持动态扩展。例如，应用程序类加载器（Application ClassLoader）可以加载应用程序特定的类，而扩展类加载器（Extension ClassLoader）可以加载扩展库中的类，这样可以方便地进行动态扩展和模块化开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%BB%93%E6%9D%9F_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E7%A8%8B%E4%BD%95%E6%97%B6%E7%BB%93%E6%9D%9F_/" itemprop="url">👌Java虚拟机进程何时结束</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java虚拟机进程何时结束"><a href="#👌Java虚拟机进程何时结束" class="headerlink" title="👌Java虚拟机进程何时结束?"></a>👌Java虚拟机进程何时结束?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="所有非守护线程（Non-Daemon-Threads）结束"><a href="#所有非守护线程（Non-Daemon-Threads）结束" class="headerlink" title="所有非守护线程（Non-Daemon Threads）结束"></a>所有非守护线程（Non-Daemon Threads）结束</h2><p>JVM 进程会在所有非守护线程结束后自动退出。非守护线程是默认的线程类型，通常用于执行主要任务。守护线程（Daemon Thread）则是辅助线程，通常用于执行后台任务，例如垃圾回收。</p>
<p><strong>非守护线程</strong>：主要任务线程，JVM 会等待其执行完毕。</p>
<p><strong>守护线程</strong>：辅助任务线程，JVM 不会等待其执行完毕。</p>
<p>当所有非守护线程都结束时，JVM 会自动退出，即使还有守护线程在运行。</p>
<h2 id="调用System-exit-int-status"><a href="#调用System-exit-int-status" class="headerlink" title="调用System.exit(int status)"></a>调用System.exit(int status)</h2><p>可以通过调用System.exit(int status)方法来显式终止 JVM 进程。status参数是一个整数，通常用于表示退出状态码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExitExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Program is exiting&quot;);</span><br><span class="line">        System.exit(0); // 正常退出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System.exit(0)：表示正常退出。非零状态码：表示异常退出。</p>
<h2 id="JVM-遇到未捕获的异常或错误"><a href="#JVM-遇到未捕获的异常或错误" class="headerlink" title="JVM 遇到未捕获的异常或错误"></a>JVM 遇到未捕获的异常或错误</h2><p>如果主线程或其他非守护线程中出现未捕获的异常或错误，且没有相应的异常处理机制，JVM 进程会终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UncaughtExceptionExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Uncaught exception&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过外部命令强制终止"><a href="#通过外部命令强制终止" class="headerlink" title="通过外部命令强制终止"></a>通过外部命令强制终止</h2><p>可以使用操作系统的命令或工具强制终止 JVM 进程，例如使用kill命令（在 Unix&#x2F;Linux 系统上）或任务管理器（在 Windows 系统上）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找 JVM 进程 ID</span><br><span class="line">ps -ef | grep java</span><br><span class="line"></span><br><span class="line"># 强制终止 JVM 进程</span><br><span class="line">kill -9 &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="主线程结束且没有其他非守护线程"><a href="#主线程结束且没有其他非守护线程" class="headerlink" title="主线程结束且没有其他非守护线程"></a>主线程结束且没有其他非守护线程</h2><p>如果主线程结束且没有其他非守护线程在运行，JVM 进程也会结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MainThreadExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Main thread is ending&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用Runtime-halt-int-status"><a href="#调用Runtime-halt-int-status" class="headerlink" title="调用Runtime.halt(int status)"></a>调用Runtime.halt(int status)</h2><p>Runtime.halt(int status)方法会立即终止 JVM 进程，不执行任何关闭钩子（Shutdown Hook）或finalize方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HaltExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime.getRuntime().halt(0); // 立即终止 JVM</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭钩子（Shutdown-Hook）"><a href="#关闭钩子（Shutdown-Hook）" class="headerlink" title="关闭钩子（Shutdown Hook）"></a>关闭钩子（Shutdown Hook）</h2><p>在 JVM 进程结束前，可以注册关闭钩子来执行一些清理操作。关闭钩子是在 JVM 关闭前执行的线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ShutdownHookExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;Shutdown hook is running&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Main thread is ending&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/" itemprop="url">👌java双亲委派机制是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌java双亲委派机制是什么"><a href="#👌java双亲委派机制是什么" class="headerlink" title="👌java双亲委派机制是什么?"></a>👌java双亲委派机制是什么?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的双亲委派机制是一种类加载机制，用于确保 Java 类加载过程的安全性和一致性。它的主要思想是：每个类加载器在加载类时，首先将请求委派给父类加载器，只有当父类加载器无法完成加载时，才由当前类加载器尝试加载类。</p>
<p><img src="/2025/05/02/JVM/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88_/NoYLGZ3O7K1yv5z_/1725898211982-d09b6999-76ec-4ab2-9720-b89c0a8fc87f-847285.png" alt="1725898211982-d09b6999-76ec-4ab2-9720-b89c0a8fc87f.png"></p>
<h2 id="双亲委派机制的工作流程"><a href="#双亲委派机制的工作流程" class="headerlink" title="双亲委派机制的工作流程"></a>双亲委派机制的工作流程</h2><p><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载 Java 核心库（位于JAVA_HOME&#x2F;lib目录下的类库，如rt.jar）。</p>
<p><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载 Java 扩展库（位于JAVA_HOME&#x2F;lib&#x2F;ext目录下的类库）。</p>
<p><strong>应用程序类加载器（Application ClassLoader）</strong>：负责加载应用程序类路径（classpath）上的类。</p>
<p>加载类的具体步骤如下：</p>
<ol>
<li><strong>当前类加载器收到类加载请求</strong>：当一个类加载器收到加载类的请求时，它不会立即尝试加载该类。</li>
<li><strong>将请求委派给父类加载器</strong>：当前类加载器首先将加载请求委派给父类加载器。</li>
<li><strong>父类加载器处理请求</strong>：</li>
</ol>
<p>如果父类加载器存在，则父类加载器会继续将请求向上委派，直到到达启动类加载器。启动类加载器尝试加载类，如果成功，则返回类的引用。</p>
<ol start="4">
<li><strong>父类加载器无法加载类</strong>：如果启动类加载器无法加载该类，加载失败返回到子类加载器。</li>
<li><strong>当前类加载器尝试加载类</strong>：如果父类加载器无法加载该类，则由当前类加载器尝试加载。</li>
</ol>
<p>通过这种机制，可以确保核心类库不会被篡改，避免了类的重复加载和类的冲突问题。</p>
<h2 id="双亲委派机制的优点"><a href="#双亲委派机制的优点" class="headerlink" title="双亲委派机制的优点"></a>双亲委派机制的优点</h2><p><strong>安全性</strong>：通过将类加载请求逐级向上委派，可以避免核心类库被篡改或替换，确保系统安全。</p>
<p><strong>避免类的重复加载</strong>：确保每个类只被加载一次，避免类的重复加载和类的冲突问题。</p>
<p><strong>提高加载效率</strong>：通过委派机制，可以利用已经加载的类，提高类加载的效率。</p>
<h2 id="双亲委派机制的例外"><a href="#双亲委派机制的例外" class="headerlink" title="双亲委派机制的例外"></a>双亲委派机制的例外</h2><p>尽管双亲委派机制是 Java 类加载的标准机制，但在某些情况下，这一机制会被打破。例如：</p>
<p><strong>自定义类加载器</strong>：某些自定义类加载器可能会覆盖默认的双亲委派机制，直接加载类。</p>
<p><strong>OSGi 框架</strong>：OSGi 框架中，类加载机制更加复杂，可能会打破双亲委派机制。</p>
<p><strong>SPI（Service Provider Interface）</strong>：在某些服务提供者接口的实现中，可能需要打破双亲委派机制来加载服务实现类。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/02/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/02/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_/" itemprop="url">👌jvm 运行时的数据区域如何理解?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-02T13:33:41+00:00">
                2025-05-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-运行时的数据区域如何理解"><a href="#👌jvm-运行时的数据区域如何理解" class="headerlink" title="👌jvm 运行时的数据区域如何理解?"></a>👌jvm 运行时的数据区域如何理解?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Java 虚拟机（JVM）在运行时将内存划分为若干不同的数据区域，每个区域都有特定的用途。</p>
<p><img src="/2025/05/02/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3_/2SSdo9L3kmTfJk6j/1725852039025-ee339bb3-3b55-4c11-a3a7-23d21fd77305-189789.png" alt="1725852039025-ee339bb3-3b55-4c11-a3a7-23d21fd77305.png"></p>
<h2 id="JVM-运行时数据区域"><a href="#JVM-运行时数据区域" class="headerlink" title="JVM 运行时数据区域"></a>JVM 运行时数据区域</h2><p>JVM 运行时数据区域主要包括以下几个部分：</p>
<p><strong>方法区 (Method Area)</strong></p>
<p><strong>堆 (Heap)</strong></p>
<p><strong>Java 栈 (Java Stacks)</strong></p>
<p><strong>本地方法栈 (Native Method Stacks)</strong></p>
<p><strong>程序计数器 (Program Counter Register)</strong></p>
<h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区 (Method Area)"></a>方法区 (Method Area)</h3><p>方法区是所有线程共享的内存区域，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><strong>功能</strong>：</p>
<p>存储类的结构信息（如类的名称、访问修饰符、字段描述、方法描述等）。</p>
<p>存储运行时常量池，包括字面量和符号引用。</p>
<p>存储静态变量。</p>
<p>存储编译后的代码。</p>
<p>在 HotSpot JVM 中，方法区的一部分实现为永久代（PermGen），在 Java 8 及以后版本中被称为元空间（Metaspace）。</p>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 (Heap)"></a>堆 (Heap)</h3><p>堆是所有线程共享的内存区域，用于存储所有对象实例和数组。</p>
<p><strong>功能</strong>：</p>
<p>动态分配对象内存。</p>
<p>垃圾收集器主要在堆上工作，回收不再使用的对象内存。</p>
<p>堆通常分为年轻代（Young Generation）和老年代（Old Generation），年轻代又进一步划分为 Eden 区和两个 Survivor 区（S0 和 S1）。</p>
<h3 id="Java-栈-Java-Stacks"><a href="#Java-栈-Java-Stacks" class="headerlink" title="Java 栈 (Java Stacks)"></a>Java 栈 (Java Stacks)</h3><p>每个线程都有自己的 Java 栈，栈帧（Stack Frame）在栈中按顺序存储。</p>
<p><strong>功能</strong>：</p>
<p>存储局部变量表、操作数栈、动态链接、方法返回地址等信息。</p>
<p>每调用一个方法，就会创建一个新的栈帧，方法执行完毕后栈帧被销毁。</p>
<p>栈帧包括：</p>
<p>局部变量表：存储方法的局部变量，包括参数和方法内部的局部变量。</p>
<p>操作数栈：用于操作数的临时存储。</p>
<p>动态链接：指向常量池的方法引用。</p>
<p>方法返回地址：方法调用后的返回地址。</p>
<h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈 (Native Method Stacks)"></a>本地方法栈 (Native Method Stacks)</h3><p>本地方法栈与 Java 栈类似，但它为本地（Native）方法服务。</p>
<p><strong>功能</strong>：</p>
<p>存储本地方法调用的状态。</p>
<p>一些 JVM 使用 C 栈来支持本地方法调用。</p>
<h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器 (Program Counter Register)"></a>程序计数器 (Program Counter Register)</h3><p>每个线程都有自己的程序计数器，是一个很小的内存区域。</p>
<p><strong>功能</strong>：</p>
<p>当前线程所执行的字节码的行号指示器。</p>
<p>如果当前执行的是本地方法，这个计数器值为空（Undefined）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/01/JVM/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/01/JVM/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8_/" itemprop="url">👌Java如何实现自己的类加载器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-01T13:33:41+00:00">
                2025-05-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Java如何实现自己的类加载器"><a href="#👌Java如何实现自己的类加载器" class="headerlink" title="👌Java如何实现自己的类加载器?"></a>👌Java如何实现自己的类加载器?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，类加载器（ClassLoader）是负责将类文件加载到 JVM 中的组件。实现自定义类加载器可以让你控制类加载的过程，例如从非标准位置加载类文件、解密类文件等。</p>
<h2 id="实现自定义类加载器的步骤"><a href="#实现自定义类加载器的步骤" class="headerlink" title="实现自定义类加载器的步骤"></a>实现自定义类加载器的步骤</h2><p><strong>继承ClassLoader类</strong>：自定义类加载器需要继承java.lang.ClassLoader类。</p>
<p><strong>重写findClass方法</strong>：重写findClass(String name)方法，这是自定义类加载器的核心方法，用于定义类的加载逻辑。</p>
<p><strong>调用defineClass方法</strong>：在findClass方法中，通过defineClass方法将字节数组转换为Class对象。</p>
<h2 id="从文件系统加载类-Demo"><a href="#从文件系统加载类-Demo" class="headerlink" title="从文件系统加载类 Demo"></a>从文件系统加载类 Demo</h2><h4 id="创建自定义类加载器"><a href="#创建自定义类加载器" class="headerlink" title="创建自定义类加载器"></a>创建自定义类加载器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classPath;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为文件路径</span><br><span class="line">            String fileName = classPath + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 读取类文件的字节码</span><br><span class="line">            byte[] classBytes = Files.readAllBytes(Paths.get(fileName));</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用自定义类加载器加载类"><a href="#使用自定义类加载器加载类" class="headerlink" title="使用自定义类加载器加载类"></a>使用自定义类加载器加载类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CustomClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在路径</span><br><span class="line">            MyClassLoader classLoader = new MyClassLoader(&quot;/path/to/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从网络加载类-Demo"><a href="#从网络加载类-Demo" class="headerlink" title="从网络加载类 Demo"></a>从网络加载类 Demo</h2><h4 id="创建自定义类加载器-1"><a href="#创建自定义类加载器-1" class="headerlink" title="创建自定义类加载器"></a>创建自定义类加载器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">public class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String baseUrl;</span><br><span class="line"></span><br><span class="line">    public NetworkClassLoader(String baseUrl) &#123;</span><br><span class="line">        this.baseUrl = baseUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将类名转换为 URL</span><br><span class="line">            String url = baseUrl + name.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br><span class="line">            // 从网络读取类文件的字节码</span><br><span class="line">            InputStream inputStream = new URL(url).openStream();</span><br><span class="line">            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();</span><br><span class="line">            int nextValue = 0;</span><br><span class="line">            while ((nextValue = inputStream.read()) != -1) &#123;</span><br><span class="line">                byteStream.write(nextValue);</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] classBytes = byteStream.toByteArray();</span><br><span class="line">            // 将字节码转换为 Class 对象</span><br><span class="line">            return defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用自定义类加载器加载类-1"><a href="#使用自定义类加载器加载类-1" class="headerlink" title="使用自定义类加载器加载类"></a>使用自定义类加载器加载类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkClassLoaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建自定义类加载器，指定类文件所在的基 URL</span><br><span class="line">            NetworkClassLoader classLoader = new NetworkClassLoader(&quot;http://example.com/classes/&quot;);</span><br><span class="line">            // 加载类</span><br><span class="line">            Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.example.MyClass&quot;);</span><br><span class="line">            // 创建类的实例</span><br><span class="line">            Object instance = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">            // 调用方法</span><br><span class="line">            clazz.getMethod(&quot;myMethod&quot;).invoke(instance);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/JVM/JVM%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/JVM/JVM%E5%A0%86%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88/" itemprop="url">👌JVM堆的内部结构是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T13:33:41+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM堆的内部结构是什么"><a href="#👌JVM堆的内部结构是什么" class="headerlink" title="👌JVM堆的内部结构是什么"></a>👌JVM堆的内部结构是什么</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 堆是 Java 虚拟机用于存储对象实例和数组的内存区域。堆内存是 JVM 管理的主要内存区域之一，堆内存的管理和优化对 Java 应用程序的性能至关重要。堆内存的内部结构通常分为几个不同的区域，以便更高效地进行内存分配和垃圾回收。</p>
<h2 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h2><p>新生代用于存储新创建的对象。大多数对象在新生代中创建，并且很快就会被垃圾回收。新生代进一步分为三个区域：</p>
<p><strong>Eden 区（Eden Space）</strong>：大多数新对象首先分配在 Eden 区。当 Eden 区填满时，会触发一次轻量级的垃圾回收（Minor GC）。</p>
<p><strong>幸存者区（Survivor Spaces）</strong>：新生代中有两个幸存者区，称为 S0（Survivor 0）和 S1（Survivor 1）。在一次 Minor GC 之后，仍然存活的对象会从 Eden 区和当前的幸存者区复制到另一个幸存者区。两个幸存者区会在每次 GC 后交替使用。</p>
<h2 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h2><p>老年代用于存储生命周期较长的对象。那些在新生代经历了多次垃圾回收仍然存活的对象会被移动到老年代。老年代的垃圾回收相对较少，但每次回收的时间较长，称为 Major GC 或 Full GC。</p>
<h2 id="永久代（Permanent-Generation）和元空间（Metaspace）"><a href="#永久代（Permanent-Generation）和元空间（Metaspace）" class="headerlink" title="永久代（Permanent Generation）和元空间（Metaspace）"></a>永久代（Permanent Generation）和元空间（Metaspace）</h2><p><strong>永久代（Permanent Generation）</strong>：在 JDK 8 之前，永久代用于存储类的元数据、常量池、方法信息等。永久代的大小是固定的，容易导致OutOfMemoryError错误。</p>
<p><strong>元空间（Metaspace）</strong>：从 JDK 8 开始，永久代被元空间取代。元空间不在 JVM 堆中，而是使用本地内存。元空间的大小可以动态调整，减少了OutOfMemoryError的风险。</p>
<h2 id="堆内存的垃圾回收"><a href="#堆内存的垃圾回收" class="headerlink" title="堆内存的垃圾回收"></a>堆内存的垃圾回收</h2><p>JVM 使用不同的垃圾回收算法来管理堆内存。</p>
<p><strong>标记-清除（Mark-Sweep）</strong>：标记活动对象，然后清除未标记的对象。</p>
<p><strong>标记-整理（Mark-Compact）</strong>：标记活动对象，然后将它们整理到堆的一端，清理掉不活动的对象。</p>
<p><strong>复制算法（Copying）</strong>：将活动对象从一个区域复制到另一个区域，清理掉旧区域的所有对象。新生代垃圾回收通常使用这种算法。</p>
<p><strong>分代收集（Generational Collection）</strong>：基于对象的生命周期，将堆分为新生代和老年代，分别进行垃圾回收。</p>
<h2 id="堆内存的配置"><a href="#堆内存的配置" class="headerlink" title="堆内存的配置"></a>堆内存的配置</h2><p>JVM 提供了多个参数来配置堆内存的大小和行为：</p>
<p>-Xms：设置堆内存的初始大小。</p>
<p>-Xmx：设置堆内存的最大大小。</p>
<p>-XX:NewSize：设置新生代的初始大小。</p>
<p>-XX:MaxNewSize：设置新生代的最大大小。</p>
<p>-XX:SurvivorRatio：设置 Eden 区与幸存者区的比例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-Xms512m </span><br><span class="line">-Xmx1024m </span><br><span class="line">-XX:NewSize=256m </span><br><span class="line">-XX:MaxNewSize=512m </span><br><span class="line">-XX:SurvivorRatio=8 </span><br><span class="line">-XX:MetaspaceSize=128m </span><br><span class="line">-XX:MaxMetaspaceSize=256m</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/JVM/JVM%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/JVM/JVM%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌JVM对象的访问模式有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T13:33:41+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM对象的访问模式有哪些？"><a href="#👌JVM对象的访问模式有哪些？" class="headerlink" title="👌JVM对象的访问模式有哪些？"></a>👌JVM对象的访问模式有哪些？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 JVM 中，对象的访问模式主要指的是 JVM 如何通过引用来访问对象的具体字段和方法。不同的 JVM 实现可能会采用不同的访问模式，但主要有以下两种常见的模式：</p>
<h2 id="句柄访问模式（Handle-Access-Mode）"><a href="#句柄访问模式（Handle-Access-Mode）" class="headerlink" title="句柄访问模式（Handle Access Mode）"></a>句柄访问模式（Handle Access Mode）</h2><p>在句柄访问模式下，每个对象引用指向一个句柄池中的句柄。句柄本身包含两个指针，一个指向对象实例数据（实际对象），另一个指向对象的类型数据（如类元数据）。</p>
<h3 id="句柄结构"><a href="#句柄结构" class="headerlink" title="句柄结构"></a>句柄结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用 -&gt; 句柄 -&gt; [对象实例数据指针 | 类型数据指针]</span><br></pre></td></tr></table></figure>

<h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><ol>
<li><strong>引用指向句柄</strong>：对象引用首先指向句柄池中的一个句柄。</li>
<li><strong>句柄指向对象</strong>：句柄包含指向实际对象实例数据的指针和类型数据的指针。</li>
<li><strong>访问对象</strong>：通过句柄中的指针访问对象实例数据和类型数据。</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>对象移动</strong>：在垃圾回收过程中，如果对象被移动，只需更新句柄中的指针，而不需要更新所有引用。</p>
<p><strong>访问灵活</strong>：通过句柄可以灵活地管理对象的访问和元数据。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>间接访问</strong>：每次访问对象都需要通过句柄进行间接访问，增加了访问开销。</p>
<h2 id="直接指针访问模式（Direct-Pointer-Access-Mode）"><a href="#直接指针访问模式（Direct-Pointer-Access-Mode）" class="headerlink" title="直接指针访问模式（Direct Pointer Access Mode）"></a>直接指针访问模式（Direct Pointer Access Mode）</h2><p>在直接指针访问模式下，每个对象引用直接指向对象实例数据。对象实例数据中包含指向类型数据的指针（通常在对象头中）。</p>
<h3 id="直接指针结构"><a href="#直接指针结构" class="headerlink" title="直接指针结构"></a>直接指针结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用 -&gt; 对象实例数据 -&gt; [对象头 | 实例字段]</span><br></pre></td></tr></table></figure>

<h3 id="访问过程-1"><a href="#访问过程-1" class="headerlink" title="访问过程"></a>访问过程</h3><ol>
<li><strong>引用指向对象</strong>：对象引用直接指向对象实例数据。</li>
<li><strong>对象头包含类型数据指针</strong>：对象实例数据的头部包含指向类型数据的指针。</li>
<li><strong>访问对象</strong>：直接通过引用访问对象实例数据和类型数据。</li>
</ol>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p><strong>高效访问</strong>：直接指向对象实例数据，访问速度更快。</p>
<p><strong>简单结构</strong>：对象引用和对象实例数据之间的关系更简单。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p><strong>对象移动</strong>：在垃圾回收过程中，如果对象被移动，所有引用都需要更新，增加了垃圾回收的复杂性。</p>
<h2 id="选择与权衡"><a href="#选择与权衡" class="headerlink" title="选择与权衡"></a>选择与权衡</h2><p>不同的 JVM 实现会根据具体的需求和优化目标选择合适的对象访问模式。现代 JVM（如 HotSpot）通常采用直接指针访问模式，因为它在访问速度和实现复杂性之间取得了较好的平衡。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectAccessExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject obj = new MyObject();  // 创建对象</span><br><span class="line">        obj.setValue(42);               // 设置对象字段</span><br><span class="line">        int value = obj.getValue();     // 访问对象字段</span><br><span class="line">        System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyObject &#123;</span><br><span class="line">    private int value;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyObject类的实例通过直接指针访问模式进行访问。JVM 会直接通过引用访问对象的实例字段value。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/%E5%9C%BA%E6%99%AF%E9%A2%98/%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/%E5%9C%BA%E6%99%AF%E9%A2%98/%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、前置校验（redis的lua脚本实现）"><a href="#一、前置校验（redis的lua脚本实现）" class="headerlink" title="一、前置校验（redis的lua脚本实现）"></a>一、前置校验（redis的lua脚本实现）</h2><p>1、检查库从是否充足<br>2、用户是否下单过该优惠券（使用Redis中的set类型来缓存下单该优惠券的用户id集合，并且要保证数据及时更新同步，即 在检验资格通过后需要向set中添加用户id）<br><strong>Lua脚本需要的ARGV参数列表中有两个待定参数，分别是优惠券id 以及 用户id</strong></p>
<h2 id="二、处理业务"><a href="#二、处理业务" class="headerlink" title="二、处理业务"></a>二、处理业务</h2><p>1、资格检验通过，则需要保证该有效订单被阻塞队列拿到，后续阻塞式执行成功，所以将“凭证”（封装好用户id、券id、订单id的订单实例）传入阻塞队列，等待异步线程阻塞式读取处理下单业务；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/30/%E5%88%86%E5%B8%83%E5%BC%8F/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/30/%E5%88%86%E5%B8%83%E5%BC%8F/1/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/JVM%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/JVM%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌JVM的直接内存是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌JVM的直接内存是什么？"><a href="#👌JVM的直接内存是什么？" class="headerlink" title="👌JVM的直接内存是什么？"></a>👌JVM的直接内存是什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>JVM 的直接内存是指通过java.nio包中的ByteBuffer类直接分配的内存。这种内存分配方式绕过了 JVM 的堆内存管理，直接使用底层操作系统的内存分配机制。直接内存的使用可以提高 I&#x2F;O 操作的性能，因为它减少了数据在 JVM 堆内存和本地操作系统内存之间的复制开销。</p>
<h2 id="直接内存的特点"><a href="#直接内存的特点" class="headerlink" title="直接内存的特点"></a>直接内存的特点</h2><p><strong>非堆内存</strong>：</p>
<p>直接内存不属于 JVM 的堆内存区域，因此不会受到堆内存的垃圾回收机制的影响。</p>
<p>直接内存的分配和释放由操作系统管理，而不是由 JVM 的垃圾回收器管理。</p>
<p><strong>高效的 I&#x2F;O 操作</strong>：</p>
<p>直接内存特别适合用于频繁的 I&#x2F;O 操作（如文件读写、网络通信等），因为它可以减少数据在 JVM 堆内存和操作系统内存之间的复制次数。</p>
<p>例如，在使用java.nio中的FileChannel进行文件读写时，通过直接缓冲区（Direct Buffer）可以显著提高性能。</p>
<p><strong>手动管理</strong>：</p>
<p>由于直接内存不受 JVM 垃圾回收机制的管理，因此需要手动释放内存。如果不及时释放，可能会导致内存泄漏和系统性能问题。</p>
<h2 id="直接内存的分配"><a href="#直接内存的分配" class="headerlink" title="直接内存的分配"></a>直接内存的分配</h2><p>直接内存的分配通过ByteBuffer类的allocateDirect方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">public class DirectMemoryExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 分配 1 MB 的直接内存</span><br><span class="line">        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);</span><br><span class="line"></span><br><span class="line">        // 使用直接缓冲区进行读写操作</span><br><span class="line">        directBuffer.put((byte) 1);</span><br><span class="line">        directBuffer.flip();</span><br><span class="line">        byte value = directBuffer.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Value: &quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接内存的释放"><a href="#直接内存的释放" class="headerlink" title="直接内存的释放"></a>直接内存的释放</h2><p>直接内存的释放并不像堆内存那样由垃圾回收器自动管理。为了更好地控制直接内存的使用，可以使用以下方法：</p>
<ol>
<li><strong>显式释放</strong>：</li>
</ol>
<p>使用第三方库（如 Netty）提供的工具类进行显式释放。例如，Netty 提供了PlatformDependent.freeDirectBuffer方法来释放直接缓冲区。</p>
<ol start="2">
<li><strong>依赖垃圾回收</strong>：</li>
</ol>
<p>虽然直接内存不受 JVM 垃圾回收器的直接管理，但ByteBuffer对象本身仍然受垃圾回收器管理。当ByteBuffer对象被垃圾回收时，其底层的直接内存也会被释放。但是，这种方式不够及时和可靠，可能会导致内存泄漏。</p>
<h2 id="直接内存的配置"><a href="#直接内存的配置" class="headerlink" title="直接内存的配置"></a>直接内存的配置</h2><p>JVM 允许通过启动参数来配置直接内存的最大使用量：</p>
<p>-XX:MaxDirectMemorySize：用于设置直接内存的最大值。如果不设置，默认值为堆内存大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxDirectMemorySize=256m DirectMemoryExample</span><br></pre></td></tr></table></figure>





<blockquote>
<p>原文: <a target="_blank" rel="noopener" href="https://www.yuque.com/jingdianjichi/xyxdsi/foc8d6a9to7on1og">https://www.yuque.com/jingdianjichi/xyxdsi/foc8d6a9to7on1og</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/Jvm%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/Jvm%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">👌Jvm的垃圾回收是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Jvm的垃圾回收是什么？"><a href="#👌Jvm的垃圾回收是什么？" class="headerlink" title="👌Jvm的垃圾回收是什么？"></a>👌Jvm的垃圾回收是什么？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="什么是垃圾回收？"><a href="#什么是垃圾回收？" class="headerlink" title="什么是垃圾回收？"></a>什么是垃圾回收？</h2><p>所谓垃圾回收机制（Garbage Collection， 简称GC），指自动管理动态分配的内存空间的机制，自动回收不再使用的内存，不定时去堆内存中清理不可达对象，以避免内存泄漏和内存溢出的问题。最早是在1960年代提出的。</p>
<p>垃圾回收是 java相较于c、c++语言的优势之一。其他编程语言，如C#、Python和Ruby等，也都提供了垃圾回收机制。不可达的对象并不会马上就会直接回收， 垃圾收集器在一个Java程序中的执行是自动的，不能强制执行，程序员唯一能做的就是通过调用System.gc 方法来建议执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。</p>
<p>这也是垃圾收集器的最主要的缺点。</p>
<h2 id="为什么需要垃圾回收？"><a href="#为什么需要垃圾回收？" class="headerlink" title="为什么需要垃圾回收？"></a>为什么需要垃圾回收？</h2><p>如果不进行垃圾回收，内存迟早都会被消耗空，因为我们在不断的分配内存空间而不进行回收。除非内存无限大，我们可以任性的分配而不回收，但是事实并非如此。所以，垃圾回收是必须的。</p>
<p>优点：</p>
<p>减少了程序员的工作量，不需要手动管理内存</p>
<p>动态地管理内存，根据应用程序的需要进行分配和回收，提高了内存利用率</p>
<p>避免内存泄漏和野指针等问题，增加程序的稳定性和可靠</p>
<p>缺点：</p>
<p>垃圾回收会占用一定的系统资源，可能会影响程序的性能</p>
<p>垃圾回收过程中会停止程序的执行，可能会导致程序出现卡顿等问题</p>
<p>不一定能够完全解决内存泄漏等问题，需要在编写代码时注意内存管理和编码规范</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/jvm%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/jvm%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F/" itemprop="url">三色标记法的优点和缺点？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-三色标记法的优点和缺点？"><a href="#👌jvm-三色标记法的优点和缺点？" class="headerlink" title="👌jvm 三色标记法的优点和缺点？"></a>👌jvm 三色标记法的优点和缺点？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>三色标记法是一种用于垃圾回收的标记算法，通过将对象分为三种颜色（白色、灰色和黑色）来管理垃圾收集过程。它在并发垃圾收集器中尤其有用，因为它能够有效处理对象引用的变化。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>并发性</strong>：</p>
<p><strong>减少停顿时间</strong>：三色标记法允许垃圾收集器在应用线程运行的同时进行标记，这大大减少了应用程序的停顿时间，提高了应用的响应性。</p>
<p><strong>并发标记</strong>：通过颜色标记和写屏障技术，三色标记法能够在并发环境下准确标记存活对象，避免遗漏或错误标记。</p>
<p><strong>精确性</strong>：</p>
<p><strong>准确标记存活对象</strong>：三色标记法通过颜色状态和处理队列，确保所有存活对象都能被正确标记，从而避免存活对象被错误回收。</p>
<p><strong>处理对象引用变化</strong>：在并发标记阶段，三色标记法能够处理对象引用的变化，确保引用变化不会导致存活对象被错误回收。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>复杂性</strong>：</p>
<p><strong>实现复杂</strong>：三色标记法的实现相对复杂，尤其是在维护颜色不变性和处理并发标记时，需要额外的机制（如写屏障）来确保正确性。</p>
<p><strong>写屏障开销</strong>：维护颜色不变性需要使用写屏障技术，这会增加一定的运行时开销，可能对性能产生影响。</p>
<p><strong>内存开销</strong>：</p>
<p><strong>颜色状态维护</strong>：三色标记法需要为每个对象维护颜色状态，这会增加一定的内存开销。</p>
<p><strong>处理队列</strong>：需要额外的内存来维护灰色对象的处理队列。</p>
<p><strong>复杂的边界条件</strong>：</p>
<p><strong>颜色不变性维护</strong>：在并发环境下，维护颜色不变性（如强三色不变性或弱三色不变性）可能会遇到复杂的边界条件，需要仔细处理以确保算法的正确性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/04/29/JVM/jvm%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/29/JVM/jvm%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9F/" itemprop="url">jvm 的四种引用区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-04-29T13:33:41+00:00">
                2025-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-04-30T03:28:19+00:00">
                2025-04-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌jvm-的四种引用区别？"><a href="#👌jvm-的四种引用区别？" class="headerlink" title="👌jvm 的四种引用区别？"></a>👌jvm 的四种引用区别？</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在 Java 中，引用类型的不同决定了垃圾收集器如何处理对象的生命周期。Java 提供了四种引用类型：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这些引用类型在java.lang.ref包中定义，它们的区别如下：</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是 Java 中最常见的引用类型。通过new关键字创建的对象引用就是强引用。只要强引用存在，垃圾收集器永远不会回收被引用的对象。强引用是默认的引用类型，通常使用最广泛。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str=new String(&quot;Hello, World!&quot;);</span><br></pre></td></tr></table></figure>

<p>str是一个强引用，只要str不被置为null或超出作用域，对象”Hello, World!”就不会被垃圾收集器回收。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是一种相对较强但仍允许垃圾收集器回收的引用类型，适用于实现内存敏感的缓存。只有在内存不足的情况下，垃圾收集器才会回收被软引用关联的对象。软引用通常用于实现缓存，当内存充足时对象不会被回收，当内存不足时对象会被回收以释放内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line">String str = new String(&quot;Hello, World!&quot;);</span><br><span class="line">SoftReference&lt;String&gt; softRef = new SoftReference&lt;&gt;(str);</span><br><span class="line">str = null; // 允许 str 对象被垃圾收集器回收</span><br></pre></td></tr></table></figure>

<p>softRef是一个软引用，当内存不足时，对象”Hello, World!”可能会被回收。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用是一种比软引用更弱的引用类型，适用于实现非强制性缓存。只要垃圾收集器运行，不管内存是否充足，都会回收被弱引用关联的对象。弱引用通常用于实现规范化映射（canonical mappings），例如WeakHashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line">String str = new String(&quot;Hello, World!&quot;);</span><br><span class="line">WeakReference&lt;String&gt; weakRef = new WeakReference&lt;&gt;(str);</span><br><span class="line">str = null; // 允许 str 对象被垃圾收集器回收</span><br></pre></td></tr></table></figure>

<p>weakRef是一个弱引用，垃圾收集器在下一次运行时可能会回收对象”Hello, World!”。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用是一种最弱的引用类型，它仅用于跟踪对象被垃圾收集器回收的时间。虚引用本身不会决定对象的生命周期，垃圾收集器回收对象时会将虚引用放入引用队列中。虚引用通常用于实现一些特殊的清理机制，例如管理直接内存（Direct Memory）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.PhantomReference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line">String str = new String(&quot;Hello, World!&quot;);</span><br><span class="line">ReferenceQueue&lt;String&gt; refQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; phantomRef = new PhantomReference&lt;&gt;(str, refQueue);</span><br><span class="line">str = null; // 允许 str 对象被垃圾收集器回收</span><br><span class="line"></span><br><span class="line">// 当垃圾收集器回收 str 对象时，phantomRef 会被放入 refQueue</span><br></pre></td></tr></table></figure>

<p>phantomRef是一个虚引用，当垃圾收集器回收对象”Hello, World!”时，phantomRef会被放入refQueue中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">194</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
