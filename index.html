<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="余声-个人博客">
<meta property="og:url" content="https://xiaoyaofeihu.github.io/index.html">
<meta property="og:site_name" content="余声-个人博客">
<meta property="og:locale">
<meta property="article:author" content="javayun">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '余声'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiaoyaofeihu.github.io/"/>





  <title>余声-个人博客</title>
  














<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">余声-个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  
    
  

  <article class="post post-type-normal post-sticky" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/11/15/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="置顶">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                <a class="post-title-link" href="/2024/11/15/%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" itemprop="url">学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-11-15T13:33:41+00:00">
                2024-11-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="springcloud服务中使用mq做消息的通知，相对于fegin有什么好处"><a href="#springcloud服务中使用mq做消息的通知，相对于fegin有什么好处" class="headerlink" title="springcloud服务中使用mq做消息的通知，相对于fegin有什么好处"></a>springcloud服务中使用mq做消息的通知，相对于fegin有什么好处</h1><h2 id="在-Spring-Cloud-服务中使用-消息队列（如-RabbitMQ、Kafka-等）来处理消息通知，相对于-Feign-进行同步调用，具有多个优势，特别是在分布式系统中。这些好处主要体现在-解耦性、可靠性、性能和可扩展性-等方面。下面详细列出它们的优缺点对比："><a href="#在-Spring-Cloud-服务中使用-消息队列（如-RabbitMQ、Kafka-等）来处理消息通知，相对于-Feign-进行同步调用，具有多个优势，特别是在分布式系统中。这些好处主要体现在-解耦性、可靠性、性能和可扩展性-等方面。下面详细列出它们的优缺点对比：" class="headerlink" title="在 Spring Cloud 服务中使用 消息队列（如 RabbitMQ、Kafka 等）来处理消息通知，相对于 Feign 进行同步调用，具有多个优势，特别是在分布式系统中。这些好处主要体现在 解耦性、可靠性、性能和可扩展性 等方面。下面详细列出它们的优缺点对比："></a>在 Spring Cloud 服务中使用 消息队列（如 RabbitMQ、Kafka 等）来处理消息通知，相对于 Feign 进行同步调用，具有多个优势，特别是在分布式系统中。这些好处主要体现在 解耦性、可靠性、性能和可扩展性 等方面。下面详细列出它们的优缺点对比：</h2><h2 id="1-解耦性"><a href="#1-解耦性" class="headerlink" title="1. 解耦性"></a>1. 解耦性</h2><ul>
<li>消息队列：使用消息队列时，生产者（发送方）和消费者（接收方）是松耦合的，即使消费者不可用，消息队列仍然可以存储消息，等待消费者处理。这种异步的方式减少了服务之间的直接依赖，增强了系统的解耦性。</li>
<li>Feign：Feign 是一种同步调用方式，服务 A 直接调用服务 B，服务之间是强耦合的。如果服务 B 不可用，服务 A 会失败，依赖关系比较紧密。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>消息队列：更容易扩展服务，减少服务间的直接依赖。</li>
<li>Feign：服务间的直接调用，导致服务耦合性较强，依赖性高。</li>
</ul>
<h2 id="2-可靠性"><a href="#2-可靠性" class="headerlink" title="2. 可靠性"></a>2. 可靠性</h2><ul>
<li>消息队列：消息队列一般会提供消息持久化、重试机制、死信队列等功能，保证消息在系统出现故障时不会丢失，能够在消费者恢复后重新处理。即使服务 A 出现故障，消息依然可以在队列中等待消费。</li>
<li>Feign：Feign 调用是同步的，如果服务 B 出现故障，Feign 请求会直接失败，且一般不具备自动重试和消息持久化功能。</li>
</ul>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>消息队列：提供消息持久化、重试机制，能确保消息不丢失。</li>
<li>Feign：服务失败时请求会直接失败，除非使用像 Ribbon 或 Hystrix 这样的断路器进行处理。</li>
</ul>
<h2 id="3-异步与性能"><a href="#3-异步与性能" class="headerlink" title="3. 异步与性能"></a>3. 异步与性能</h2><ul>
<li>消息队列：消息队列是异步处理的，即生产者发送完消息后，不需要等待消费者处理结果。生产者可以继续执行其他任务，消息队列通过缓冲提高系统吞吐量。当系统负载较高时，消费者可以批量消费消息，提高处理效率。</li>
<li>Feign：Feign 是同步的，发送请求后，调用方必须等待服务返回结果，可能会导致性能瓶颈，特别是当多个服务调用彼此依赖时，响应时间可能会增加。</li>
</ul>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>消息队列：通过异步处理提高系统吞吐量和性能，适合处理高并发、高负载的场景。</li>
<li>Feign：同步请求，可能会成为性能瓶颈，尤其在服务间相互调用较多时。</li>
</ul>
<h2 id="4-可伸缩性"><a href="#4-可伸缩性" class="headerlink" title="4. 可伸缩性"></a>4. 可伸缩性</h2><ul>
<li>消息队列：消息队列可以在消费者端进行水平扩展。例如，消费者可以横向扩展多个实例来处理消息，从而提升系统的处理能力。消息队列会自动将消息分发给空闲的消费者实例，提高系统的可伸缩性。</li>
<li>Feign：Feign 本身并不具备内建的负载均衡功能，虽然可以使用 Spring Cloud 的负载均衡组件（如 Ribbon），但它依赖于同步请求，因此在高并发场景下扩展性较差。</li>
</ul>
<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>消息队列：通过消费端的水平扩展，提高系统的可伸缩性。</li>
<li>Feign：虽然有负载均衡，但扩展性主要依赖于同步调用方式，可能会受到性能瓶颈的限制。</li>
</ul>
<h2 id="5-流量控制与限流"><a href="#5-流量控制与限流" class="headerlink" title="5. 流量控制与限流"></a>5. 流量控制与限流</h2><ul>
<li>消息队列：消息队列通常支持流量控制。比如，消费者的处理速度低于生产者的发送速度时，消息队列可以进行流量调节，避免系统被大量消息打垮。此外，死信队列、延时队列等功能可以帮助处理异常消息，避免堆积。</li>
<li>Feign：Feign 是同步请求，不适合处理流量控制。如果请求量激增，可能会导致服务出现超时或者崩溃。</li>
</ul>
<h3 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>消息队列：可以通过流量控制机制、死信队列、延时队列等功能保证系统稳定性。</li>
<li>Feign：不适合直接进行流量控制，可能导致系统超载。</li>
</ul>
<h2 id="6-消息顺序"><a href="#6-消息顺序" class="headerlink" title="6. 消息顺序"></a>6. 消息顺序</h2><ul>
<li>消息队列：许多消息队列系统（如 Kafka 和 RabbitMQ）都支持消息的顺序保证，尤其在处理同一个主题或队列中的消息时，可以确保消息按顺序被消费。对于需要保证顺序消费的场景，消息队列是非常适合的。</li>
<li>Feign：Feign 的调用是同步的，但它不保证请求的顺序和消费顺序。多个服务之间的调用是按顺序发生的，但并不适用于保证消息顺序。</li>
</ul>
<h3 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>消息队列：可以确保消息顺序性，适合需要严格顺序的场景。</li>
<li>Feign：没有内建的顺序保证机制。</li>
</ul>
<h2 id="7-场景适配"><a href="#7-场景适配" class="headerlink" title="7. 场景适配"></a>7. 场景适配</h2><ul>
<li>消息队列：适用于以下场景：</li>
</ul>
<blockquote>
<p>事件驱动的应用，异步通知、推送；<br>高并发、高吞吐量的系统；<br>系统解耦，避免微服务之间的直接调用；<br>消息延迟处理或异步处理的场景。</p>
</blockquote>
<ul>
<li>Feign：适用于以下场景：</li>
</ul>
<blockquote>
<p>服务间的同步调用，需要立即得到返回值；<br>处理简单的请求-响应模式；<br>服务间的低延迟、低耦合调用。</p>
</blockquote>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><table>
<thead>
<tr>
<th>特性</th>
<th><strong>消息队列</strong></th>
<th><strong>Feign</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>耦合性</strong></td>
<td>松耦合，生产者和消费者分离</td>
<td>强耦合，服务间直接调用</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>提供消息持久化、重试机制</td>
<td>依赖于服务的可用性，失败时没有自动恢复</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>异步，适合高并发、高吞吐量的场景</td>
<td>同步，可能成为性能瓶颈</td>
</tr>
<tr>
<td><strong>可伸缩性</strong></td>
<td>通过水平扩展消费者来提高可伸缩性</td>
<td>依赖于负载均衡，扩展有限</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>可以控制流量，避免系统过载</td>
<td>没有流量控制机制</td>
</tr>
<tr>
<td><strong>消息顺序</strong></td>
<td>可以保证消息顺序</td>
<td>不保证消息顺序</td>
</tr>
<tr>
<td><strong>场景适配</strong></td>
<td>事件驱动、异步通知、大量消息处理</td>
<td>服务间同步调用、低延迟处理</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="使用-消息队列（如-RabbitMQ、Kafka）更适合于-高并发、异步、解耦、事件驱动-的场景，能够提高系统的可靠性、性能和扩展性。"><a href="#使用-消息队列（如-RabbitMQ、Kafka）更适合于-高并发、异步、解耦、事件驱动-的场景，能够提高系统的可靠性、性能和扩展性。" class="headerlink" title="使用 消息队列（如 RabbitMQ、Kafka）更适合于 高并发、异步、解耦、事件驱动 的场景，能够提高系统的可靠性、性能和扩展性。"></a>使用 消息队列（如 RabbitMQ、Kafka）更适合于 高并发、异步、解耦、事件驱动 的场景，能够提高系统的可靠性、性能和扩展性。</h3><h3 id="使用-Feign-更适合-同步调用、简单的请求-响应模式、低延迟-的服务间通信。"><a href="#使用-Feign-更适合-同步调用、简单的请求-响应模式、低延迟-的服务间通信。" class="headerlink" title="使用 Feign 更适合 同步调用、简单的请求-响应模式、低延迟 的服务间通信。"></a>使用 Feign 更适合 同步调用、简单的请求-响应模式、低延迟 的服务间通信。</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  <article class="post post-type-normal post-sticky" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="置顶">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                <a class="post-title-link" href="/2025/05/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98/" itemprop="url">线程池问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-10T13:33:41+00:00">
                2025-05-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、线程池拒绝策略选择指南"><a href="#一、线程池拒绝策略选择指南" class="headerlink" title="一、线程池拒绝策略选择指南"></a>一、线程池拒绝策略选择指南</h1><p>在实际开发中，线程池拒绝策略的选择需要根据具体的业务场景和系统需求来决定。Java线程池提供了四种内置拒绝策略，每种策略适用于不同的情况。</p>
<p>一、四种内置拒绝策略</p>
<ol>
<li>AbortPolicy（默认策略）<br>行为：直接抛出RejectedExecutionException异常</li>
</ol>
<p>适用场景：</p>
<p>需要明确知道任务被拒绝的情况</p>
<p>关键业务系统，不能容忍任务静默丢失</p>
<p>开发测试环境（便于发现问题）</p>
<p>示例：</p>
<p>java<br>ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(<br>    2, 4, 60, TimeUnit.SECONDS,<br>    new ArrayBlockingQueue&lt;&gt;(2),<br>    new ThreadPoolExecutor.AbortPolicy()  &#x2F;&#x2F; 显式指定<br>);<br>2. CallerRunsPolicy<br>行为：将任务回退给调用者线程执行</p>
<p>适用场景：</p>
<p>适合能承受一定延迟的业务</p>
<p>需要保证每个任务都能被执行</p>
<p>不希望任务丢失但可以接受降级</p>
<p>特点：</p>
<p>会降低新任务提交速度，起到负反馈调节作用</p>
<p>调用者线程可能被阻塞</p>
<ol start="3">
<li>DiscardPolicy<br>行为：静默丢弃被拒绝的任务，不做任何处理</li>
</ol>
<p>适用场景：</p>
<p>非核心业务</p>
<p>允许丢失部分任务的场景</p>
<p>监控日志不重要的任务</p>
<p>风险：</p>
<p>任务丢失无感知，可能造成数据不一致</p>
<ol start="4">
<li>DiscardOldestPolicy<br>行为：丢弃队列中最老的任务，然后尝试重新提交当前任务</li>
</ol>
<p>适用场景：</p>
<p>允许丢弃旧任务的新业务场景</p>
<p>实时性要求高的任务优先处理</p>
<p>任务本身具有时效性（旧任务价值低）</p>
<p>注意事项：</p>
<p>可能丢失重要但处理慢的任务</p>
<p>不适合任务之间有依赖关系的场景</p>
<p>二、选择策略的决策流程</p>
<ul>
<li>是否绝对不能丢失任务<ul>
<li>是：使用CallerRunsPolicy</li>
<li>否：是否需要立即知道被拒绝<ul>
<li>是：使用AbortPolicy</li>
<li>否：新任务比旧任务更重要<ul>
<li>是：使用DiscardOldestPolicy</li>
<li>否：使用DiscardPolicy</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>三、实际业务场景推荐</p>
<ol>
<li><p>支付&#x2F;交易核心系统<br>推荐策略：CallerRunsPolicy<br>理由：保证每个支付请求都能被处理，宁可降级也不丢失</p>
</li>
<li><p>日志记录&#x2F;数据收集<br>推荐策略：DiscardPolicy<br>理由：日志可容忍部分丢失，避免影响主业务流程</p>
</li>
<li><p>实时数据处理<br>推荐策略：DiscardOldestPolicy<br>理由：新数据比旧数据更有价值</p>
</li>
<li><p>管理系统后台任务<br>推荐策略：AbortPolicy<br>理由：需要及时发现系统过载情况</p>
</li>
</ol>
<p>四、自定义拒绝策略<br>当内置策略不满足需求时，可以实现RejectedExecutionHandler接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectionPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 记录日志</span></span><br><span class="line">        log.warn(<span class="string">&quot;Task rejected: &#123;&#125;&quot;</span>, r.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 持久化任务到数据库/文件</span></span><br><span class="line">        persistTask(r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 尝试重新提交</span></span><br><span class="line">        <span class="keyword">if</span> (!executor.isShutdown()) &#123;</span><br><span class="line">            executor.submit(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">CustomRejectionPolicy</span>());</span><br></pre></td></tr></table></figure>

<p>五、配置建议<br>监控报警：无论选择哪种策略，都应监控拒绝情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过ThreadPoolExecutor的getRejectedExecutionCount()获取拒绝数</span></span><br></pre></td></tr></table></figure>

<p>参数调优：合理设置队列容量和线程数比选择拒绝策略更重要</p>
<p>组合使用：不同业务使用不同线程池，配置不同策略</p>
<p>文档记录：在代码中明确注释选择该策略的原因</p>
<p>六、最佳实践总结<br>关键业务：优先保证任务执行（CallerRunsPolicy）</p>
<p>可丢弃任务：选择静默丢弃（DiscardPolicy）</p>
<p>需要感知：抛出异常（AbortPolicy）</p>
<p>时效敏感：丢弃旧任务（DiscardOldestPolicy）</p>
<p>特殊需求：自定义策略（如持久化后重试）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  
    
  

  <article class="post post-type-normal post-sticky" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2024/10/10/%E5%9F%BA%E7%A1%80/ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                  <span class="post-sticky-flag" title="置顶">
                    <i class="fa fa-thumb-tack"></i>
                  </span>
                
                <a class="post-title-link" href="/2024/10/10/%E5%9F%BA%E7%A1%80/ThreadLocal/" itemprop="url">ThreadLocal的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-10-10T17:33:00+00:00">
                2024-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。"><a href="#ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。" class="headerlink" title="ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。"></a>ThreadLocal是Java中用于解决多线程环境下数据隔离问题的一个类。它提供了一种方式，使得每个线程都可以拥有其独立的变量副本，这样每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。这种机制在多线程编程中非常有用，特别是当需要在多个线程之间共享某些数据，但又不希望这些数据因为并发访问而引发问题时。</h2><h3 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h3><p>ThreadLocal的实现主要依赖于一个内部类ThreadLocalMap。这个Map以ThreadLocal对象为键，以线程独有的变量为值。每个线程都维护着一个ThreadLocalMap的引用，这样线程就可以通过ThreadLocal对象作为键，在其自己的ThreadLocalMap中查找或设置值。</p>
<ol>
<li><p><strong>ThreadLocalMap的结构</strong>：</p>
<ul>
<li>ThreadLocalMap是一个哈希表，它的键（Key）是ThreadLocal对象本身的一个弱引用（WeakReference），而值（Value）则是线程独有的变量。</li>
<li>使用弱引用作为键的好处是，当ThreadLocal对象被垃圾回收时，不会因为ThreadLocalMap中的引用而阻止其被回收。但这也带来了一个问题，即如果ThreadLocal对象被回收了，而ThreadLocalMap中的Entry还存在（且Value还未被回收），那么就会出现键为null的情况，这需要在ThreadLocalMap的操作中特别处理。</li>
</ul>
</li>
<li><p><strong>ThreadLocal的方法</strong>：</p>
<ul>
<li><code>initialValue()</code>：返回此线程局部变量的初始值。</li>
<li><code>get()</code>：返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则通过调用<code>initialValue()</code>方法创建并初始化此副本。</li>
<li><code>set(T value)</code>：将此线程局部变量的当前线程副本中的值设置为指定值。</li>
<li><code>remove()</code>：移除此线程局部变量的值。这是一个清理操作，有助于避免内存泄漏，特别是在使用线程池时。</li>
</ul>
</li>
<li><p><strong>ThreadLocalMap的扩容和清理</strong>：</p>
<ul>
<li>ThreadLocalMap的扩容机制与HashMap类似，当元素数量超过阈值时，会进行扩容。</li>
<li>由于ThreadLocalMap的键是弱引用，当没有强引用指向ThreadLocal对象时，ThreadLocal对象可以被垃圾回收。但是，如果ThreadLocal对象被回收了，而对应的Value对象还有强引用存在（即还没有被线程显式地调用<code>remove()</code>方法移除），那么这些Value对象就变成了“孤儿对象”，可能会导致内存泄漏。因此，在使用ThreadLocal时，建议显式地调用<code>remove()</code>方法来清理不再需要的线程局部变量。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>ThreadLocal的典型使用场景包括：</p>
<ul>
<li>在多线程环境中，每个线程需要维护一个独立的、不与其他线程共享的状态或数据。</li>
<li>在处理用户请求时，将用户相关的信息（如用户ID、会话信息等）保存在ThreadLocal中，以便在同一个请求处理流程中方便地访问这些信息，而不需要通过参数传递。</li>
</ul>
<h3 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h3><ul>
<li><strong>内存泄漏</strong>：指的是程序中分配的内存在不再需要时没有被正确释放或回收的情况。随着时间的推移，可用内存逐渐减少，最终可能导致程序性能下降或崩溃。</li>
<li><strong>内存溢出</strong>（OOM, Out of Memory）：当程序运行时，如果请求的内存超出了可用内存的限制，就会抛出内存溢出异常。内存泄漏如果不及时解决，最终可能导致内存溢出。</li>
</ul>
<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p>ThreadLocal是一个用于创建线程本地变量的类。每个线程都拥有自己独立的、初始化为null的变量副本，这些变量对其他线程是不可见的。然而，ThreadLocal的内存泄漏问题是一个比较典型的问题。</p>
<h4 id="ThreadLocal内存泄漏的来源"><a href="#ThreadLocal内存泄漏的来源" class="headerlink" title="ThreadLocal内存泄漏的来源"></a>ThreadLocal内存泄漏的来源</h4><ol>
<li><p><strong>ThreadLocal对象在堆上存储的ThreadLocalMap</strong>：</p>
<ul>
<li>ThreadLocalMap是ThreadLocal的内部类，用于存储线程局部变量。</li>
<li>ThreadLocalMap的key是ThreadLocal对象，value是线程变量的值。</li>
</ul>
</li>
<li><p><strong>ThreadLocal的引用链</strong>：</p>
<ul>
<li>ThreadLocal对象有两个引用源：一个是栈上的ThreadLocal引用（方法内创建），一个是ThreadLocalMap中的key对它的引用。</li>
<li>如果栈上的ThreadLocal引用不再使用（方法结束），但ThreadLocal对象因为还有ThreadLocalMap中的key引用而无法被回收，就会导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>线程对象被重复使用</strong>：</p>
<ul>
<li>在线程池场景中，线程对象会被重复使用。如果线程中的ThreadLocalMap没有及时清理，就会导致内存泄漏。</li>
</ul>
</li>
</ol>
<h4 id="弱引用解决部分内存泄漏问题"><a href="#弱引用解决部分内存泄漏问题" class="headerlink" title="弱引用解决部分内存泄漏问题"></a>弱引用解决部分内存泄漏问题</h4><p>为了解决ThreadLocal对象因为ThreadLocalMap中的key引用而无法被回收的问题，ThreadLocalMap使用了弱引用。</p>
<ul>
<li><strong>弱引用</strong>：如果一个对象只具有弱引用，那么这个对象就会在下次垃圾回收时被回收。</li>
<li>在ThreadLocalMap中，key（ThreadLocal对象）是弱引用。这意味着，当栈上的ThreadLocal引用不再使用时，ThreadLocal对象可以被垃圾回收器回收，从而避免了因为ThreadLocal对象无法被回收而导致的内存泄漏。</li>
</ul>
<p>然而，即使使用了弱引用，ThreadLocal的内存泄漏问题并没有完全解决。因为value（线程变量的值）还是强引用，如果线程对象被重复使用（如在线程池中），并且ThreadLocalMap没有及时清理，那么value所占用的内存仍然无法被回收。因此，开发者还需要在使用完ThreadLocal后，显式地调用<code>remove()</code>方法来清理ThreadLocalMap中的entry，以避免内存泄漏。</p>
<p>综上所述，ThreadLocal的内存泄漏问题是一个复杂的问题，需要开发者和JDK共同解决。JDK通过使用弱引用来解决了一部分问题，但开发者还需要在使用完ThreadLocal后显式地调用<code>remove()</code>方法来避免内存泄漏。<br>总之，ThreadLocal是一个强大的工具，它可以帮助我们在多线程环境中实现数据的隔离和线程安全。但是，使用时也需要注意其潜在的内存泄漏问题，特别是在使用线程池时。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/16/Error/easyexcel%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/16/Error/easyexcel%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99/" itemprop="url">报错</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-16T13:33:41+00:00">
                2025-05-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/error/" itemprop="url" rel="index">
                    <span itemprop="name">error</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="easyexcel-导入使用shiro报错"><a href="#easyexcel-导入使用shiro报错" class="headerlink" title="easyexcel 导入使用shiro报错"></a>easyexcel 导入使用shiro报错</h1><h2 id="一、背景描述"><a href="#一、背景描述" class="headerlink" title="一、背景描述"></a>一、背景描述</h2><p>SpringBoot项目，使用Shiro进行权限管理。测试过程中发现执行文件导入时最开始一切正常，但是导入几次之后再次执行导入就会报错，此时执行其他功能一切正常</p>
<h2 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h2><ul>
<li>在使用 EasyExcel 进行多线程导入数据时，可能会遇到 org.apache.shiro.session.UnknownSessionException 异常。这个异常通常与 Apache Shiro 的会话管理有关，尤其是在多线程环境下，如果多个线程尝试访问或操作同一个会话，而没有正确处理线程间的同步，就可能抛出此类异常。</li>
</ul>
<h2 id="三、原因分析"><a href="#三、原因分析" class="headerlink" title="三、原因分析"></a>三、原因分析</h2><p>1、会话管理不正确：在多线程环境中，如果多个线程尝试访问或修改同一个用户的会话（Session），而没有适当的管理和同步，就可能导致 UnknownSessionException。</p>
<p>2、会话过期或失效：在多线程环境下，如果会话在某个线程中被修改或过期，而其他线程还在尝试访问该会话，也可能会引发此异常。</p>
<h2 id="四、问题分析"><a href="#四、问题分析" class="headerlink" title="四、问题分析"></a>四、问题分析</h2><ul>
<li>排查导入代码发现，只有在执行保存语句的时候获取当前用户使用了Shiro相关代码，因此怀疑此处出现问题。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.operator = (String) SecurityUtils.getSubject().getPrincipal();</span><br></pre></td></tr></table></figure></li>
<li>在此处断点发现，手动新增数据和批量导入数据都执行该语句，但两次获取的Subject不一致。因此阅读源码进行排查。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从SecurityUtils中获取Subject源码如下</span></span><br><span class="line"><span class="comment">// package: org.apache.shiro.SecurityUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> ThreadContext.getSubject(); <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">null</span>) &#123;</span><br><span class="line">        subject = (<span class="keyword">new</span> <span class="title class_">Subject</span>.Builder()).buildSubject();</span><br><span class="line">        ThreadContext.bind(subject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟进上面①中的方法</span></span><br><span class="line"><span class="comment">// package: org.apache.shiro.util.ThreadContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Subject <span class="title function_">getSubject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Subject) get(SUBJECT_KEY); <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟进上面②中的方法</span></span><br><span class="line"><span class="comment">// package: org.apache.shiro.util.ThreadContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;get() - in thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        log.trace(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue(key); <span class="comment">// ③</span></span><br><span class="line">    <span class="keyword">if</span> ((value != <span class="literal">null</span>) &amp;&amp; log.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Retrieved value of type [&quot;</span> + value.getClass().getName() + <span class="string">&quot;] for key [&quot;</span> +</span><br><span class="line">                key + <span class="string">&quot;] &quot;</span> + <span class="string">&quot;bound to thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        log.trace(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟进上面③中的方法</span></span><br><span class="line"><span class="comment">// package: org.apache.shiro.util.ThreadContext</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">getValue</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Map&lt;Object, Object&gt; perThreadResources = resources.get(); <span class="comment">// ④</span></span><br><span class="line">    <span class="keyword">return</span> perThreadResources != <span class="literal">null</span> ? perThreadResources.get(key) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面④中的resources在ThreadContext中定义如下</span></span><br><span class="line"><span class="comment">// package: org.apache.shiro.util.ThreadContext</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocalMap</span>&lt;Map&lt;Object, Object&gt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>根据上面对源码的跟踪，发现Subject是与ThreadLocal也就是线程绑定的。获取Subject时先获取当前线程绑定的Subject，若没有则重新创建并绑定到当前线程。而我导入的时候为了提高导入效率，使用了多线程。到此就发现问题的原因了</p>
<h2 id="五、问题分析"><a href="#五、问题分析" class="headerlink" title="五、问题分析"></a>五、问题分析</h2><ul>
<li>假设项目中线程池设置核心线程数量为10，而核心线程默认是不会被超时回收的<ul>
<li>可通过threadPoolExecutor.allowCoreThreadTimeOut(true);设置核心线程超时回收</li>
</ul>
</li>
</ul>
<p>1、当用户A登录后，执行导入操作，从线程池中拿出5个线程，此时这5个线程将绑定用户A的Subject<br>2、当用户A多次执行导入操作后，线程池全部核心线程与用户A的Subject绑定。用户A退出登录后，线程池并不会将核心线程进行销毁。<br>后续用户B登录，再次执行导入操作，此时线程池分配线程进行操作，但此时所有的线程都已与用户A绑定，因此获取到的Subject都是用户A的Subject，从Subject中获取session时此session已被销毁，因此报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据sessionId获取session，获取为空则报错</span></span><br><span class="line"><span class="comment">// package: org.apache.shiro.session.mgt.eis.AbstractSessionDAO</span></span><br><span class="line"><span class="keyword">public</span> Session <span class="title function_">readSession</span><span class="params">(Serializable sessionId)</span> <span class="keyword">throws</span> UnknownSessionException &#123;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> doReadSession(sessionId);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownSessionException</span>(<span class="string">&quot;There is no session with id [&quot;</span> + sessionId + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、建议"><a href="#六、建议" class="headerlink" title="六、建议"></a>六、建议</h2><p>多线程时不要使用Shiro相关代码。将用户名作为参数传入，不再单独获取。</p>
<h2 id="七、参考文档"><a href="#七、参考文档" class="headerlink" title="七、参考文档"></a>七、参考文档</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bbc2005/articles/15340412.html">https://www.cnblogs.com/bbc2005/articles/15340412.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/12/redis/redissentinal%E4%B8%8Erediscluster%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/12/redis/redissentinal%E4%B8%8Erediscluster%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/" itemprop="url">👌redis sentinal与redis cluster的区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-12T13:33:41+00:00">
                2025-05-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis-sentinal与redis-cluster的区别？"><a href="#👌redis-sentinal与redis-cluster的区别？" class="headerlink" title="👌redis sentinal与redis cluster的区别？"></a>👌redis sentinal与redis cluster的区别？</h1><h1 id="口语化答案"><a href="#口语化答案" class="headerlink" title="口语化答案"></a>口语化答案</h1><p>哨兵和集群是两种非常不同的模式。一个重点关注高可用，一个关注水平扩展和数据分片。哨兵主要解决主服务器故障的自动切换问题。集群则是为了存储大量数据，将数据分布到多个节点。在存储上，哨兵不进行数据分片，集群则通过哈希槽的方式存储数据，集群的可用和切换采用了Gossip 协议，哨兵模式则依靠哨兵的检测。所以哨兵适合小规模的高可用，集群适合大规模的数据存储。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>这道题还是挺重要的，经常有人会将两种模式弄混。二者模式区别非常大，要重点关注。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>高可用，水平扩展，数据分片，哈希槽</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>先来了解概念：</p>
<p>redis sentinal 哨兵模式</p>
<p>redis cluster 集群模式</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Sentinel是一种用于监控Redis主从复制结构并实现自动故障转移的系统。它主要关注的是高可用性，保证当主服务器发生故障时，能够自动将一个从服务器提升为新的主服务器，并通知客户端进行相应的切换。</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>Cluster是一种分布式存储解决方案，支持自动分片和高可用性。支持主从复制和故障转移，还能够将数据分布在多个节点上，实现数据的水平扩展。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table>
<thead>
<tr>
<th></th>
<th>哨兵模式</th>
<th>集群模式</th>
</tr>
</thead>
<tbody><tr>
<td>架构区别</td>
<td>Sentinel节点监控主从服务器的状态，当主服务器故障时，Sentinel节点会选举一个新的主服务器。</td>
<td>数据自动分片存储在多个节点上，每个节点负责一部分数据。每个分片有一个主节点和一个或多个从节点。使用Gossip协议进行节点间通信，自动检测故障并进行主从切换。</td>
</tr>
<tr>
<td>数据存储</td>
<td>数据存储在一个主服务器及其从服务器上，不进行数据分片。</td>
<td>数据通过哈希槽（hash slots）机制分布在多个节点上，每个节点负责一部分哈希槽。</td>
</tr>
<tr>
<td>扩展性</td>
<td>只提供高可用性，不能水平扩展数据存储容量。</td>
<td>支持水平扩展，可以通过增加节点来扩展数据存储容量和处理能力。</td>
</tr>
<tr>
<td>高可用</td>
<td>通过心跳机制检测主服务器的状态，自动选举新的主服务器并更新拓扑结构。</td>
<td>使用Gossip协议进行节点间的故障检测，自动进行主从切换，确保集群的高可用性。</td>
</tr>
<tr>
<td>使用场景</td>
<td>适用于小规模的Redis部署，主要关注高可用性。不需要数据分片。</td>
<td>适用于大规模的Redis部署，支持水平扩展。需要同时满足高可用性和数据分片、扩展性需求。</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/11/redis/rediskey%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/11/redis/rediskey%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE_/" itemprop="url">👌redis key的过期时间和永久有效分别怎么设置?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-11T13:33:41+00:00">
                2025-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis-key的过期时间和永久有效分别怎么设置"><a href="#👌redis-key的过期时间和永久有效分别怎么设置" class="headerlink" title="👌redis key的过期时间和永久有效分别怎么设置?"></a>👌redis key的过期时间和永久有效分别怎么设置?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>在Redis中，你可以使用多种命令来设置键的过期时间或将键设置为永久有效。</p>
<h3 id="设置键的过期时间"><a href="#设置键的过期时间" class="headerlink" title="设置键的过期时间"></a>设置键的过期时间</h3><ol>
<li><strong>使用<strong><strong>EXPIRE</strong></strong>命令，</strong>EXPIRE命令用于设置键的过期时间，以秒为单位。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key seconds</span><br><span class="line">例如：</span><br><span class="line">EXPIRE mykey 60  # 设置 mykey 的过期时间为60秒</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用<strong><strong>PEXPIRE</strong></strong>命令，</strong>PEXPIRE命令用于设置键的过期时间，以毫秒为单位。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PEXPIRE key milliseconds</span><br><span class="line">例如：</span><br><span class="line">PEXPIRE mykey 60000  # 设置 mykey 的过期时间为60000毫秒（即60秒）</span><br></pre></td></tr></table></figure>

<p>以上的两个区别就是秒级和毫秒级的区别。</p>
<ol start="3">
<li><strong>使用<strong><strong>EXPIREAT</strong></strong>命令，</strong>EXPIREAT命令用于设置键的过期时间为指定的 Unix 时间戳，以秒为单位。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPIREAT key timestamp</span><br><span class="line">例如：</span><br><span class="line">EXPIREAT mykey 1672531199  # 设置 mykey 的过期时间为指定的 Unix 时间戳</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>使用<strong><strong>PEXPIREAT</strong></strong>命令，</strong>PEXPIREAT命令用于设置键的过期时间为指定的 Unix 时间戳，以毫秒为单位。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PEXPIREAT key milliseconds-timestamp</span><br><span class="line">例如：</span><br><span class="line">PEXPIREAT mykey 1672531199000  # 设置 mykey 的过期时间为指定的 Unix 时间戳（毫秒）</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用<strong><strong>SET</strong></strong>命令带选项，</strong>SET命令可以在设置键值的同时指定过期时间。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET key value EX seconds</span><br><span class="line">SET key value PX milliseconds</span><br><span class="line">例如：</span><br><span class="line">SET mykey &quot;value&quot; EX 60  # 设置 mykey 的值为 &quot;value&quot; 并使其在60秒后过期</span><br><span class="line">SET mykey &quot;value&quot; PX 60000  # 设置 mykey 的值为 &quot;value&quot; 并使其在60000毫秒（即60秒）后过期</span><br></pre></td></tr></table></figure>



<h3 id="设置键为永久有效"><a href="#设置键为永久有效" class="headerlink" title="设置键为永久有效"></a>设置键为永久有效</h3><ol>
<li><strong>使用<strong><strong>PERSIST</strong></strong>命令，</strong>PERSIST命令用于移除键的过期时间，使其变为永久有效。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PERSIST key</span><br><span class="line">例如：</span><br><span class="line">PERSIST mykey  # 移除 mykey 的过期时间，使其变为永久有效</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/11/redis/redis%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/11/redis/redis%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/" itemprop="url">👌redis中的管道有什么用？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-11T13:33:41+00:00">
                2025-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis中的管道有什么用？"><a href="#👌redis中的管道有什么用？" class="headerlink" title="👌redis中的管道有什么用？"></a>👌redis中的管道有什么用？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官。管道 pipeline 主要是为了解决批量查询问题而诞生的。如果说没有管道，我们查 10 个信息，就要发送 10 次命令，与 redis 进行往返 10 次的交互，这对性能的影响是很大的。如果通过管道，将 10 个命令放在一块传递给 redis，结果再一次性返回，性能会得到提升。这种思想可以用到很多地方，包括在 mysql 进行查询的时候，也可以考虑。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>管道这道题还比较常问，因为在公司中还是很多场景都在使用的。比较考察你对于性能的提升优化有没有考虑，代码写的好的小伙伴，肯定会考虑到批量这一点。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>批量，网络消耗，顺序返回</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis中的管道（Pipeline）主要用于批量执行多个命令，用来提高性能和效率。管道可以将多个命令一次性发给服务器，然后返回多个结果。</p>
<h2 id="为什么会有管道"><a href="#为什么会有管道" class="headerlink" title="为什么会有管道"></a>为什么会有管道</h2><p>按照平时开发的过程，假设要查询 10 个用户的信息，用户的信息正好存在 redis 里面。这个时候客户端需要发送 10 次命令到服务器，服务器处理命令并返回结果，这个过程会涉及多次网络往返，尤其是在高延迟网络环境中，频繁的网络通信会降低性能。管道通过将多个命令打包在一起，一次性发送到服务器，从而减少网络往返次数，提高性能。</p>
<p>管道的工作原理是将多个Redis命令批量发送到服务器，而不等待每个命令的单独响应。</p>
<p><strong>客户端批量发送命令</strong>：客户端将一系列Redis命令放入管道中。</p>
<p><strong>一次性发送命令</strong>：客户端将所有命令一次性发送到Redis服务器。</p>
<p><strong>服务器批量处理命令</strong>：Redis服务器依次处理这些命令。</p>
<p><strong>批量返回结果</strong>：服务器将所有命令的结果一次性返回给客户端。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p><strong>1、 批量写入数据</strong>：如批量插入大量数据到Redis中，可以显著提高写入速度。类似 mysql 里面的批量插入。</p>
<p><strong>2、 批量读取数据</strong>：如一次性获取大量键值对，可以减少网络延迟。类似 mysql 可以通过 in 的方式来查询多个数据。但是不想 mysql 那么死，redis 的管道什么命令都可以放一起。</p>
<p><strong>3、 减少网络开销</strong>：在高延迟网络环境中，管道可以显著减少网络往返次数，提高性能。</p>
<h2 id="Java中使用Redis管道"><a href="#Java中使用Redis管道" class="headerlink" title="Java中使用Redis管道"></a>Java中使用Redis管道</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量发送1000个SET命令，最后执行管道中的命令并关闭连接。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Pipeline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPipelineExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Jedis对象，连接到Redis服务器</span></span><br><span class="line">        Jedis jedis=<span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始管道操作</span></span><br><span class="line">        Pipeline pipeline= jedis.pipelined();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量发送命令</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            pipeline.set(<span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行管道中的命令</span></span><br><span class="line">        pipeline.sync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Jedis连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>管道中的命令是按顺序执行的，结果也按顺序返回。管道中的某个命令失败不会影响其他命令的执行，需要注意如何处理返回的结果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/11/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/11/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9F/" itemprop="url">👌redis主从复制的核心原理？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-11T13:33:41+00:00">
                2025-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis主从复制的核心原理？"><a href="#👌redis主从复制的核心原理？" class="headerlink" title="👌redis主从复制的核心原理？"></a>👌redis主从复制的核心原理？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官。redis 的主从复制原理主要是，一开始从服务器发送同步命令，主服务器接收到之后，就会生成一个 rdb 的文件，然后传输给从服务器，从服务器接收到之后，立马进行数据的恢复。然后当主服务器再次接收到写命令的时候，会发给从服务器。这个过程是一个异步复制，主服务器不会等待结果。这样就完成了主从复制，主要的核心步骤就是这些，涉及的一个同步的点就是偏移量，主从都会维护一个偏移量的概念。来判断自己复制到哪里了，如果没有达到会继续自动复制。以上</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>算是比较原理的一道题了，低年限的基本不会问到。这道题可以考察到你初始同步，增量同步的一些思想。这个同步机制，在其他场景也是基本适用的，就像是 mysql 的主从复制基本也是如此。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>sync 命令，生成 rdb，写命令增量，缓存偏移量</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="主从复制概念"><a href="#主从复制概念" class="headerlink" title="主从复制概念"></a>主从复制概念</h2><p>Redis支持主从复制模式，其中一台服务器作为主服务器（Master），可以接收写请求；而一个或多个服务器作为从服务器（Slave），只能接收读请求。通过SLAVEOF命令或配置文件中设置slaveof选项，让从服务器复制主服务器的数据。</p>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>1、发送SYNC命令：从服务器启动后，连接上主服务器发送SYNC命令，请求同步数据。</p>
<p>2、创建RDB文件：主服务器接收到SYNC命令后，在后台执行BGSAVE命令，生成一个RDB快照文件，这个文件包含了主服务器当前的数据状态。</p>
<p>3、发送RDB文件：主服务器将生成的RDB文件发送给从服务器，从服务器接收并加载该文件，更新自己的数据状态。</p>
<p>4、异步复制：一旦从服务器加载完RDB文件，主从复制就进入了命令传播阶段。此时，主服务器会将所有接收到的写命令发送给从服务器，确保主从数据的一致性。Redis的主从复制是异步的，这意味着主服务器在发送写命令给从服务器时，不会等待从服务器的响应，从而保证了主服务器的高可用性。</p>
<h2 id="复制偏移量和缓冲区概念"><a href="#复制偏移量和缓冲区概念" class="headerlink" title="复制偏移量和缓冲区概念"></a>复制偏移量和缓冲区概念</h2><p>主从服务器都会维护一个复制偏移量（offset），用于记录复制过程中传输的数据量。通过比较主从服务器的复制偏移量，可以判断数据是否一致。</p>
<p>复制积压缓冲区：主服务器维护了一个固定长度的、先进先出（FIFO）的队列作为复制积压缓冲区，用于保存最近一段时间内的写命令。当从服务器重新连接主服务器时，如果复制偏移量在复制积压缓冲区范围内，主服务器可以直接将从断线位置开始的写命令发送给从服务器，实现部分重同步。</p>
<p>这两个概念对于短线重连也产生了极大的影响。</p>
<p>当从节点与主节点的连接断开后，会自动尝试重新连接。如果从节点重新连接主节点时，发现自己的复制偏移量在主节点的复制积压缓冲区范围内，则会进行增量同步。如果复制积压缓冲区中的数据不足以完成同步，则需要重新进行全量同步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/11/redis/redis%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%85%B7%E4%BD%93%E7%9A%84%E8%8A%82%E7%82%B9_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/11/redis/redis%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%85%B7%E4%BD%93%E7%9A%84%E8%8A%82%E7%82%B9_/" itemprop="url">👌redis在集群中查找key的时候，怎么定位到具体的节点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-11T13:33:41+00:00">
                2025-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis在集群中查找key的时候，怎么定位到具体的节点"><a href="#👌redis在集群中查找key的时候，怎么定位到具体的节点" class="headerlink" title="👌redis在集群中查找key的时候，怎么定位到具体的节点?"></a>👌redis在集群中查找key的时候，怎么定位到具体的节点?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>这个问题主要涉及到一个哈希槽的概念，redis 集群，会将键划分为 16384 个槽。每个槽分配一个或多个节点。比如一个集群，三个节点，每个节点负责一定范围的槽。当 key 来了的时候，首先做 hash 算法获得数值后，与 16384 进行取模。得到的值就是槽的位置，然后再根据槽的编号，就可以找到对应的节点。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>算是进阶点的一道题了，年限低的小伙伴不必太在意，在集群模式下，这个知识点是必须要掌握的。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>slot 机制，取模 hash 槽，16384，节点范围机制</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis集群采用了一种哈希槽的机制用于数据存储和获取。每个 redis 集群节点会分布在一个槽范围内，我们通过对 key 进行的 hash 计算，就可以确定 key 落在哪个槽上。</p>
<h2 id="哈希槽机制"><a href="#哈希槽机制" class="headerlink" title="哈希槽机制"></a>哈希槽机制</h2><p>Redis集群将整个键空间划分为16384个哈希槽。每个键根据其哈希值被映射到其中一个哈希槽上，每个哈希槽被分配给一个节点或多个节点（主从复制的场景）。计算过程如下：</p>
<ol>
<li><strong>计算哈希值</strong>：Redis使用MurmurHash算法对键进行哈希计算，得到一个整数哈希值。</li>
<li><strong>映射到哈希槽</strong>：将哈希值对16384取模（即hash(key) % 16384），得到对应的哈希槽编号。</li>
<li><strong>定位节点</strong>：根据哈希槽编号找到负责该哈希槽的节点。</li>
</ol>
<p>看了上面的图，你对 slot 有了解了，那么你会产生疑问，slot 又是如何和 redis 进行关联的呢？</p>
<h2 id="哈希槽分配"><a href="#哈希槽分配" class="headerlink" title="哈希槽分配"></a>哈希槽分配</h2><p>集群的配置时，哈希槽会被分配给不同的节点。每个节点负责一定范围的哈希槽。例如，节点A可能负责哈希槽0-5000，节点B负责哈希槽5001-10000，节点C负责哈希槽10001-16383。这样就实现了集群、节点、slot 三者联动。</p>
<h2 id="查找流程"><a href="#查找流程" class="headerlink" title="查找流程"></a>查找流程</h2><p>当客户端需要查找某个键时，流程如下：</p>
<ol>
<li><strong>计算哈希槽</strong>：客户端根据键计算出对应的哈希槽编号。</li>
<li><strong>查找节点</strong>：客户端查询集群的哈希槽分配表，找到负责该哈希槽的节点。</li>
<li><strong>发送请求</strong>：客户端将请求发送到对应的节点，获取或存储数据。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>一般这种都需要我们操心，很多都帮我们封装好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClusterExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义集群节点</span></span><br><span class="line">        Set&lt;HostAndPort&gt; nodes = newHashSet&lt;&gt;();</span><br><span class="line">        nodes.add(newHostAndPort(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        nodes.add(newHostAndPort(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        nodes.add(newHostAndPort(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7002</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建JedisCluster对象</span></span><br><span class="line">        JedisCluster jedisCluster=<span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储键值对</span></span><br><span class="line">        jedisCluster.set(<span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;myvalue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取键值对</span></span><br><span class="line">        String value= jedisCluster.get(<span class="string">&quot;mykey&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Value for &#x27;mykey&#x27;: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭JedisCluster连接</span></span><br><span class="line">        jedisCluster.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/11/redis/redis%E6%94%AF%E6%8C%81%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/11/redis/redis%E6%94%AF%E6%8C%81%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_/" itemprop="url">👌redis支持哪几种数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-11T13:33:41+00:00">
                2025-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis支持哪几种数据类型"><a href="#👌redis支持哪几种数据类型" class="headerlink" title="👌redis支持哪几种数据类型?"></a>👌redis支持哪几种数据类型?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>redis 的基础数据类型，主要有五种，string ，hash，list，set 和 zset。平时最常用的就是 string，可以缓存内容、做分布式锁等等，其次就是 hash，比如缓存一些对象结构的数据，hash 就比较合理。假设缓存一个个人信息，姓名，年龄，头像这些。传统的 string 需要进行序列化转 json，hash 则可以直接拿到。zset 也用过，主要是做排行榜功能，利用分数的特性进行排序。主要就是这些，以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>这道题比较简单，一般面试切入到 redis 的时候，会问一下这道，但是你的目的是在这五种基础数据类型中，选出钩子，让面试官继续针对某一个类型来进行问，比如你对分布式锁准备的很充分，你答 string 类型的时候，就往上面引入，你用 zset 做过排行榜，那么就 zset 上面多说一些。</p>
<h1 id="面试重点词"><a href="#面试重点词" class="headerlink" title="面试重点词"></a>面试重点词</h1><p>五种类型、string 的分布式锁、hash 存储对象、zset 做排行榜。</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis支持的数据类型主要有五种。</p>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a><strong>String（字符串）</strong></h3><p>1、字符串是 Redis 中最简单和最常用的数据类型。可以用来存储如字符串、整数、浮点数、图片（图片的base64编码或图片的路径）、序列化后的对象等。</p>
<p>2、每个键（key）对应一个值（value），一个键最大能存储512MB的数据。</p>
<p>3、命令用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key &quot;value&quot;</span><br><span class="line">GET key</span><br></pre></td></tr></table></figure>

<h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a><strong>Hash（哈希）</strong></h3><p>1、Redis Hash是一个String类型的field和value的映射表，类似于Java中的Map&lt;String, Object&gt;。</p>
<p>2、Hash特别适合用于存储对象，如用户信息、商品详情等。</p>
<p>3、 每个Hash可以存储2^32 - 1个键值对。</p>
<p>4、命令用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET user:1000 name &quot;John&quot;</span><br><span class="line">HGET user:1000 name</span><br></pre></td></tr></table></figure>

<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a><strong>List（列表）</strong></h3><p>1、 列表是一个有序的字符串集合，可以从两端压入或弹出元素，支持在列表的头部或尾部添加元素。</p>
<p>2、 列表最多可存储2^32 - 1个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH mylist &quot;world&quot;</span><br><span class="line">LPUSH mylist &quot;hello&quot;</span><br><span class="line">LRANGE mylist 0 -1</span><br></pre></td></tr></table></figure>

<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a><strong>Set（集合）</strong></h3><p>1、Set是一个无序的字符串集合，不允许重复元素。集合适用于去重和集合运算（如交集、并集、差集）。Set的添加、删除、查找操作的复杂度都是O(1)。</p>
<p>2、常用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD myset &quot;hello&quot;</span><br><span class="line">SADD myset &quot;world&quot;</span><br><span class="line">SMEMBERS myset</span><br></pre></td></tr></table></figure>

<h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a><strong>Zset（有序集合）</strong></h3><p>Zset和Set一样也是String类型元素的集合，且不允许重复的成员。有序集合类似于集合，但每个元素都会关联一个double类型的分数（score），redis正是通过分数来为集合中的成员进行从小到大的排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/11/redis/redis%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/11/redis/redis%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9_/" itemprop="url">👌redis有哪些优点？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-11T13:33:41+00:00">
                2025-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis有哪些优点"><a href="#👌redis有哪些优点" class="headerlink" title="👌redis有哪些优点?"></a>👌redis有哪些优点?</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官 Redis 是现在非常常用的缓存，相比于其他的缓存，最大的一个优势就是高性能，redis 的速度非常快，操作都是毫秒级，吞吐量非常高，支持每秒数百万的请求。同时各种操作都基于内存进行，读写速度非常快。还有就是他提供了丰富的数据类型，像 string，hash，zset 这些，在我们日常开发都非常常见的使用。还有一些高级数据类型，像 geo，bitmap 这些。另外就是 redis 的持久化机制做的也比较好，不同的策略选择使其可以应对宕机等异常情况。配合分布式集群的支持，整体的可用性也非常高。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>其实这道题一般是面试官跟你聊 redis 刚开头的开场时候，会和你问问，主要目的其实是想通过你说的一些优点，来继续发问，问你为什么这是优点，以及延伸出一个话题来继续深度聊。所以像这道题，大家答的时候，熟悉哪个优点就多说点，有点不熟悉的就一嘴带过！</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>高性能，内存，快，高吞吐，持久化，分布式</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis 是当前非常主流的缓存，基于键值对来实现的存储，支持多种数据类型。看一下鸡哥这张思维导图就知道优点是什么了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/10/redis/redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/10/redis/redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F/" itemprop="url">👌redis有哪些持久化方式？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-10T13:33:41+00:00">
                2025-05-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis有哪些持久化方式？"><a href="#👌redis有哪些持久化方式？" class="headerlink" title="👌redis有哪些持久化方式？"></a>👌redis有哪些持久化方式？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>主要是 rdb 和 aof 的方式，另外也可以混合使用。rdb 主要是在指定的时间间隔内生成数据集的快照，并将其保存到磁盘上，生成一个 rdb 格式的二进制文件，容易备份。恢复速度快，适合用于灾难恢复。AOF持久化方式是记录每一个写操作到日志文件中。Redis会将这些写操作以追加的方式写入到AOF文件中。每次恢复的时候，进行重放。aof 相比 rdb 就是文件会大一些，回复速度慢一些，但是数据丢失风险小。在实际中，一般可以选择混合互补的方式使用。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>经典必问，面试官经常会问你 redis 数据丢不丢啊，如何持久化啊，这类问题。大家要记住 rdb 和 aof 的两个特点即可。一个比较粗，一个比较细致，重点答这一块，最后告诉他混合起来。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>rdb，aof，混合持久化</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>主要的持久化方式有两种：RDB（Redis Database）和AOF（Append Only File）。</p>
<p>Redis 4.0引入了混合持久化模式。</p>
<h2 id="RDB（Redis-Database）"><a href="#RDB（Redis-Database）" class="headerlink" title="RDB（Redis Database）"></a>RDB（Redis Database）</h2><p>RDB持久化方式会在指定的时间间隔内生成数据集的快照，并将其保存到磁盘上。这个快照文件的默认名称是dump.rdb。</p>
<p>RDB的配置可以在redis.conf文件中进行。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      # 如果900秒（15分钟）内至少有1个键发生变化，就触发一次RDB快照</span><br><span class="line">save 300 10     # 如果300秒（5分钟）内至少有10个键发生变化，就触发一次RDB快照</span><br><span class="line">save 60 10000   # 如果60秒（1分钟）内至少有10000个键发生变化，就触发一次RDB快照</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<p>1、RDB文件是一个紧凑的二进制文件，可以很容易地进行备份。</p>
<p>2、 恢复速度快，适合用于灾难恢复。</p>
<p>3、 对Redis性能影响较小，因为生成RDB文件的工作是在子进程中进行的。</p>
<p><strong>缺点</strong>：</p>
<p>1、 数据持久化的频率较低，可能会丢失最近一次快照之后的数据。</p>
<p>2、 生成RDB快照时，可能会消耗较多的CPU和内存资源。</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>AOF持久化方式记录每一个写操作到日志文件中（默认名称是appendonly.aof）。Redis会将这些写操作以追加的方式写入到AOF文件中。</p>
<p>AOF的配置可以在redis.conf文件中进行。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes         # 启用AOF持久化</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次AOF文件</span><br><span class="line"># 其他选项：</span><br><span class="line"># appendfsync always  # 每个写操作都同步到AOF文件，性能较差但数据最安全</span><br><span class="line"># appendfsync no      # 由操作系统决定何时同步，性能最好但数据安全性较差</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<p>1、数据恢复更可靠，AOF可以记录每一个写操作，数据丢失风险较小。</p>
<p>2、AOF文件是可读的文本文件，方便分析和调试。</p>
<p><strong>缺点</strong>：</p>
<p>1、 AOF文件比RDB文件大，恢复速度较慢。</p>
<p>2、 持久化频率高时，可能会影响Redis性能。</p>
<p>3、 需要定期进行AOF重写（rewrite），以避免文件过大。</p>
<h3 id="3-混合持久化（Hybrid-Persistence）"><a href="#3-混合持久化（Hybrid-Persistence）" class="headerlink" title="3. 混合持久化（Hybrid Persistence）"></a>3. 混合持久化（Hybrid Persistence）</h3><p>混合持久化模式结合了RDB和AOF的优点。在Redis 4.0及以上版本中，混合持久化模式在生成新的AOF文件时，会首先创建一个RDB快照，然后在快照之后追加AOF日志。这种方式可以在保证数据恢复速度的同时，减少数据丢失的风险。</p>
<p>混合持久化的配置可以在redis.conf文件中进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes  # 启用混合持久化模式</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<p>1、 结合了RDB和AOF的优点，既能快速恢复数据，又能减少数据丢失的风险。</p>
<h2 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h2><p><strong>RDB</strong>：适用于对数据一致性要求不高，但需要快速恢复数据的场景，例如缓存服务器。</p>
<p><strong>AOF</strong>：适用于对数据一致性要求高的场景，例如金融交易系统。</p>
<p><strong>混合持久化</strong>：适用于需要综合考虑数据恢复速度和数据一致性的场景。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/10/redis/redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/10/redis/redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F/" itemprop="url">👌redis相比memcached有哪些优势？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-10T13:33:41+00:00">
                2025-05-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis相比memcached有哪些优势？"><a href="#👌redis相比memcached有哪些优势？" class="headerlink" title="👌redis相比memcached有哪些优势？"></a>👌redis相比memcached有哪些优势？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>redis 相比 memcached，主要提供了丰富的数据类型和各种高级操作。memcached 仅仅支持字符串类型，redis 支持 5 种基础+4 种高级，非常丰富。还有就是 redis 提供了 rdb 和 aof 的持久化机制，memcached 一旦重启，数据就会直接丢失。分布式相关，redis 天然支持主从复制，哨兵，集群，memcached 还需要靠一些第三方库和工具类实现。再高级一点的就是 redis 支持像 lua，事务，发布订阅这些，memcached 统统不支持。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>最近几年基本上不会考这道题了，这道题在早些时候，memcached 还用的时候，问的比较多。除非碰到还在用memcached 的公司，否则不会被问到。大家稍微了解即可，比较的过程也是了解历史的过程。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>丰富数据类型，持久化，分布式，lua，事务</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>通过一个表格来进行对比</p>
<table>
<thead>
<tr>
<th></th>
<th>redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>Redis 支持字符串、哈希、列表、集合、有序集合、位图、HyperLogLog、地理空间和流等多种数据类型</td>
<td>Memcached 仅支持字符串类型的键值对。</td>
</tr>
<tr>
<td>持久化机制</td>
<td>Redis 支持将数据持久化到磁盘，可以通过 RDB 快照和 AOF 日志来保存数据，确保在系统重启后数据不会丢失</td>
<td>Memcached不支持持久化，数据仅保存在内存中，一旦服务器重启或宕机，数据就会丢失。</td>
</tr>
<tr>
<td>分布式</td>
<td>支持主从，哨兵，集群</td>
<td>Memcached也支持分布式部署，但通常需要依赖第三方库或工具来实现</td>
</tr>
<tr>
<td>脚本功能</td>
<td>Redis 支持在服务器端执行 Lua 脚本，能够将多个操作合并为一个原子操作</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>Redis 提供 MULTI、EXEC、WATCH 等命令，支持简单的事务操作</td>
<td>不支持事务</td>
</tr>
<tr>
<td>内存淘汰策略</td>
<td>Redis 提供多种内存淘汰策略，如 LRU、LFU 等</td>
<td>Memcached 仅支持 LRU 淘汰策略。</td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/09/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/09/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F/" itemprop="url">👌redis是单进程单线程？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-09T13:33:41+00:00">
                2025-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis为什么这么快？"><a href="#👌redis为什么这么快？" class="headerlink" title="👌redis为什么这么快？"></a>👌redis为什么这么快？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>redis 的快主要得益于以下几个点，第一个就是纯内存的操作，相比磁盘来说，纯内存带来的速度提升非常大。其次就是合理的数据结构和数据编码设计。像不同的数据类型所对应的底层结构都会有变化，基本上作者让我们在 o1 的复杂度内就可以读取到我们想要的值。还有就是单线程，因为在内存，所以压力瓶颈一般在网络和 cpu，单线程完全足够，这使得 redis 不需要考虑切换的消耗。以及 redis 采取了 io 多路复用，减少了网络压力，提高了吞吐量。以上就是 redis 这么快的原因。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>经典题目了，主要是看你对内存的速度有没有一个思考性的了解，知道内存比磁盘快的多，有这种思维，可以在平时开发的时候多注意。还有就是考察单线程不需要考虑切换和争抢的性能问题。io 多路复用是 redis 的比较特色的东西。再深一点就是要考察你对数据类型的底层结构有没有具体的了解了。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>内存，数据结构，单线程，io 多路复用</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>redis 巨快，巨快，操作毫秒级，qps 可达 10w+。</p>
<h2 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h2><h3 id="纯内存"><a href="#纯内存" class="headerlink" title="纯内存"></a>纯内存</h3><p>Redis将数据存储在内存中，避免了大量访问数据库和直接读取磁盘数据的操作。内存的读写速度远超过磁盘I&#x2F;O，使得Redis的数据访问非常迅速。</p>
<h3 id="数据结构合理"><a href="#数据结构合理" class="headerlink" title="数据结构合理"></a>数据结构合理</h3><p>Redis内部的数据结构都是为快速读写而设计的，如跳跃表、SDS（简单动态字符串）、链表和Hash等。基本都能够在 o（1）复杂度下完成大部分操作，比如 hash 的结构，想获取其中一个属性的值，非常的方便，不像数据库查询需要磁盘寻找。</p>
<h3 id="单线程操作"><a href="#单线程操作" class="headerlink" title="单线程操作"></a>单线程操作</h3><p>Redis采用单线程模型来处理客户端请求，避免了多线程带来的上下文切换和竞争条件。单线程模型使得Redis不需要考虑各种锁的问题，减少了性能消耗。但是持久化，异步删除等等是异步线程处理，但这不影响性能。不过要注意一个点，因为单线程，某个命令如果耗时太大，可能会产生阻塞，也就是我们经常说的，不要使用 keys，或者直接读整个 hash 大 key。</p>
<h3 id="io-多路复用模型"><a href="#io-多路复用模型" class="headerlink" title="io 多路复用模型"></a>io 多路复用模型</h3><p><font style="color:rgb(25, 27, 31);">Redis在网络通信和磁盘写入方面采用了异步式的IO处理，即使用epoll</font>多路复用技术<font style="color:rgb(25, 27, 31);">同时处理多个网络请求，减少了I&#x2F;O阻塞及</font>上下文切换<font style="color:rgb(25, 27, 31);">开销，提高了系统的吞吐量和响应时间。</font></p>
<h3 id="专门设计的数据结构"><a href="#专门设计的数据结构" class="headerlink" title="专门设计的数据结构"></a>专门设计的数据结构</h3><p>redis 的每种数据类型对应的底层存储结构都不一样，经历过多种方式的设计。拿 string 类型来进行说，如果存储数字的话，是用int类型的编码。如果存储非数字，小于等于39字节的字符串，是embstr。大于39个字节，则是raw编码。这种根据类型和字节数的设计，在 key 越多的场景下，占用空间越少。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/09/redis/redis%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%8C%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/09/redis/redis%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%8C%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97_/" itemprop="url">👌redis事务支持原子性，支持回滚？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-09T13:33:41+00:00">
                2025-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis事务保证原子性吗，支持回滚吗"><a href="#👌redis事务保证原子性吗，支持回滚吗" class="headerlink" title="👌redis事务保证原子性吗，支持回滚吗?"></a>👌redis事务保证原子性吗，支持回滚吗?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>不支持。</p>
<p>先来回顾两个命令：</p>
<p>MULTI：开启一个事务。之后的所有命令都会被放入一个队列中，直到EXEC命令执行。</p>
<p>EXEC：执行之前队列中的所有命令。</p>
<p>在MULTI和EXEC之间的命令会被放入一个队列中，直到EXEC命令执行时，这些命令才会按顺序执行。</p>
<p>在EXEC命令执行时，所有被MULTI命令包裹的命令会按顺序一次性执行。意味着在EXEC执行时，Redis会将所有命令作为一个整体进行处理。Redis保证单个命令的原子性，即每个命令在执行时是不可分割的。</p>
<p>但是，Redis事务并不完全等同于传统关系型数据库的事务。</p>
<p>如果在EXEC执行过程中某个命令失败（例如，命令语法错误），该命令会被跳过，但其他命令仍然会继续执行。这与关系型数据库的事务不同，后者通常会在某个命令失败时回滚整个事务。</p>
<p>Redis事务没有回滚机制。如果某个命令执行失败，已经执行的命令不会被撤销。</p>
<p>redis再执行lua脚本的时候，会封装为一个事务，不可中断；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/09/redis/redis%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/09/redis/redis%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84_/" itemprop="url">👌redis回收进程是如何工作的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-09T13:33:41+00:00">
                2025-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis回收进程如何工作的"><a href="#👌redis回收进程如何工作的" class="headerlink" title="👌redis回收进程如何工作的?"></a>👌redis回收进程如何工作的?</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis的回收进程负责定期扫描和删除过期键。服务器运行时自动执行。主要就是定期回收和惰性回收，其实也可以看之前的 redis 过期策略。来进行合二为一，其实二者答案差不多，就是内容有一定区别。</p>
<h2 id="定期回收任务"><a href="#定期回收任务" class="headerlink" title="定期回收任务"></a>定期回收任务</h2><p>Redis回收进程的核心是一个定期任务，这个任务在Redis的事件循环中执行。</p>
<p><strong>事件循环</strong>：Redis使用一个单线程的事件循环模型来处理所有的客户端请求和后台任务。</p>
<p><strong>定期任务</strong>：在事件循环中，Redis会定期触发一个函数来执行过期键的检查和删除操作。这个函数默认每100毫秒运行一次。</p>
<p>实现步骤如下：</p>
<ol>
<li><strong>选择数据库</strong>：每次执行定期任务时，Redis会遍历所有的数据库（默认16个）。</li>
<li><strong>随机抽样</strong>：对于每个数据库，Redis会随机选择一部分带有过期时间的键进行检查（默认20个）。</li>
<li><strong>检查过期键</strong>：检查这些键是否已经过期，如果过期则删除。</li>
<li><strong>重复检查</strong>：如果发现超过一定比例的键是过期的（默认25%），则继续进行更多次的检查和删除，直到过期键的比例下降到合理范围内。</li>
</ol>
<h2 id="惰性回收"><a href="#惰性回收" class="headerlink" title="惰性回收"></a>惰性回收</h2><p>惰性回收不是一个独立的进程，而是每次客户端访问键时触发的检查机制。它的工作原理如下：</p>
<ol>
<li><strong>访问键</strong>：每当客户端访问一个键时，Redis会检查该键是否设置了过期时间。</li>
<li><strong>检查过期</strong>：如果该键已经过期，Redis会立即删除该键，并返回空结果或相应的错误信息。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/09/redis/redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/09/redis/redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/" itemprop="url">👌redis如何实现延迟队列？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-09T13:33:41+00:00">
                2025-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis如何实现延时队列"><a href="#👌redis如何实现延时队列" class="headerlink" title="👌redis如何实现延时队列"></a>👌redis如何实现延时队列</h1><h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>可以使用有序集合（Sorted Set）来实现延时队列。有序集合中的每个元素有一个关联的分数，可以用来表示任务的执行时间戳。具体的步骤如下，非常简单</p>
<h2 id="添加任务到延时队列"><a href="#添加任务到延时队列" class="headerlink" title="添加任务到延时队列"></a>添加任务到延时队列</h2><p>将任务添加到有序集合中，使用任务的执行时间作为分数（score）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 示例代码：添加任务到延时队列</span><br><span class="line">String queueName = &quot;delay_queue&quot;;</span><br><span class="line">String taskId=&quot;task_1&quot;;</span><br><span class="line">long delay=5000; // 延迟时间（毫秒）</span><br><span class="line">long executionTime= System.currentTimeMillis() + delay;</span><br><span class="line">Jedis jedis = newJedis(&quot;localhost&quot;);</span><br><span class="line">jedis.zadd(queueName, executionTime, taskId);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<h2 id="轮询延时队列并执行任务"><a href="#轮询延时队列并执行任务" class="headerlink" title="轮询延时队列并执行任务"></a>轮询延时队列并执行任务</h2><p>定期检查有序集合中的任务，找到那些执行时间已经到达或超过当前时间的任务，并执行这些任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 示例代码：轮询延时队列并执行任务</span><br><span class="line">String queueName = &quot;delay_queue&quot;;</span><br><span class="line">Jedis jedis=new Jedis(&quot;localhost&quot;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">    long currentTime= System.currentTimeMillis();</span><br><span class="line">    Set&lt;Tuple&gt; tasks = jedis.zrangeByScoreWithScores(queueName, 0, currentTime, 0, 1);</span><br><span class="line"></span><br><span class="line">    if (tasks.isEmpty()) &#123;</span><br><span class="line">        // 没有任务需要执行，休眠一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (Tuple task : tasks) &#123;</span><br><span class="line">        StringtaskId= task.getElement();</span><br><span class="line">        // 执行任务</span><br><span class="line">        executeTask(taskId);</span><br><span class="line"></span><br><span class="line">        // 从队列中移除已执行的任务</span><br><span class="line">        jedis.zrem(queueName, taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jedis.close();</span><br><span class="line">private static void executeTask(String taskId) &#123;</span><br><span class="line">    // 实现任务执行逻辑</span><br><span class="line">    System.out.println(&quot;Executing task: &quot; + taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/09/redis/redis%E6%98%AF%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/09/redis/redis%E6%98%AF%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%97%EF%BC%9F/" itemprop="url">👌redis是单进程单线程？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-09T13:33:41+00:00">
                2025-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis是单进程单线程的吗？"><a href="#👌redis是单进程单线程的吗？" class="headerlink" title="👌redis是单进程单线程的吗？"></a>👌redis是单进程单线程的吗？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>这个问题其实是两个角度来看，我们通常说 redis 说单线程，是因为从接收到客户端的请求，然后 redis 进行内部操作，再返回结果。这个过程是单线程的。单线程的吞吐量可以达到 10w&#x2F;s，来自 redis 的官方数据，由于 redis 的操作都是在内存中完成，所以性能的瓶颈时内存和带宽，而不是 cpu。如果在这种情况下，使用多线程，反而又要去处理线程安全和数据竞争的问题，还有上下文切换的消耗。那么另一个角度就是除了 redis 执行命令的时候，像持久化数据操作，内存释放操作，这些是由多线程来进行实现的。在 redis6.0 之后，为了减轻网络的性能瓶颈，还增加了多个 io 线程来处理请求。也是一个比较大的优化。所以这个问题，两个角度来看，以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>还是问的比较常见的，一道陷阱题。如果你单纯的说，是单线程的，基本就 gg，面试官会认为的你广度是有问题的。所以说大家一定要答出另一个角度。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>操作单线程、多线程异步、多路 io</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis核心操作是单线程的。Redis在处理并发请求时有简单、高效和一致性的优点。但是Redis在某些方面使用了额外的线程来处理后台任务。</p>
<p>Redis的主要操作，包括网络IO和键值对读写，确实是由一个线程来完成的。这保证了Redis在处理客户端请求时的简单性和一致性，避免了多线程可能带来的上下文切换开销和竞争条件。利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。这意味着，虽然多个客户端可能同时发送请求，但Redis会将这些请求放入队列中，并逐个处理它们。</p>
<p>Redis 单线程性能高的原因：</p>
<p>1、 高效的 I&#x2F;O 多路复用：Redis使用网络IO多路复用技术（如epoll）来同时处理多个客户端连接。这使得Redis能够高效地利用系统资源，为大量并发连接提供高性能的服务。官网数据 10w&#x2F;qps。</p>
<p>2、 由于Redis基于内存操作，并且采用了单线程模型，不需要处理线程切换问题和多线程之间资源竞争，以及锁的问题。</p>
<p>Redis 多线程主要做的事情：</p>
<p>持久化（例如，在保存RDB快照时，Redis会自动fork一个子进程去处理）、异步删除和集群数据同步等。这些任务不会阻塞Redis的主线程，从而确保Redis能够持续地为客户端提供服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/09/redis/redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/09/redis/redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/" itemprop="url">👌redis的setnx和setex的区别？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-09T13:33:41+00:00">
                2025-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌redis过期策略有哪些？"><a href="#👌redis过期策略有哪些？" class="headerlink" title="👌redis过期策略有哪些？"></a>👌redis过期策略有哪些？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>过期策略主要分为主动和被动，主动又分为定时、定期，被动就是常说的惰性清理。先说结论，redis 采取的方案是定期+惰性配合的方式来进行实现。定期策略主要是通过周期性执行的函数来扫描即将过期的键，立马将其进行失效操作。这种方式比较消耗 cpu。于是产生了定期操作，没隔多少 ms 来进行执行，这种减少了 cpu 的消耗。也能比较准时的删除过期的键。算是定时的一种优化，比较难的点就是寻求平衡。最后就是惰性删除，所有的 key 即使过期了也不会立马删除，当这个键过期之后，下一次访问的时候，才会被删除，容易造成内存泄漏的问题。最后 oom 就会触发内存淘汰策略了，优点就是大大减轻了 cpu 的压力。以上两种方式配合，能达到一个平衡。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>常考题，很多人把过期策略和淘汰策略混在一起。二者既不同，当惰性删除的时候，又有联系。大家要注意多层面来回答，注意辩证 cpu 性能的问题处理。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>定期删除，定时删除，惰性删除，主动于被动</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>从行为上，我们可以把过期策略分为两大点。主动删除，被动删除。主动删除又分为定时删除和定期删除。</p>
<h2 id="主动删除"><a href="#主动删除" class="headerlink" title="主动删除"></a>主动删除</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a><strong>定时删除</strong></h3><p>当设置键的过期时间时，Redis会为该键创建一个定时器，当过期时间到达时自动删除该键。redis.c 下的 activeExpireCycle 函数实现了定期删除粗略，配合 Redis的服务器的 serverCron函数，在服务器周期执行serverCron 的时候，activeExpireCycle函数就会被调用，在一定的时间内，分多次遍历 redis 中的数据库，从数据库的expires字典中检查一部分键的过期时间，此操作是随机性的，然后删除其中的过期键。</p>
<p>优点：删除操作会在数据到期时立即进行，确保内存及时释放。</p>
<p>缺点：定时器的管理会消耗系统资源，特别是在大量键设置过期时间的情况下，删除 key 会对响应时间和吞吐量产生影响。</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h3><p>Redis会定期扫描数据库中的键，并删除其中已过期的键。通过随机抽取一定数量的键，并检查它们是否过期，如果过期就删除，Redis默认每隔100ms（可以通过配置文件中的hz参数进行调整）就执行一次过期扫描任务。</p>
<blockquote>
<p>配置redis.conf的hz选项，默认为10，1s刷新的频率。即1秒执行10次，相当于100ms执行一次，hz值越大，说明刷新频率越快，Redis性能损耗也越大</p>
</blockquote>
<p>优点：通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响，同时能有效释放过期键占用的内存。</p>
<p>缺点：难以确定删除操作执行的时长和频率，如果执行的太频繁，会对CPU造成负担，就变成了定时删除；如果执行的太少，则过期键长时间占用的内存没有及时释放，造成内存浪费。</p>
<h3 id="内存不足"><a href="#内存不足" class="headerlink" title="内存不足"></a>内存不足</h3><p>当Redis的内存达到最大限制时，还会触发内存淘汰策略，策略不同决定哪些数据会被删除以腾出空间。<br>no eviction：禁止淘汰，达到内存限制时拒绝新的写请求。<br>allkeys-lru：从所有键中淘汰最近最少使用的键。<br>volatile-lru：从设置了过期时间的键中驱逐最近最少使用的键。<br>allkeys-random：从所有键中随机驱逐键。<br>volatile-random：从设置了过期时间的键中随机驱逐键。<br>volatile-ttl：从设置了过期时间的键中驱逐剩余时间最短的键。</p>
<h2 id="被动删除"><a href="#被动删除" class="headerlink" title="被动删除"></a>被动删除</h2><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h3><p>Redis不会在键过期时立即删除它，而是在下一次访问这个键时检查其是否过期，然后删除过期的键。假设这个键已经过期，但是后面一直没有被访问，则会永远存在。不会被删除，这就是惰性删除。</p>
<p>惰性删除策略由db.c&#x2F;expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查。如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除；如果输入键未过期，那么expireIfNeeded函数不做动作。</p>
<p>优点：惰性删除不会增加额外的系统开销，不浪费 cpu，只在访问时进行检查。</p>
<p>缺点：如果某个键永远不会被访问，即使设置了过期时间，它也不会被自动删除，造成内存泄漏问题。</p>
<p>Redis 实际使用的是定期删除+惰性删除的方式！定期删除减少 cpu 消耗和浪费，配合惰性删除，二次检查保险。</p>
<h3 id><a href="#" class="headerlink" title></a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaoyaofeihu.github.io/2025/05/07/redis/Redis%E7%9A%84%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/11.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="余声-个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/05/07/redis/Redis%E7%9A%84%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F/" itemprop="url">👌Redis的从服务器的作用？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2025-05-07T13:33:41+00:00">
                2025-05-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2025-05-17T09:01:35+00:00">
                2025-05-17
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="👌Redis的从服务器的作用？"><a href="#👌Redis的从服务器的作用？" class="headerlink" title="👌Redis的从服务器的作用？"></a>👌Redis的从服务器的作用？</h1><h1 id="口语化回答"><a href="#口语化回答" class="headerlink" title="口语化回答"></a>口语化回答</h1><p>好的，面试官，从服务器在 redis 集群模式下，起着非常重要的角色。一方面可以复制数据，保证数据不丢失，当主节点发生故障的时候，可以切换到从服务器继续提供服务，还可以为主服务器分担压力，做读写分离，一般 redis 的都是读多写少，我们可以把从服务器承担读请求，把主服务器承担写请求。还有就是可以通过添加从节点，来提供额外的存储和计算能力。以上。</p>
<h1 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h1><p>业务比较大的情况下，redis 一般都会搭建集群，这道题其实可以考察到，你为什么要选择使用从服务器，看你对于高可用有没有自己的理解，以及集群模式的扩展，故障转移这些有没有一定的考虑。</p>
<h1 id="面试得分点"><a href="#面试得分点" class="headerlink" title="面试得分点"></a>面试得分点</h1><p>数据冗余备份、故障转移、读写分离、高可用</p>
<h1 id="题目详细答案"><a href="#题目详细答案" class="headerlink" title="题目详细答案"></a>题目详细答案</h1><p>Redis集群中的从服务器（也称为副本或副本节点）在Redis的高可用性和扩展性中扮演着重要角色。主要的作用有以下几点。</p>
<h3 id="提供数据冗余和备份"><a href="#提供数据冗余和备份" class="headerlink" title="提供数据冗余和备份"></a>提供数据冗余和备份</h3><p>在集群模式下，Redis集群中的每个主节点可以有一个或多个从节点。这些从节点会复制主节点的数据，从而提供数据的冗余和备份。当主节点出现故障或不可用时，从节点可以接管其工作，确保数据不会丢失，并提高系统的容错能力。</p>
<h3 id="支持故障自动转移"><a href="#支持故障自动转移" class="headerlink" title="支持故障自动转移"></a>支持故障自动转移</h3><p>在Redis集群中，当主节点发生故障时，系统可以自动将其中一个从节点升级为主节点，继续处理客户端的请求。这种自动转移的过程称为故障转移，可以确保Redis集群在节点故障时仍然保持高可用性和稳定性。</p>
<h3 id="支持读写分离"><a href="#支持读写分离" class="headerlink" title="支持读写分离"></a>支持读写分离</h3><p>在Redis集群配置中，可以将读请求发送到从节点，而将写请求发送到主节点。这种读写分离的配置可以提高系统的并发处理能力和读性能，因为从节点可以处理更多的读请求，而主节点则可以专注于处理写请求。</p>
<h3 id="扩展性能和容量："><a href="#扩展性能和容量：" class="headerlink" title="扩展性能和容量："></a>扩展性能和容量：</h3><p>通过添加从节点，Redis集群可以扩展其性能和容量。从节点可以分担主节点的负载，并提供额外的存储和计算能力。在Redis集群中，可以动态地添加或删除从节点，以扩展或缩小系统的规模和容量。这种灵活性使得Redis集群能够适应不同的业务需求和工作负载。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/11.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">229</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">javayun</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
