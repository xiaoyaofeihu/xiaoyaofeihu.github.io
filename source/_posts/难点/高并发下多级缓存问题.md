---
title: 高并发下的缓存问题 
date: 2024-11-12 17:33:00
tags:
	- 缓存
categories: 高并发
---

## 在高并发的情况下，特别是当 本地缓存（如 Guava, Caffeine 等）接到每秒 2000 万（QPS）的请求时，系统面临的挑战主要有两个方面：

缓存的读写性能瓶颈：即如何高效地处理大量的读写请求。
缓存的内存管理问题：如何合理利用内存，以应对大量数据的存储需求，并防止内存泄漏或过载。
为了应对这些挑战，可以采取以下几种优化和设计策略：

1. 选择合适的本地缓存库
对于高并发场景，选择一个高效的本地缓存库至关重要。常见的库有：

Caffeine：一个高性能的 Java 本地缓存库，基于 Google 的 Guava，通过 基于时间的过期策略 和 大小限制 来管理缓存，并提供 异步加载 和 弱引用缓存 支持。
Guava：较为成熟的缓存库，但对于高并发处理可能稍逊色于 Caffeine。
Caffeine 的性能通常优于 Guava，尤其在处理大量并发请求时，它在 缓存淘汰算法（如 LRU）和 内存管理（如使用弱引用、自动过期等）上做了很多优化。

2. 内存和缓存的容量管理
本地缓存的一个关键问题是如何管理 缓存容量，尤其是在高并发时。可以通过以下方式进行优化：

设置合理的缓存大小限制：根据应用的内存容量设置合理的缓存大小，避免缓存占用过多内存导致的内存溢出。常见的策略是 按大小（maximumSize）或按时间（expireAfterWrite）限制缓存大小。

LRU（Least Recently Used）策略：通过限制缓存条目的数量，当缓存的条目数超过限制时，自动淘汰最久未使用的数据。

自动过期（TTL）：为缓存数据设置一个过期时间（例如 expireAfterWrite 或 expireAfterAccess），避免缓存占用过多内存。

批量过期机制：在高并发环境下，可以通过批量清除缓存或定期刷新缓存来减少单个请求的压力。

3. 缓存穿透、雪崩和击穿的处理
在高并发情况下，避免 缓存穿透、缓存雪崩 和 缓存击穿 是非常重要的：

缓存穿透：是指查询的数据在缓存和数据库中都不存在。为了避免这种情况，可以使用 布隆过滤器（Bloom Filter）来快速判断某个数据是否存在，避免无效查询。

缓存雪崩：是指缓存中的大量数据在同一时刻过期，导致大量请求直接访问数据库。可以通过以下方式避免：

设置 不同的过期时间（例如，随机化过期时间，避免所有缓存同时过期）。
使用 后台异步更新 机制，确保缓存能够及时更新。
缓存击穿：是指某一时刻大量并发请求访问同一缓存条目，导致缓存失效后直接访问数据库。可以通过以下方式避免：

使用 锁机制（例如 ReentrantLock、synchronized 等）来确保只有一个请求能去加载数据，其他请求等待加载完成后共享缓存结果。
使用 队列或 信号量 来限制并发请求对数据库的访问。
4. 使用异步加载和缓存预加载
在高并发场景下， 异步加载 缓存可以显著提高性能，避免同步加载带来的性能瓶颈。

异步加载：通过异步方式加载缓存数据，使得当缓存数据不存在时，其他线程可以并发等待数据的加载结果，而不是阻塞。

缓存预加载：对于一些访问频繁的数据，可以提前预加载到缓存中，避免高并发时大量缓存未命中的情况。

5. 多级缓存策略
在高并发的情况下，采用 多级缓存 策略非常有效。例如：

本地缓存 + 分布式缓存：对于极其频繁的查询，使用本地缓存（如 Caffeine）进行快速响应；对于数据量较大、频率较低的查询，则使用 分布式缓存（如 Redis）来保证数据的一致性和持久性。

本地缓存与二级缓存结合：当本地缓存未命中时，可以查询 Redis 等分布式缓存。若 Redis 中也没有，则最终回退到数据库。

6. 限流与请求排队
在高并发环境中，可以使用 限流 和 请求排队 技术来避免请求过载，减少对本地缓存和数据库的压力。

限流：可以通过 令牌桶 或 漏桶算法 实现请求限流，确保系统不会因为过载而崩溃。
请求排队：对于高并发请求，可以通过队列对请求进行排队处理，保证系统的稳定性。
7. 监控与预警
在高并发情况下，必须监控缓存的使用情况、命中率、缓存大小和过期情况等，以便及时发现和处理性能瓶颈。

监控 缓存命中率 和 缓存填充率，确保缓存系统的健康运行。
对 缓存容量、加载时间、过期时间、缓存清除策略 等进行实时监控，及时调整系统参数。
8. 分布式缓存的结合
在极高 QPS 的情况下，单机本地缓存 可能无法承载如此大的流量，此时可以考虑使用 分布式缓存（如 Redis、Memcached 等）作为备份或辅助缓存。

分布式缓存 提供了跨机器的缓存能力，能有效扩展缓存容量和处理高并发的请求。
与本地缓存结合，采用 分层缓存 模型，将常用的数据放在本地缓存中，其他数据存储在 Redis 等分布式缓存中。
## 小结
当面对每秒 2000 万（QPS）的请求时，本地缓存和分布式缓存的设计需要特别注意：

使用 高效的缓存库（如 Caffeine）来处理高并发的缓存读写。
合理设置缓存的 大小限制 和 过期策略，避免内存溢出和缓存过载。
通过 多级缓存、异步加载、缓存预加载 和 限流机制 来减轻系统负载，确保系统的稳定性和性能。
缓存穿透、缓存雪崩 和 缓存击穿 的问题也需要特别注意，通过布隆过滤器、过期时间随机化、加锁等机制来应对。
如果有更多关于高并发缓存设计的具体问题，随时可以提问！