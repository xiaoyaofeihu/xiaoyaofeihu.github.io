---
title: List中的遍历方式
date: 2024-10-10 17:33:00
tags:
	- 集合
categories: java
---

+ 在Java中，遍历并修改一个List集合是一个常见的操作，但如果不小心处理，可能会遇到`ConcurrentModificationException`异常，这通常是因为在遍历过程中直接修改了集合的结构（如添加、删除元素）。下面是你提到的几种处理方案及其详细解释：

1. **通过普通的for循环（不建议，可能会漏删）**：
   使用普通的for循环遍历List，并通过索引直接修改或删除元素。这种方法的问题是，如果删除元素后没有相应地调整索引（例如，连续删除元素时），可能会导致跳过某些元素的检查或索引越界异常。

2. **通过普通的for循环进行倒序遍历**：
   倒序遍历可以避免因删除元素而导致的索引调整问题，因为即使删除了元素，后面的元素索引也不会改变（相对于当前遍历方向）。这种方法可以有效避免漏删的问题。

3. **使用迭代器循环**：
   迭代器提供了一种安全的方式来遍历并修改集合。使用迭代器的`remove`方法可以安全地删除当前元素，而不会触发`ConcurrentModificationException`。注意，不能使用集合的`remove`方法，而应该使用迭代器的`remove`方法。

4. **复制列表**：
   创建一个原始列表的副本，遍历原始列表，同时在副本上进行删除操作。这种方法是fail-safe的，因为遍历和修改发生在不同的列表上。但这种方法相对复杂，且需要额外的内存来存储副本。此外，如果列表中的元素是复杂对象，可能需要正确地实现`equals`和`hashCode`方法以确保正确的删除。

5. **使用并发安全的集合类**：
   使用如`CopyOnWriteArrayList`这样的线程安全的集合类。这种集合类在修改时创建集合的副本，因此遍历和修改可以安全地进行，但这也可能导致在大量修改时性能下降，因为每次修改都需要复制整个集合。

6. **使用Stream的过滤方法**：
   Java 8引入的Stream API提供了一种声明性的方式来处理集合。通过`filter`方法，可以创建一个新的Stream，只包含满足特定条件的元素。然后，可以使用`collect`方法将结果收集到一个新的列表中。这种方法简单高效，因为它避免了在遍历过程中直接修改原始集合。

7. **通过`removeIf`方法**：
   Java 8的`List`接口引入了`removeIf`方法，它接受一个谓词（Predicate），并删除所有满足该谓词的元素。这是一个非常简洁和高效的方法，用于根据条件删除元素。

综上所述，每种方法都有其适用的场景和优缺点。在选择方法时，应考虑集合的大小、修改的频率、内存使用以及对性能的要求。对于大多数情况，使用`removeIf`或Stream的`filter`方法是推荐的做法，因为它们既简单又高效。