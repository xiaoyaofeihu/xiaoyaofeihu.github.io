---
title: 学习笔记
date: 2024-11-15 13:33:41
tags:
	- 项目
categories: 笔记
---

# springcloud服务中使用mq做消息的通知，相对于fegin有什么好处



## 在 Spring Cloud 服务中使用 消息队列（如 RabbitMQ、Kafka 等）来处理消息通知，相对于 Feign 进行同步调用，具有多个优势，特别是在分布式系统中。这些好处主要体现在 解耦性、可靠性、性能和可扩展性 等方面。下面详细列出它们的优缺点对比：

## 1. 解耦性
+ 消息队列：使用消息队列时，生产者（发送方）和消费者（接收方）是松耦合的，即使消费者不可用，消息队列仍然可以存储消息，等待消费者处理。这种异步的方式减少了服务之间的直接依赖，增强了系统的解耦性。
+ Feign：Feign 是一种同步调用方式，服务 A 直接调用服务 B，服务之间是强耦合的。如果服务 B 不可用，服务 A 会失败，依赖关系比较紧密。

### 优点：

+ 消息队列：更容易扩展服务，减少服务间的直接依赖。
+ Feign：服务间的直接调用，导致服务耦合性较强，依赖性高。

## 2. 可靠性
+ 消息队列：消息队列一般会提供消息持久化、重试机制、死信队列等功能，保证消息在系统出现故障时不会丢失，能够在消费者恢复后重新处理。即使服务 A 出现故障，消息依然可以在队列中等待消费。
+ Feign：Feign 调用是同步的，如果服务 B 出现故障，Feign 请求会直接失败，且一般不具备自动重试和消息持久化功能。
### 优点：

+ 消息队列：提供消息持久化、重试机制，能确保消息不丢失。
+ Feign：服务失败时请求会直接失败，除非使用像 Ribbon 或 Hystrix 这样的断路器进行处理。

## 3. 异步与性能
+ 消息队列：消息队列是异步处理的，即生产者发送完消息后，不需要等待消费者处理结果。生产者可以继续执行其他任务，消息队列通过缓冲提高系统吞吐量。当系统负载较高时，消费者可以批量消费消息，提高处理效率。
+ Feign：Feign 是同步的，发送请求后，调用方必须等待服务返回结果，可能会导致性能瓶颈，特别是当多个服务调用彼此依赖时，响应时间可能会增加。
### 优点：

+ 消息队列：通过异步处理提高系统吞吐量和性能，适合处理高并发、高负载的场景。
+ Feign：同步请求，可能会成为性能瓶颈，尤其在服务间相互调用较多时。
## 4. 可伸缩性
+ 消息队列：消息队列可以在消费者端进行水平扩展。例如，消费者可以横向扩展多个实例来处理消息，从而提升系统的处理能力。消息队列会自动将消息分发给空闲的消费者实例，提高系统的可伸缩性。
+ Feign：Feign 本身并不具备内建的负载均衡功能，虽然可以使用 Spring Cloud 的负载均衡组件（如 Ribbon），但它依赖于同步请求，因此在高并发场景下扩展性较差。
### 优点：

+ 消息队列：通过消费端的水平扩展，提高系统的可伸缩性。
+ Feign：虽然有负载均衡，但扩展性主要依赖于同步调用方式，可能会受到性能瓶颈的限制。

## 5. 流量控制与限流
+ 消息队列：消息队列通常支持流量控制。比如，消费者的处理速度低于生产者的发送速度时，消息队列可以进行流量调节，避免系统被大量消息打垮。此外，死信队列、延时队列等功能可以帮助处理异常消息，避免堆积。
+ Feign：Feign 是同步请求，不适合处理流量控制。如果请求量激增，可能会导致服务出现超时或者崩溃。
### 优点：

+ 消息队列：可以通过流量控制机制、死信队列、延时队列等功能保证系统稳定性。
+ Feign：不适合直接进行流量控制，可能导致系统超载。
## 6. 消息顺序
+ 消息队列：许多消息队列系统（如 Kafka 和 RabbitMQ）都支持消息的顺序保证，尤其在处理同一个主题或队列中的消息时，可以确保消息按顺序被消费。对于需要保证顺序消费的场景，消息队列是非常适合的。
+ Feign：Feign 的调用是同步的，但它不保证请求的顺序和消费顺序。多个服务之间的调用是按顺序发生的，但并不适用于保证消息顺序。
### 优点：

+ 消息队列：可以确保消息顺序性，适合需要严格顺序的场景。
+ Feign：没有内建的顺序保证机制。
## 7. 场景适配
+ 消息队列：适用于以下场景：

> 事件驱动的应用，异步通知、推送；
高并发、高吞吐量的系统；
系统解耦，避免微服务之间的直接调用；
消息延迟处理或异步处理的场景。
+ Feign：适用于以下场景：

>服务间的同步调用，需要立即得到返回值；
处理简单的请求-响应模式；
服务间的低延迟、低耦合调用。
## 8. 总结
| 特性         | **消息队列**                              | **Feign**                          |
|--------------|-------------------------------------------|------------------------------------|
| **耦合性**   | 松耦合，生产者和消费者分离               | 强耦合，服务间直接调用             |
| **可靠性**   | 提供消息持久化、重试机制                 | 依赖于服务的可用性，失败时没有自动恢复 |
| **性能**     | 异步，适合高并发、高吞吐量的场景         | 同步，可能成为性能瓶颈            |
| **可伸缩性** | 通过水平扩展消费者来提高可伸缩性         | 依赖于负载均衡，扩展有限          |
| **流量控制** | 可以控制流量，避免系统过载               | 没有流量控制机制                  |
| **消息顺序** | 可以保证消息顺序                         | 不保证消息顺序                    |
| **场景适配** | 事件驱动、异步通知、大量消息处理         | 服务间同步调用、低延迟处理        |

## 总结
### 使用 消息队列（如 RabbitMQ、Kafka）更适合于 高并发、异步、解耦、事件驱动 的场景，能够提高系统的可靠性、性能和扩展性。
### 使用 Feign 更适合 同步调用、简单的请求-响应模式、低延迟 的服务间通信。